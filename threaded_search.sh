#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: cbuild.sh
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> -Wno-unused-parameter \\\\\\\\
-Wno-unused-result \\\\\\\\
-Wfatal-errors -std=c99 \\\\\\\\@??!.-5,.+5p\@p FAIL line 49\@q!@;=
@.+2a -lpthread \\\\
.
@vis 4@wq" $VI -e 'cbuild.sh'

# Patch: lbuf.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	return n != 0;
\\\\}
@??!.-5,.+5p\@p FAIL line 482\@q!@;=
@.+3,#+12c struct lsparams
{
	struct lbuf *lb;
	rset *re;
	int dir;
	int beg;
	int end;
	int *r;
	int *o;
	int off;
	int nskip;
};

static void *lsearch(void *arg)
{
	struct lsparams *a = arg;
	int r0 = *a->r, o0 = *a->o;
	int offs[a->re->nsubc], i = r0;
	char *s;
	int off = a->off, g1, g2, _o, step, flg;
	for (; i >= a->beg && i < a->end; i += a->dir) {
.
@.,$;f+ 		_o = 0;
		step = 0;
		flg = REG_NEWLINE;@??!.-5,.+5p\@p FAIL line 498\@q!@;=
@.+3,#+1c 		s = a->lb->ln[i];
		while (rset_find(a->re, s + off, offs, flg) >= 0) {
.
@.,$;f+ 				continue;
			\\\\}
			_o \\\\+= uc_off\\\\(s \\\\+ step, off \\\\+ g1 - step\\\\);@??!.-5,.+5p\@p FAIL line 507\@q!@;=
@.+3c 			if (a->dir < 0 && r0 == i && _o > o0 - a->nskip)
.
@.-1@>				break;>+1,#+3c 			*a->o = _o;
			*a->r = i;
.
@??!.-5,.+5p\@p FAIL line 509\@q!@.,$;f+ 			step = off \\\\+ g1;
			off \\\\+= g2 > 0 \\\\? g2 : 1;@??!.-5,.+5p\@p FAIL line 515\@q!@;=
@.+2c 			a->end = -1; /* break outer loop efficiently */
			if (a->dir > 0)
				return NULL;
.
@.,$;f+ 		\\\\}
		off = 0;
	\\\\}@??!.-5,.+5p\@p FAIL line 519\@q!@;=
@.+3c 	return NULL;
}

int lbuf_search(struct lbuf *lb, rset *re, int dir, int beg, int end, int pskip,
		int nskip, int *r, int *o)
{
	#define NUM_THREADS 4
	pthread_t threads[NUM_THREADS];
	static unsigned char fake_ulen[256]; /* novelty: for fast thread termination */
	struct lsparams data[NUM_THREADS];
	int rs[NUM_THREADS];
	int os[NUM_THREADS];
	int thread_step = end / NUM_THREADS; /* number of lines assigned per thread */
	int step = 0, i = 0, off;
	char *s = lbuf_get(lb, *r);
	if (pskip >= 0 && s)
		off = rstate->s == s ? rstate->chrs[MIN(*o + pskip, rstate->n)] - s
					: uc_chr(s, *o + pskip) - s;
	else
		off = 0;
	utf8_length['\\\\n'] = 0;
	for (i = 0; i < NUM_THREADS; i++) {
		if (*r + step > end || *r + step * dir < 0)
			break;
		data[i].lb = lb;
		data[i].re = re;
		data[i].dir = dir;
		data[i].off = i ? 0 : off;
		rs[i] = *r + step * dir;
		step += thread_step;
		data[i].r = &rs[i];
		data[i].beg = beg;
		data[i].nskip = nskip;
		if (i == NUM_THREADS-1)
			data[i].end = end;
		else
			data[i].end = MIN(rs[i] + thread_step, end);
		os[i] = i ? -1 : *o;
		data[i].o = &os[i];
		pthread_create(&threads[i], NULL, lsearch, (void*) &data[i]);
	}
	for (step = i, i = 0; i < step; i++) {
		pthread_join(threads[i], NULL);
		if (data[i].end < 0) {
			*r = *data[i].r;
			*o = *data[i].o;
			for (int z = i+1; z < step; z++)
				data[z].end = -1;
			/* force instant termination, regardless how long string is */
			utf8_length = fake_ulen;
			for (int z = i+1; z < step; z++)
				pthread_join(threads[z], NULL);
			utf8_length = _utf8_length;
			utf8_length['\\\\n'] = 1;
			return 0;
		}
	}
	utf8_length['\\\\n'] = 1;
	return 1;
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: regex.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	return 0;
\\\\}
@??!.-5,.+5p\@p FAIL line 402\@q!@;=
@.+3;29;35c flg & REG_NEWLINE
.
@.,$;f+ 	char nsubs\\\\[prog->sub\\\\];
	for \\\\(i = 0; i < prog->laidx; i\\\\+\\\\+\\\\)
		lb\\\\[i\\\\] = NULL;@??!.-5,.+5p\@p FAIL line 642\@q!@;=
@.+3;11c  && utf8_length[eol_ch]
.
@.-1@>		utf8_length\\[eol_ch\\] = 0;>a 	else
		flg &= ~REG_NEWLINE;
.
@??!.-5,.+5p\@p FAIL line 643\@q!@vis 4@wq" $VI -e 'regex.c'

# Patch: uc.c
EXINIT="rcm:|sc! \\\\@|vis 6@>	/\\*	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F \\*/>-1;14c _
.
@??!.-5,.+5p\@p FAIL line 1\@q!@%;f> 	/\\\\* E \\\\*/ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	/\\\\* F \\\\*/ 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1
\\\\};@??!.-5,.+5p\@p FAIL line 19\@q!@;=
@.+2a unsigned char *utf8_length = _utf8_length;
.
@vis 4@wq" $VI -e 'uc.c'

# Patch: vi.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> #include <sys/stat\\\\.h>
#include <sys/ioctl\\\\.h>
#include <sys/wait\\\\.h>@??!.-5,.+5p\@p FAIL line 15\@q!@;=
@.+2a #include <pthread.h>
.
@vis 4@wq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> void syn_init\\\\(void\\\\);

/\\\\* uc\\\\.c utf-8 helper functions \\\\*/@??!.-5,.+5p\@p FAIL line 274\@q!@;=
@.+3c extern unsigned char _utf8_length[256];
extern unsigned char *utf8_length;
.
@vis 4@wq" $VI -e 'vi.h'
