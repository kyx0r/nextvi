#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Patch: cbuild.sh
EXINIT="rcm:|sc! @|vis 6@49a -lpthread \\
.
@vis 4@wq" $VI -e 'cbuild.sh'

# Patch: lbuf.c
EXINIT="rcm:|sc! @|vis 6@473c 	return NULL;
}

int lbuf_search(struct lbuf *lb, rset *re, int dir, int beg, int end, int pskip,
		int nskip, int *r, int *o)
{
	#define NUM_THREADS 4
	pthread_t threads[NUM_THREADS];
	static unsigned char fake_ulen[256]; /* novelty: for fast thread termination */
	struct lsparams data[NUM_THREADS];
	int rs[NUM_THREADS];
	int os[NUM_THREADS];
	int thread_step = end / NUM_THREADS; /* number of lines assigned per thread */
	int step = 0, i = 0, off;
	char *s = lbuf_get(lb, *r);
	if (pskip >= 0 && s)
		off = rstate->s == s ? rstate->chrs[MIN(*o + pskip, rstate->n)] - s
					: uc_chr(s, *o + pskip) - s;
	else
		off = 0;
	utf8_length['\\n'] = 0;
	for (i = 0; i < NUM_THREADS; i++) {
		if (*r + step > end || *r + step * dir < 0)
			break;
		data[i].lb = lb;
		data[i].re = re;
		data[i].dir = dir;
		data[i].off = i ? 0 : off;
		rs[i] = *r + step * dir;
		step += thread_step;
		data[i].r = &rs[i];
		data[i].beg = beg;
		data[i].nskip = nskip;
		if (i == NUM_THREADS-1)
			data[i].end = end;
		else
			data[i].end = MIN(rs[i] + thread_step, end);
		os[i] = i ? -1 : *o;
		data[i].o = &os[i];
		pthread_create(&threads[i], NULL, lsearch, (void*) &data[i]);
	}
	for (step = i, i = 0; i < step; i++) {
		pthread_join(threads[i], NULL);
		if (data[i].end < 0) {
			*r = *data[i].r;
			*o = *data[i].o;
			for (int z = i+1; z < step; z++)
				data[z].end = -1;
			/* force instant termination, regardless how long string is */
			utf8_length = fake_ulen;
			for (int z = i+1; z < step; z++)
				pthread_join(threads[z], NULL);
			utf8_length = _utf8_length;
			utf8_length['\\n'] = 1;
			return 0;
		}
	}
	utf8_length['\\n'] = 1;
	return 1;
.
@vis 4@vis 6@469c 			a->end = -1; /* break outer loop efficiently */
			if (a->dir > 0)
				return NULL;
.
@vis 4@vis 6@463,466c 			*a->o = _o;
			*a->r = i;
.
@vis 4@vis 6@461c 			if (a->dir < 0 && r0 == i && _o > o0 - a->nskip)
.
@vis 4@vis 6@452,453c 		s = a->lb->ln[i];
		while (rset_find(a->re, s + off, offs, flg) >= 0) {
.
@vis 4@vis 6@439,448c 	struct lbuf *lb;
	rset *re;
	int dir;
	int beg;
	int end;
	int *r;
	int *o;
	int off;
	int nskip;
};

static void *lsearch(void *arg)
{
	struct lsparams *a = arg;
	int r0 = *a->r, o0 = *a->o;
	int offs[a->re->nsubc], i = r0;
	char *s;
	int off = a->off, g1, g2, _o, step, flg;
	for (; i >= a->beg && i < a->end; i += a->dir) {
.
@vis 4@vis 6@436,437c struct lsparams
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: regex.c
EXINIT="rcm:|sc! @|vis 6@643a 	else
		flg &= ~REG_NEWLINE;
.
@vis 4@vis 6@642c 	if (eol_ch && utf8_length[eol_ch])
.
@vis 4@vis 6@402c #define _return(state) { if (flg & REG_NEWLINE) utf8_length[eol_ch] = 1; return state; } \\
.
@vis 4@wq" $VI -e 'regex.c'

# Patch: uc.c
EXINIT="rcm:|sc! @|vis 6@19a unsigned char *utf8_length = _utf8_length;
.
@vis 4@vis 6@1c unsigned char _utf8_length[256] = {
.
@vis 4@wq" $VI -e 'uc.c'

# Patch: vi.c
EXINIT="rcm:|sc! @|vis 6@15a #include <pthread.h>
.
@vis 4@wq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! @|vis 6@271c extern unsigned char _utf8_length[256];
extern unsigned char *utf8_length;
.
@vis 4@wq" $VI -e 'vi.h'
