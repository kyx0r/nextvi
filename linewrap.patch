diff --git a/ex.c b/ex.c
index 302af98e..602affa7 100644
--- a/ex.c
+++ b/ex.c
@@ -21,6 +21,7 @@ int xpr;			/* ex_cprint register */
 int xsep = ':';			/* ex command separator */
 int xlim = -1;			/* rendering cutoff for non cursor lines */
 int xseq = 1;			/* undo/redo sequence */
+int xlw;			/* soft linewrap col */
 
 int xrow, xoff, xtop;		/* current row, column, and top row */
 int xbufcur;			/* number of active buffers */
@@ -1175,6 +1176,23 @@ static void *ec_setenc(char *loc, char *cmd, char *arg)
 	return NULL;
 }
 
+static void *ec_linewrap(char *loc, char *cmd, char *arg)
+{
+	int fd;
+	if (xb->modified)
+		return "unsaved changes present";
+	if (*arg)
+		xlw = atoi(arg);
+	else
+		xlw = xcols;
+	lbuf_free(xb);
+	xb = lbuf_make();
+	readfile()
+	ex_bufpostfix(ex_buf, 1);
+	syn_setft(xb_ft);
+	return NULL;
+}
+
 static int eo_val(char *arg)
 {
 	int val = atoi(arg);
@@ -1279,6 +1297,7 @@ static struct excmd {
 	EO(left),
 	EO(lim),
 	EO(led),
+	{"lw", ec_linewrap},
 	EO(vis),
 	EO(mpt),
 	{"=", ec_num},
diff --git a/lbuf.c b/lbuf.c
index 884b7807..1081c9da 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -82,16 +82,50 @@ static int lbuf_replace(struct lbuf *lb, sbuf *sb, char *s, struct lopt *lo, int
 {
 	int i, pos = lo->pos;
 	if (s) {
+		char *lwp = NULL;
 		for (; *s; n_ins++) {
 			int l = linelength(s);
 			int l_nonl = l - (s[l - !!l] == '\n');
 			struct linfo *n = emalloc(l_nonl + 7 + sizeof(struct linfo));
 			n->len = l_nonl;
 			n->grec = 0;
+			n->lw_prev = NULL;
+			n->lw_next = NULL;
 			char *ln = (char*)(n + 1);
 			memcpy(ln, s, l_nonl);
 			memset(&ln[l_nonl + 1], 0, 5);	/* fault tolerance pad */
 			ln[l_nonl] = '\n';
+			if (xlw) {
+				rstate->s = NULL;
+				ren_state *r = ren_position(ln);
+				if (r->cmax > xlw) {
+					l_nonl = l;
+					l = uc_chr(r->s, r->col[xlw]) - r->s;
+					if (l <= 0) {
+						l = l_nonl;
+						goto too_small;
+					}
+					l_nonl = l - (ln[l - !!l] == '\n');
+					n = erealloc(n, l_nonl + 7 + sizeof(struct linfo));
+					n->len = l_nonl;
+					n->grec = 0;
+					n->lw_prev = lwp;
+					n->lw_next = NULL;
+					ln = (char*)(n + 1);
+					if (lwp)
+						lbuf_s(lwp)->lw_next = ln;
+					lwp = ln;
+					memcpy(ln, s, l_nonl);
+					memset(&ln[l_nonl + 1], 0, 5);	/* fault tolerance pad */
+					ln[l_nonl] = '\n';
+				} else {
+					if (lwp)
+						lbuf_s(lwp)->lw_next = ln;
+					n->lw_prev = lwp;
+					lwp = NULL;
+				}
+			}
+			too_small:
 			sbuf_mem(sb, &ln, (int)sizeof(s))
 			s += l;
 		}
@@ -237,7 +271,7 @@ int lbuf_wr(struct lbuf *lb, int fd, int beg, int end)
 	for (int i = beg; i < end; i++) {
 		char *ln = lb->ln[i];
 		long nw = 0;
-		long nl = lbuf_s(ln)->len + 1;
+		long nl = lbuf_s(ln)->len + (!lbuf_s(ln)->lw_next);
 		while (nw < nl) {
 			long nc = write(fd, ln + nw, nl - nw);
 			if (nc < 0)
diff --git a/vi.c b/vi.c
index 6c69814b..f0c32680 100644
--- a/vi.c
+++ b/vi.c
@@ -169,6 +169,22 @@ static void vi_drawrow(int row)
 		return;
 	}
 	s = lbuf_get(xb, row);
+	if (xlw && s) {
+		led_att la;
+		if (!led_attsb)
+			sbuf_make(led_attsb, sizeof(la))
+		if (lbuf_s(s)->lw_next && !lbuf_s(s)->lw_prev) {
+			la.s = s;
+			la.off = 0;
+			la.att = SYN_BGMK(8);
+			sbuf_mem(led_attsb, &la, (int)sizeof(la))
+		} else if (!lbuf_s(s)->lw_next && lbuf_s(s)->lw_prev) {
+			la.s = s;
+			la.off = ren_position(s)->n-1;
+			la.att = SYN_BGMK(9);
+			sbuf_mem(led_attsb, &la, (int)sizeof(la))
+		}
+	}
 	skip:
 	rstate += row != xrow;
 	if (!s)
diff --git a/vi.h b/vi.h
index c0cb10d8..67348a03 100644
--- a/vi.h
+++ b/vi.h
@@ -144,6 +144,8 @@ struct lopt {
 struct linfo {
 	int len;
 	int grec;
+	char *lw_prev;
+	char *lw_next;
 };
 struct lbuf {
 	char **ln;			/* buffer lines */
