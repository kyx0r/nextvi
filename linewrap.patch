diff --git a/lbuf.c b/lbuf.c
index 18131f8..30a6ba1 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -137,9 +137,50 @@ static void lbuf_replace(struct lbuf *lb, char *s, struct lopt *lo, int n_del, i
 			(lb->ln_n - pos - n_del) * sizeof(lb->ln_glob[0]));
 	}
 	lb->ln_n += n_ins - n_del;
-	for (i = 0; i < n_ins; i++) {
+	for (i = 0; i < n_ins;) {
 		int l = linelength(s);
 		int l_nonl = l - (s[l - !!l] == '\n');
+		int *rpos, nn, left = xcols;
+		char **chrs;
+		preserve(int, xorder, 0)
+		char tmp = s[l];
+		s[l] = '\0';
+		rpos = ren_position(s, &chrs, &nn);
+		s[l] = tmp;
+		restore(xorder)
+		while (rpos[nn] > left) {
+			l_nonl = chrs[left] - chrs[left - xcols];
+			p("%d %d\n", rpos[nn], l_nonl)
+			char *n = emalloc(l_nonl + 7 + sizeof(int));
+			*(int*)n = l_nonl;		/* store length */
+			n += sizeof(int);
+			memcpy(n, s, l_nonl);
+			memset(&n[l_nonl + 1], 0, 5);	/* fault tolerance pad */
+			n[l_nonl] = '\n';
+			s += l_nonl;
+			n_ins++;
+			while (lb->ln_n + n_ins >= lb->ln_sz) {
+				int nsz = lb->ln_sz + (lb->ln_sz ? lb->ln_sz : 512);
+				char **nln = emalloc(nsz * sizeof(nln[0]));
+				char *nln_glob = emalloc(nsz * sizeof(nln_glob[0]));
+				memcpy(nln, lb->ln, lb->ln_n * sizeof(lb->ln[0]));
+				memcpy(nln_glob, lb->ln_glob, lb->ln_n * sizeof(lb->ln_glob[0]));
+				free(lb->ln);
+				free(lb->ln_glob);
+				lb->ln = nln;
+				lb->ln_glob = nln_glob;
+				lb->ln_sz = nsz;
+			}
+			memmove(lb->ln + pos + n_ins, lb->ln + pos,
+				(lb->ln_n - pos) * sizeof(lb->ln[0]));
+			memmove(lb->ln_glob + pos + n_ins, lb->ln_glob + pos,
+				(lb->ln_n - pos) * sizeof(lb->ln_glob[0]));
+			lb->ln[pos + i] = n;
+			i++;
+			left += xcols;
+		}
+		if (left != xcols)
+			continue;
 		char *n = emalloc(l_nonl + 7 + sizeof(int));
 		*(int*)n = l_nonl;		/* store length */
 		n += sizeof(int);
@@ -148,6 +189,7 @@ static void lbuf_replace(struct lbuf *lb, char *s, struct lopt *lo, int n_del, i
 		n[l_nonl] = '\n';
 		lb->ln[pos + i] = n;
 		s += l;
+		i++;
 	}
 	for (i = n_del; i < n_ins; i++)
 		lb->ln_glob[pos + i] = 0;
