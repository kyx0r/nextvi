.Dd Nov 1, 2024
.Dt Nextvi 1
.Os
.
.Sh NAME
.Nm Nextvi
.Nd A small vi/ex editor for editing bidirectional UTF-8 text
.
.Sh SYNOPSIS
.Nm vi
.Op Fl emsv
.Op Ar
.
.Sh DESCRIPTION
.Nm Nextvi
is a
.Xr vi 1 Ns -like
text editor based on Ali Gholami Rudi's
.Xr Neatvi 1 Ns .
VI is a legendary command-line text editor, first introduced
by Bill Joy in 1976, renowned for its modal interface, which
allows users to switch between insert, command, and visual modes
for seamless text manipulation. This powerful and efficient
editor has stood the test of time, remaining a staple tool for
developers and system administrators in Unix and Linux environments,
thanks to its flexibility, customization options, and syntax
similar to other vi/ex editors. To mark its 50th anniversary,
Nextvi emerges as the pinnacle of VI's evolution. This masterpiece
of efficiency and elegance boasts unparalleled startup speed,
unmatched portability, exceptional hackability, and an incredibly
robust macro system, among other features. Nextvi is truly the
next generation of VI, ready to elevate your text editing experience.
.
.Sh OPTIONS
.Bl -tag -width Ds -compact
.It Fl e
Enter Ex mode on startup
.It Fl m
Disable initial file read message
.It Fl s
Enter raw Ex mode on startup
.It Fl v
Enter visual mode on startup (Default)
.El
.Sh MANPAGE NOTATION
.Bl -tag -width Ds -compact
.It Cm <x>
A closure where x represents character literal
.It Cm [x]
A closure where x represents optional argument
.It Cm {x}
A closure where x represents required argument
.It Cm <^X>
Represents a ctrl key X
.It Cm #
Represents a positive number in a closure
.It Cm *
Represents any character(s) in a closure
.It Cm < >
Separates alternatives in a closure
.El
.Sh VI NORMAL
.Bl -tag -width Dq -compact
.It Cm [#]+
.It Cm [#]j
.It Cm [#]<^M>
.It Cm [#]<Newline>
.Bd -compact
Move # lines down
.Ed
.It Cm [#]-
.It Cm [#]k
.Bd -compact
Move # lines up
.Ed
.It Cm [#]h
Move # cols left
.It Cm [#]l
Move # cols right
.It Cm f{arg}
Move to arg character found forward
.It Cm F{arg}
Move to arg character found backward
.It Cm t{arg}
Move until arg character found forward
.It Cm T{arg}
Move until arg character found backward
.It Cm [#],
Repeat last <f F t T> move backward # times
.It Cm [#];
Repeat last <f F t T> move forward # times
.It Cm [#]B
Move to end of word, skip punctuation backward # times
.It Cm [#]E
Move to end of word, skip punctuation forward # times
.It Cm [#]b
Move to end of word backward # times
.It Cm [#]e
Move to end of word forward # times
.It Cm [#]W
Move to start of word, skip punctuation forward # times
.It Cm [#]w
Move to start of word forward # times
.It Cm {
Move to next <{> section up
.It Cm }
Move to next <{> section down
.It Cm \&[
Move to next <Newline> section up
.It Cm \&]
Move to next <Newline> section down
.It Cm ^
Move to start of line after indentation
.It Cm 0
Move to start of line
.It Cm $
Move to end of line
.It Cm [#]|
Goto # col
.It Cm [#]<Space>
Move # characters forward
.It Cm [#]<^H>
.It Cm [#]<Backspace>
.Bd -compact
Move # characters backward
.Ed
.It Cm %
Move to [](){} pair
.It Cm [#]%
Move to # percent line number
.It Cm '{arg}
Move to a line mark arg
.It Cm `{arg}
Move to a line mark arg with cursor position
.It Cm gg
Goto first line in buffer
.It Cm [#]G
Move to last line in buffer or # line
.It Cm H
Move to highest line on a screen
.It Cm L
Move to lowest line on a screen
.It Cm M
Move to middle line on a screen
.It Cm [#]z.
Center screen at cursor. # is xtop
.It Cm [#]z<^M>
.It Cm [#]z<Newline>
.Bd -compact
Center screen at top row. # is xtop
.Ed
.It Cm [#]z-
Center screen at bottom row. # is xtop
.It Cm [#]<^E>
Scroll down 1 or # lines, retain # and cursor position
.It Cm [#]<^Y>
Scroll up 1 or # lines, retain # and cursor position
.It Cm [#]<^D>
Scroll down half a screen size. If # set scroll to # lines
.It Cm [#]<^U>
Scroll up half a screen size. If # set scroll to # lines
.It Cm <^B>
Scroll up full screen size
.It Cm <^F>
Scroll down full screen size
.It Cm #
Show global and relative line numbers
.It Cm 2#
Toggle show global line numbers permanently
.It Cm 4#
Toggle show relative line numbers after indentation permanently
.It Cm 8#
Toggle show relative line numbers permanently
.It Cm V
Toggle show hidden characters:<Space Tab Newline>
.It Cm <^V>
Toggle show line motion numbers for ebEBwW
.It Cm [#]<^V>
Disable line motion numbers
.It Cm [#]<^R>
Redo # times
.It Cm [#]u
Undo # times
.It Cm <^I>
.It Cm <Tab>
.Bd -compact
Open file path from cursor to end of line
.Ed
.It Cm <^K>
Write current buffer to file. Force write on 2nd attempt
.It Cm [#]<^W>{arg}
Unindent arg region # times
.It Cm [#]<{arg}
Indent left arg region # times
.It Cm [#]>{arg}
Indent right arg region # times
.It Cm \&"{arg}{arg1}
Operate on arg register according to arg1 motion
.It Cm R
Print registers and their contents
.It Cm [#]&{arg}
Execute arg register macro in non-blocking mode # times
.It Cm [#]@{arg}
Execute arg register macro in blocking mode # times
.It Cm [#]@@
.It Cm [#]&&
.Bd -compact
Execute a last executed register macro # times
.Ed
.It Cm [#].
Repeat last normal command # times
.It Cm [#]v.
Repeat last normal command moving down across # lines
.It Cm \&:
Enter ex prompt
.It Cm [#]!{arg}
Enter pipe ex prompt based on region # or arg
.It Cm vv
Enter ex prompt with the last ex command from history
.It Cm [#]vr
Enter %s/ ex prompt. Insert # words from cursor
.It Cm [#]vt[#arg]
Enter .,.+0s/ ex prompt. Insert # of lines from cursor. Insert #arg words from cursor
.It Cm [#]v/
Enter v/ xkwd ex prompt to set search keyword. Insert # words from cursor
.It Cm v;
Enter ! ex prompt
.It Cm [#]vi
Enter %s/ ex prompt. Contains regex for changing spaces to tabs. # modifies tab width
.It Cm [#]vI
Enter %s/ ex prompt. Contains regex for changing tabs to spaces. # modifies tab width
.It Cm vo
Remove trailing white spaces and <\er> line endings
.It Cm va
Toggle autoindent on or off. see ai ex option
.It Cm <^G>
Print buffer status infos
.It Cm 1<^G>
Enable permanent status bar row
.It Cm 2<^G>
Disable permanent status bar row
.It Cm ga
Print character info
.It Cm 1ga
Enable permanent character info bar row
.It Cm 2ga
Disable permanent character info bar row
.It Cm [#]gw
Hard line wrap a line to # col limit
.It Cm [#]gq
Hard line wrap a buffer to # col limit
.It Cm g~{arg}
Switch character case for arg region
.It Cm gu{arg}
Switch arg region to lowercase
.It Cm gU{arg}
Switch arg region to uppercase
.It Cm [#]~
Switch character case # times forward
.It Cm i
Enter insert mode
.It Cm I
Enter insert mode at start of line after indentation
.It Cm A
Enter insert mode at end of line
.It Cm a
Enter insert mode 1 character forward
.It Cm [#]s
Enter insert mode and delete # characters
.It Cm S
Enter insert mode and delete all characters
.It Cm o
Enter insert mode and create a new line down
.It Cm O
Enter insert mode and create a new line up
.It Cm [#]c{arg}
Enter insert mode and delete arg region # times
.It Cm C
Enter insert mode and delete from cursor to end of line
.It Cm [#]d{arg}
Delete arg region # times
.It Cm D
Delete from cursor to end of line
.It Cm [#]x
Delete # characters from cursor forward
.It Cm [#]X
Delete # characters from cursor backward
.It Cm di{arg}
Delete around arg which can be <( ) \&">
.It Cm ci{arg}
Change around arg which can be <( ) \&">
.It Cm [#]r{arg}
Replace # characters with arg from cursor forward
.It Cm K
Split a line
.It Cm [#]K
Split a line without creating <Newline>
.It Cm [#]J
Join # lines
.It Cm vj
Toggle space padding when joining lines
.It Cm [#]y{arg}
Yank arg region # times
.It Cm [#]Y
Yank # lines
.It Cm [#]p
Paste default register # times
.It Cm [#]P
Paste default register below current line or behind cursor position # times
.It Cm m{arg}
Set buffer local line mark arg
.It Cm <^T>
Set global line mark 0. Global marks are always valid
.It Cm [#]<^T>
Set or switch to a global mark based on # % 2 == 0
.It Cm [#]<^7>
.It Cm [#]<^_>
.Bd -compact
Show buffer list and switch based on # or 0-9 index when prompted
.Ed
.It Cm <^^>
.It Cm <^6>
.Bd -compact
Swap to previous buffer
.Ed
.It Cm [#]<^N>
Swap to next buffer, # changes direction [forward backward]
.It Cm \e
Swap to /fm/ buffer b-2
.It Cm [#]\e
Swap from /fm/ buffer b-2 and backfill directory listing
.It Cm vb
Recurse into b-1 history buffer. Insert current line into ex prompt after a quit command
.It Cm z{#}
Set alternative keymap to # keymap
.It Cm ze
Switch to English keymap
.It Cm zf
Switch to alternative keymap
.It Cm zL
Set td ex option to 2
.It Cm zl
Set td ex option to 1
.It Cm zr
Set td ex option to -1
.It Cm zR
Set td ex option to -2
.It Cm [#]/
Regex search, move down 1 or # matches
.It Cm [#]?
Regex search, move up 1 or # matches
.It Cm [#]n
.It Cm [#]N
.Bd -compact
Repeat regex search, move [down up] 1 or # matches
.Ed
.It Cm <^A>
Regex search 1 word from cursor, no center, wraparound move [up down]
.It Cm {#}<^A>
Regex search, set keyword to # words from cursor
.It Cm <^]>
Filesystem search forward based on directory listing in b-2
.It Cm {#}<^]>
Filesystem search forward, set keyword to # words from cursor
.It Cm <^P>
Filesystem search backward based on directory listing in b-2
.It Cm {#}<^P>
Filesystem search backward, set keyword to # words from cursor
.It Cm <^Z>
Suspend vi
.It Cm <^L>
Force redraw whole screen and update terminal dimensions
.It Cm qq
Force quit and clean terminal
.It Cm zz
Force quit, submit a command when recursive
.It Cm ZZ
Soft quit, write to a file before exit
.El
.
.Sh VI REGIONS
.Bd -literal -compact
Regions are vi normal commands that define [h v]range for vi motions.
Commands described with the word "move" define a region.
This includes:
<+ j ^M Newline - k h l f F t T , ; B E b e W w { } [ ] ^ 0 $ Space
^H Backspace % ' ` G H L M / ? n N ^A>
.Ed
.
.Sh VI MOTIONS
.Bd -literal -compact
Motions are vi normal commands that run in a [h v]range.
Commands described with the word "region" consume a region.
This includes:
<^W < > ! c d y "> g~ gu gU
Examples:
.Ed
.Bl -tag -width Ds -compact
.It Cm 3d/int
Delete text until the 3rd instance of [int] keyword
.It Cm d3w
Delete 3 words
.It Cm \&"ayl
Yank a character into <a> register
.It Cm \&"Ayw
Append a word to <a> register
.El
.
.Sh VI/EX INSERT
.Bl -tag -width Dq -compact
.It Cm <^H>
.It Cm <Backspace>
.Bd -compact
Delete a character
.Ed
.It Cm <^U>
Delete util <^X> mark or everything
.It Cm <^W>
Delete a word
.It Cm <^T>
Increase indent
.It Cm <^D>
Decrease indent
.It Cm <^]>
Switch default paste register to registers 0-9
.It Cm <^\e>{arg}
Select paste register arg. <^\e> selects default register
.It Cm <^P>
Paste a register
.It Cm <^X>
Mark autocomplete and <^U> starting position. <^X> resets the mark
.It Cm <^G>
Index buffer for autocomplete
.It Cm <^Y>
Reset autocomplete data
.It Cm <^R>
Loop through autocomplete options backward
.It Cm <^N>
Loop through autocomplete options forward
.It Cm <^B>
Print autocomplete options when in vi insert
.It Cm <^B>
Recurse into b-1 history buffer when in ex prompt. Insert current line into ex prompt after a quit command
.It Cm <^A>
Loop through lines in a history buffer b-1
.It Cm <^Z>
Suspend vi/ex
.It Cm <^L>
Redraw screen in vi mode, clean terminal in ex
.It Cm <^O>
Switch between vi and ex modes recursively
.It Cm <^O>
Switch to english keymap
.It Cm <^F>
Switch to alternative keymap
.It Cm <^V>{arg}
Read a literal character arg
.It Cm <^K>{arg}
Read a digraph sequence arg
.It Cm <^C>
.It Cm <ESC>
.Bd -compact
Exit insert mode
.Ed
.El
.
.Sh EX
Ex is a powerful line editor for Unix systems, initially developed by Bill Joy in
1976. This essential tool serves as the backbone of vi, enabling it to execute commands,
macros and even transform into a purely command-line interface (CLI) when desired.
In Ex, each command is initiated with the prefix <:>.
.
.Sh EX EXPANSION
.Bd -literal -compact
Characters <# %> in ex prompt substitute the buffer pathname.
<%> substitutes current buffer and <#> last swapped buffer.
It is possible to expand any arbitrary buffer by using <# %>
followed by the buffer number.
Example: print the pathname for buffer 69.
:!echo "%69"

Every ex command is be able to receive data from external process 
through a special expansion character <!> which pipes the data 
into the command itself. If the closing <!> is not specified, 
the end of the line becomes a terminator.
Example:
Substitute the value of env var $SECRET to the value of $RANDOM :).
In this demo, we set the value of SECRET to "int" ourselves.
:%s/!export SECRET="int" && printf "%s" $SECRET!/!printf "%s" $RANDOM! :)
.Ed
.
.Sh EX ESCAPES
Nextvi special character escapes work mostly the same way everywhere
except the following situations:
.Bd -literal -compact
 - Escapes in regex bracket expressions.
 - Due to ex expansion <# % !> characters have to be escaped
   if they are part of an ex command.
 - A single back slash requires 2 back slashes, and so on.
 - regex requires for <(> to be escaped if used inside "[]" brackets.
 - In ex prompt the only separator is <|> character. It can
   be escaped normally but will require extra back slash if passed
   into a regular expression or a global command.
.Ed
.
.Sh EX RANGES
.Bd -literal -compact
Some ex commands can be prefixed with ranges.
Examples:
.Ed
.Bl -tag -width Ds -compact
.It Cm \&.
current position
.It Cm \&,
vertical range separator
.It Cm \&;
horizontal range separator
.It Cm :1,5p
print lines 1,5
.It Cm :.-5,.+5p
print 5 lines around xrow
.It Cm :/int/p
print first occurrence of int
.It Cm :?int?p
print first occurrence of int in reverse
.It Cm :.,/int/p
print until int is found
.It Cm :?int?,.p
print until int is found in reverse
.It Cm :'d,'ap
print lines from mark d to mark a
.It Cm :%p
print all lines in the buffer
.It Cm :$p
print last line in the buffer
.It Cm :;50
goto character offset 50
.It Cm :10;50
goto line 10 character offset 50
.It Cm :10;.+5
goto line 10 +5 character offset
.It Cm :'a;'a
goto line mark a character offset a
.It Cm :;$
goto end of the line
.It Cm :5;/int/
search for int on line 5
.It Cm :.;?int?
search for int in reverse on the current line
.El
.
.Sh EX COMMANDS
.Bl -tag -width Ds -compact
.It Cm [range]f{/?}[kwd]
Ranged search (stands for find)
.Bd -literal
Example: no range given, current line only
:f/int
Example: reverse
:f?int
Example: range given
:10,100f/int
Subsequent commands within the range will move to the next match
just like vi n/N commands.
.Ed

.It Cm b[#]
Print currently active buffers state or switch to a buffer
.Bd -literal
Example: switch to the 5th buffer
:b5

There are 2 temporary buffers which are separate from
the main buffers.
b-1 = /hist/ ex history buffer
b-2 = /fm/ directory listing buffer
Example: switch to the b-1 buffer
:b-1
Example: switch to the b-2 buffer
:b-2
.Ed

.It Cm bp [path]
Set current buffer path
.It Cm bs[#]
Set current buffer saved. If any arg given, reset undo/redo history

.It Cm [range]p
Print line(s) from the buffer
.Bd -literal
Example: utilize character offset ranges
:1,10;5;5p
Example: print current line from offset 5 to 10
:.;5;10p
.Ed

.It Cm ea [kwd] [#]
Open file based on it's filename substring and from listing in b-2
.Bd -literal
Requires directory listing in b-2 backfilled prior.
Example: backfill b-2 using :fd
:fd
Example: backfill b-2 using find
:b-2|1,$!find .

If the substring matches more than 1 filename, a prompt will
be shown. Submit using numbers 0-9 (higher ascii values work
too (<^C> to cancel)). Passing an extra arg to :ea in form of
a number will bypass the prompt and open the corresponding file.
Example: open filename containing "v"
:ea v
Example: open first match containing "v"
:ea v 0
.Ed

.It Cm ea![kwd] [#]
Forced version of ea

.It Cm [#]a [#]i [#]c
Enter ex append/insert/change mode
.Bd -literal
# determines insertion line number.
Exiting with <^M>.<^M> or <^M><ESC> will apply changes to the buffer.
Exiting with <^C> will discard changes.
.Ed

.It Cm [range]d
Delete line(s)
.It Cm e [path]
Open a file at a path
.It Cm e!
Reload the current buffer from the filesystem

.It Cm [range]g{*}[kwd]{*}{cmd}
Global command
.Bd -literal
Execute an ex command on a range of lines that matches an
enclosed regex.

Example: remove empty lines
:g/^$/d

Multiple ex commands can be chained in one global command.
To chain commands, the ex separator <|> must be escaped once.
Example: yank matches appending to reg 'a' and print them out.
:g/int/ya A\e|p

It is possible to nest global commands inside of global commands.
Example: find all lines with int and a semicolon and append
"has a semicolon"
:g/int/:.g/;/& A has a semicolon
Example: extract/print data enclosed in "()"
:g/\e(.+\e)/;0;/\e(.+\e)/\e|.;.+1k a\e|se grp=2\e|;/\e)*(\e))/\e|
se nogrp\e|k s\e|.;'a;'sp
.Ed

.It Cm [range]g!{*}[kwd]{*}{cmd}
Inverted global command
.It Cm [range]=
Print the current range line number

.It Cm [range]k [mark]
Set a line mark
.Bd -literal
The character offset is set to the current position.
.Ed

.It Cm &{macro}
Global non-blocking macro
.Bd -literal
Execute any sequence of vi/ex commands or macros.
A non-blocking macro shall not wait for input when the end of
the sequence is reached. A non-blocking macro executing other
macros will always reach a terminating point.
Example: execute vi insert statement
:& ihello
Example: execute :hello
:& :hello
Example: execute ci(int macro
:& ci(int
Example: turn non-blocking into blocking macro
:& :@ :run as non-blocking but blocking<^V><^M>
.Ed

.It Cm @{macro}
Global blocking macro
.Bd -literal
Execute any sequence of vi/ex commands or macros.
A blocking macro shall wait for input when the end of the sequence
is reached. A blocking macro executing other macros may result
in congestion.
Example: execute vi insert statement
:@ ihello
Example: insert hello into : prompt
:@ :hello
Example: execute ci(int macro
:@ ci(int
Example: execute ci(int exiting insert mode
:@ ci(int<^V><^C>
Example: execute ci)INT as a follow-up
:@ ci(int<^V><^C>ci)INT
.Ed

.It Cm pu [register] [cmd]
Paste a register
.Bd -literal
To pipe register data to an external process use :pu \e![cmd]
Example: copy default register to X11 clipboard
:pu \e!xclip -selection clipboard
.Ed

.It Cm q
Soft quit
.It Cm q!
Force quit

.It Cm [range]r [path cmd]
Read a file or a pipe
.Bd -literal
To read data from a pipe use :[range]r \e![cmd]
Example: pipe in only the first line
:r \e!ls
Example: pipe in only lines 3,5
:3,5r \e!ls
Example: pipe in all data
:%r \e!ls
.Ed

.It Cm [range]w [path cmd]
Write to a file or a pipe
.Bd -literal
To pipe buffer data to external process use :[range]w \e![cmd]
Example: pipe out all data into less
:w \e!less
Example: pipe out only first 10 lines
:1,10w \e!less
.Ed

.It Cm [range]w! [path]
Force write to a file

.It Cm wq[!]
.It Cm x[!]
.Bd -compact
Write and force/soft quit
.Ed

.It Cm u[# $]
Undo # times or all with $
.It Cm rd[# $]
Redo # times or all with $

.It Cm se {exp}
Set a variable
.Bd -literal
Example: set using implications
:se hll
:se nohll
Example: set using exact values
:se hll=1
:se hll=0
.Ed

.It Cm [range]s{*}[kwd]{*}{str}[*][opts]
Substitute
.Bd -literal
Find and replace text in a range of lines that matches an
enclosed regex with an enclosed replacement string.

Example: global replacement
:%s/term1/term2/g

Substitution backreference inserts the text of matched group
specified by \ex where x is group number.

Example: substitution backreference
this is an example text for subs and has int or void
:%s/(int)\e|(void)/pre\e0after
this is an example text for subs and has preintafter or void
:%s/(int)\e|(void)/pre\e2after/g
this is an example text for subs and has prepreafterafter or prevoidafter
.Ed

.It Cm [range]ya [register][append]
Yank a region
.Bd -literal
To append to the register, pass in its uppercase version.
To append to any of the non-alphabetical registers add any extra
character to the command.
Example: append to register <1>
:ya 1x
.Ed

.It Cm ya!
Reset register value

.It Cm [range]![cmd]
Run external program
.Bd -literal
When ex range specified, pipes the buffer data to an external
process and pipes the output back into current buffer replacing
the affected range.
Example: infamously sort the buffer
:1,$!sort
.Ed

.It Cm ft [filetype]
Set a filetype
.Bd -literal
No argument prints the current file type.
Reloads the highlight ft, which makes it possible to reset dynamic
highlights created by options like "hlw".
.Ed

.It Cm cm [keymap]
Set a keymap
.Bd -literal
No argument prints the current keymap name.
.Ed

.It Cm cm! [keymap]
Set an alternative keymap

.It Cm fd [path]
Set a secondary directory (stands for file dir)
.Bd -literal
Recalculates the directory listing in b-2 buffer.
No argument implies current directory.
.Ed

.It Cm fp [path]
Set a directory path for :fd (stands for file path)

.It Cm cd [path]
Set a working directory (stands for change dir)
.Bd -literal
Currently open buffers' file paths will be automatically adjusted
to reflect a newly set working directory.
.Ed

.It Cm inc [regex]
Include regex for :fd calculation
.Bd -literal
Example: include only files in submodule directory that end with .c
:inc submodule.*\e.c$
Example: exclude the .git and submodule folders
:inc (^[\e!.git\e!submodule]+[^\e/]+$)
No argument disables the filter.
.Ed

.It Cm reg
Print registers and their contents

.It Cm bx[#]
Set max number of buffers allowed
.Bd -literal
Buffers will be deallocated if the number specified is lower
than the number of buffers currently in use.
No argument will reset to the default value of 10.
.Ed

.It Cm ac [regex]
Set autocomplete filter regex
.Bd -literal
Example: autocomplete using whole lines from the buffer
:ac .+
No argument resets to the default word filter regex as defined
in led.c.
.Ed

.It Cm uc
Toggle multibyte utf-8 decoding
.Bd -literal
This command is particularly useful when editing files with
mixed encodings, binary files, or when the terminal does not
support UTF-8 or lacks the necessary fonts to display UTF-8
characters. Typically to be used along with :ph for the full
effect.
.Ed

.It Cm ph [#clow] [#chigh] [#width] [#blen][*char]
Create new placeholders
.Bd -literal
Example: render 8 bit ascii (Extended ASCII) as <~>
:ph 128 255 1 1~
Example: flawless ISO/IEC 8859-1 (latin-1) support
:uc|ph 128 160 1 1~
Example: reset to default as in conf.c
:ph
.Ed
.
.El
.
.Sh EX OPTIONS
.Bl -tag -width Ds -compact
.
.It Cm ai
If set, indent new lines.
.
.It Cm ic
If set, ignore case in regular expressions.

.It Cm ish
Interactive shell
.Bd -literal
Makes every "!" pipe command run through an interactive shell
so that all shell features e.g. aliases work.
.Ed

.It Cm grp
Regex search group
.Bd -literal
Defines a target search group for any regex search operation.
This becomes necessary when the result of regex search is to
be based on some group rather than default match group.

Example: ignore tabs at the beginning of the line
:se grp=2|1,$f/^[	]+(.+)|se nogrp

The value of grp is calculated using (group number * 2).
The default group number is 0.
.Ed

.
.It Cm hl
If set, highlight text based on rules defined in
.Pa conf.c .
.
.It Cm hlr
If set, highlight text in reverse direction.
.
.It Cm hll
If set and defined in hl, highlight current line.
.
.It Cm hlp
If set and defined in hl, highlight [](){} pairs.
.
.It Cm hlw
If set and defined in hl, highlight current word from cursor.
.
.It Cm led
If unset, all terminal output is disabled.

.It Cm vis
Control startup flags
.Bd -literal
Example: disable :e message in ex mode
:se vis=12
Example: disable :e message in vi mode
:se vis=8
Example: enable raw ex mode
:se vis=6
Example: disable raw ex mode
:se vis=4
.Ed

.It Cm mpt
Control vi prompts
.Bd -literal
When set to 0 after an ex command is called from vi, disables
the "[any key to continue]" prompt.
If mpt is negative, the prompt will remain disabled.
.Ed

.It Cm order
If set, reorder characters based on rules defined in
.Pa conf.c .
.
.It Cm shape
If set, perform Arabic script letter shaping.
.
.It Cm pac
If set, print autocomplete suggestions on the fly.
.
.It Cm tbs
Number of spaces used to represent a tab.
.
.It Cm td
Current text direction context.
This option accepts four meaningful values:
.Bl -tag -width Ds -compact
.It Ar +2
Exclusively left-to-right.
.It Ar +1
Follow
.Va dircontexts[]
(in
.Pa conf.c ) ,
defaulting to left-to-right.
.It Ar -1
Follow
.Va dircontexts[] ,
defaulting to right-to-left.
.It Ar -2
Exclusively right-to-left.
.El

.It Cm pr
Print register
.Bd -literal
Set a special register using a character or a number.
Once the register is set, all data passed into ex_print will
be stored in the register.
If the register is uppercase, <Newline> characters are added
to match the exact output that was printed.
Example: paste current buffer list exactly like from :b command
:se pr=A|ya! a|b|pu a
Example: store a line printed with :p
:se pr=A|ya! a|p
.Ed
.
.El
.
.Sh EXINIT ENV VAR
.Bd -literal
EXINIT defines a sequence of vi/ex commands to be performed
at startup. Consequently, this is the primary way for scripting
and customizing nextvi outside of C.
Many standard text processing utils such as grep, awk, sed
can be replaced by nextvi with EXINIT in mind.

Examples:
.Ed

.Bl -tag -width Ds -compact
.It Cm export EXINIT=$'e ./vi.c|& i\ex7\ex3|bx 1|bx'
Index vi.c for autocomplete

.It Cm export EXINIT='b-1|%r ./vi.c|b-1'
Load vi.c into a history buffer

.It Cm export EXINIT=$'e|& io{\en}\ex16\ex3kA\ex3|& 1G|& 2\e"ayy'
Setup @ macro in register <a>

@a macro creates <{> and closing <}> below the cursor leaving
cursor in insert mode in between the braces.
.El
.
.Sh REGEX
.Bd -literal
Nextvi's regex syntax is akin to that of Plan 9.
Disregard manpage notation for <{ } [ ]> in this section.
.Ed
.Bl -tag -width Ds -compact

.It Cm \&.
match any single char
.It Cm ^
assert start of the line
.It Cm $
assert end of the line
.It Cm {N,M}
match N to M times
.It Cm ()
grouping
.It Cm (?:)
non capture grouping
.It Cm [N-M]
match a set of alternate ranges N to M
.It Cm *
repeated zero or more times
.It Cm +
repeated one or more times
.It Cm \&|
union, alternative branch
.It Cm \e<
assert beginning of the word
.It Cm \e>
assert end of the word
.It Cm \&?
one or zero matches greedy
.It Cm \&??
one or zero matches lazy
.El

Additionally, Nextvi's supports static lookahead expressions.
.Bl -tag -width Ds -compact
.It Cm /[=abc]
find <a> followed by "bc"
.It Cm /[!abc]
find anything except <a> followed by "bc"
.It Cm /[!abc!cda!qwe]
multiple lookahead alternatives in one bracket exp
.It Cm /[!abc^=123]
disable lookahead using "^=" specifier and match [123]
.El
.
.Sh SPECIAL MARKS
.Bl -tag -width Ds -compact
.It Cm *
position of the previous change
.It Cm \&[
first line of the previous change
.It Cm \&]
last line of the previous change
.El
.
.Sh SPECIAL REGISTERS
.Bl -tag -width Ds -compact
.It Cm /
previous search keyword
.It Cm \&:
previous ex command
.It Cm 0
previous value of default register (atomic)
.Bd -literal -compact
Atomic means the operation did not include a <Newline> character.
.Ed
.It Cm 1-9
previous value(s) of default register (nonatomic)
.El
.
.Sh CODE MAP
.Bd -literal -compact
+---------------+-----------------------+
| 470	vi.h	| definitions/aux	|
| 537	kmap.h	| keymap translation	|
+---------------+-----------------------+
| 293	conf.c	| hl/ft/td config	|
| 336	term.c	| low level IO		|
| 382	ren.c	| positioning/syntax	|
| 593	lbuf.c	| file/line buffer	|
| 653	uc.c	| UTF-8 support		|
| 658	regex.c	| extended RE		|
| 665	led.c	| insert mode/output	|
| 1232	ex.c	| ex options/commands	|
| 1993	vi.c	| normal mode/general	|
| 6805	total	| wc -l *.c|sort	|
+---------------+-----------------------+
.Ed
.
.Sh COMPILING
.Bl -tag -width Ds -compact
.It Cm export CC='g++ -x c'
set compiler, g++ example
.It Cm export CFLAGS='-s'
set CFLAGS, strip example
.It Cm ./cbuild.sh
Basic build
.It Cm ./cbuild.sh debug
Basic debug build
.It Cm ./cbuild.sh pgobuild
pgobuild which can lead to a significant performance boost on
some application specific tasks.
.It Cm valgrind --tool=cachegrind --cache-sim=yes --branch-sim=yes ./vi vi.c
performance bench test
.El
.
.Sh PHILOSOPHY
.Bd -literal -compact
In most text editors, flexibility is a minor or irrelevant design goal.
Nextvi is designed to be flexible where the editor adapts to the user needs.
This flexibility is achieved by heavily chaining basic commands and allowing
them to create new ones with completely different functionality. Command
reuse keeps the editor small without infringing on your freedom to quickly
get a good grasp on the code. If you want to customize anything, you should
be able to do it using the only core commands or a mix with some specific C
code for more difficult tasks. Simple and flexible design allows for straight
forward solutions to any problem long term and filters bad inconsistent ideas.

.Sy \&"All software sucks, but some do more than others."
.Em 	- Kyryl Melekhin
.Ed
.
.Sh SEE ALSO
.Bd -literal -compact
New functionality can be obtained through optional patches provided in the
patches branch. If you have a meaningful contribution and would love to be
made public the patch can be submitted via email or github pull request.
.Lk https://github.com/kyx0r/nextvi/tree/patches

Scripts used to generate this manual are located in the manual branch.
.Lk https://github.com/kyx0r/nextvi/tree/manual

Q: What is pikevm?
A: Pikevm is a complete rewrite of nextvi's regex engine for the purposes of
getting rid of backtracking and severe performance and memory constraints.
Pikevm guarantees that all regular expressions are computed in constant space
and O(n+k) time where n is size of the string and k is some constant for the
complexity of the regex i.e. number of state transitions. It is important to
understand that it does not mean that we run at O(n) linear speed, but rather
the amount of processing time & memory usage is distributed evenly and linearly
throughout the string, the k constant plays a big role. If you are familiar
with radix sort algorithms this follows the same idea.
Q: What are the other benefits?
A: For example, now it is possible to compute a C comment /* n */ where n can
be an infinite number of characters. Of course this extends to every other
valid regular expression.
Q: New features pikevm supports?
A: Additionally, pikevm supports PCRE style non capture group (?:) and lazy
quantifiers like .*? and .+?? because they were easy to implement and allow
for further regex profiling/optimization.
Q: NFA vs DFA (identify)
A: pikevm = NFA backtrack = DFA
Q: What's wrong with original implementation?
A: Nothing except it being slow and limited. My improved version of Ali's DFA
implementation ran 3.5X faster in any case, however I found a bug with it
where zero quantifier "?" nested groups compute wrong submatch results. To
fix this problem, it would require to undo a lot of optimization work already
done, basically going back to how slow Ali's implementation would be. The reason
this was spotted so late was because this kind of regex wasn't used before,
so I never tested it. Other than that I think submatch extraction is correct
on other cases. Pikevm does not have this bug, so it will be used as main
regex engine from now on, unless dfa ever finds a proper fix. Honestly, this
change isn't so surprising, as I was working on pikevm a few months prior, to
favor a superior algorithm.
You can still find that code here (likely with no updates):
.Lk https://github.com/kyx0r/nextvi/tree/dfa_dead
As a downside, NFA simulation loses the DFA property of being able to
quickly short circuit a match, as everything runs linearly and at constant
speed, incurring match time overhead. Well optimized DFA engine can
outperform pikevm, but that is rather rare as they got problems of their own.
For example as independently benchmarked, dfa_dead runs only 13% faster than
pikevm and that is stretching the limit of what is physically possible on a
table based matcher. Can't cheat mother nature, and if you dare to try she's
unforgiving at best.
Supplementary reading by Russ Cox:
.Lk https://swtch.com/~rsc/regexp/regexp1.html

Original Neatvi repository:
.Lk https://github.com/aligrudi/neatvi
.Ed
.
.Sh AUTHORS
.An -nosplit
.Nm
was written by
.An Kyryl Melekhin Aq Mt k.melekhin@gmail.com .
It is based on
.Xr neatvi 1 Ns ,
which was written by
.An Ali Gholami Rudi Aq Mt ali@rudi.ir .
.\" add more contributors here?
This manual page was inspired by
.An népéta Aq Mt nepeta@canaglie.net
