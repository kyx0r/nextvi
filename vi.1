.Dd Feb  6, 2026
.Dt Nextvi 1
.Os Nextvi 4.0
.
.Sh NAME
.Nm Nextvi
.Nd A small vi/ex terminal text editor
.
.Sh SYNOPSIS
.Nm vi
.Op Fl emsv
.Op Ar
.
.Sh DESCRIPTION
.Bd -literal -compact
Nextvi is a modern clone of the command-line text editor vi(1),
initially developed by Bill Joy in 1976 for Unix-based systems.
Nextvi builds upon many standard features from vi(1) including
unique modal interface that allows users to switch between normal,
insert, and command modes, for efficient text manipulation.
Additional enhancements include an unrestricted macro system,
syntax highlighting, keymaps, bidirectional UTF-8 support, and
numerous other features. Nextvi remains highly efficient, portable,
and hackable, ensuring its continued relevance and high quality
for years to come.
.Ed
.
.Sh OPTIONS
.Bl -tag -width Ds -compact
.It Fl e
Enter ex mode on startup
.It Fl m
Disable initial file read message
.It Fl s
Enter raw ex mode on startup
.It Fl v
Enter visual mode on startup (Default)
.El
.Sh MANPAGE NOTATION
.Bl -tag -width Ds -compact
.It Cm <\fIx\fP>
A closure where x represents character literal
.It Cm [\fIx\fP]
A closure where x represents optional argument
.It Cm {\fIx\fP}
A closure where x represents required argument
.It Cm \&"\fIx\fP\&"
A closure where x represents a string
.It Cm <^\fIX\fP>
Represents a ctrl key X
.It Cm #
Represents a positive number in a closure
.It Cm *
Represents any character(s) in a closure
.It Cm < >
Separates alternatives in a closure
.It Cm x-y
Range from x to y
.El
.Sh VI NORMAL
.Bl -tag -width Dq -compact
.It Cm [\fI#\fP]j
Move # lines down
.It Cm [\fI#\fP]k
Move # lines up
.It Cm [\fI#\fP]+
.It Cm [\fI#\fP]<^M>
.It Cm [\fI#\fP]<Enter>
.Bd -compact
Move # lines down, cursor after indent
.Ed
.It Cm [\fI#\fP]-
Move # lines up, cursor after indent
.It Cm [\fI#\fP]h
Move # columns left
.It Cm [\fI#\fP]l
Move # columns right
.It Cm [\fI#\fP]f{\fIarg\fP}
Move to arg character found forward # times
.It Cm [\fI#\fP]F{\fIarg\fP}
Move to arg character found backward # times
.It Cm [\fI#\fP]t{\fIarg\fP}
Move until arg character found forward # times
.It Cm [\fI#\fP]T{\fIarg\fP}
Move until arg character found backward # times
.It Cm [\fI#\fP],
Repeat last <f F t T> move backward # times
.It Cm [\fI#\fP];
Repeat last <f F t T> move forward # times
.It Cm [\fI#\fP]E
Move to end of word # times, skip punctuation
.It Cm [\fI#\fP]e
Move to end of word # times
.It Cm [\fI#\fP]B
Move to start of word backward # times, skip punctuation
.It Cm [\fI#\fP]b
Move to start of word backward # times
.It Cm [\fI#\fP]W
Move to start of word forward # times, skip punctuation
.It Cm [\fI#\fP]w
Move to start of word forward # times
.It Cm vw
Toggle line only mode for <E e B b W w>
.It Cm [\fI#\fP](
Move to next sentence boundary down # times
.It Cm [\fI#\fP])
Move to next sentence boundary up # times
.It Cm [\fI#\fP]{
Move to next <{> section down # times
.It Cm [\fI#\fP]}
Move to next <{> section up # times
.It Cm [\fI#\fP]\&[
Move to next <Newline> section down # times
.It Cm [\fI#\fP]\&]
Move to next <Newline> section up # times
.It Cm ^
Move to start of line after indent
.It Cm 0
Move to start of line
.It Cm $
Move to end of line
.It Cm [\fI#\fP]|
Goto # col
.It Cm [\fI#\fP]<Space>
Move # characters forward, multiline
.It Cm [\fI#\fP]<^H>
.It Cm [\fI#\fP]<Backspace>
.Bd -compact
Move # characters backward, multiline
.Ed
.It Cm %
Move to closest <] ) }><[ ( {> pair
.It Cm {\fI#\fP}%
Move to # percent line number
.It Cm '{\fIa-z ` ' [ ] *\fP}
Move to a line mark
.It Cm `{\fIa-z ` ' [ ] *\fP}
Move to a line mark with cursor position
.It Cm gg
Goto first line in buffer
.It Cm [\fI#\fP]G
Move to last line in buffer or # line
.It Cm H
Move to highest line on a screen
.It Cm L
Move to lowest line on a screen
.It Cm M
Move to middle line on a screen
.It Cm z.
Center screen at cursor
.It Cm z<^M>
.It Cm z<Enter>
.Bd -compact
Center screen at top row
.Ed
.It Cm z-
Center screen at bottom row
.It Cm [\fI#\fP]<^E>
Scroll down 1 or # lines, retain # and cursor position
.It Cm [\fI#\fP]<^Y>
Scroll up 1 or # lines, retain # and cursor position
.It Cm [\fI#\fP]<^D>
Scroll down half a screen size. If [#], set scroll to # lines
.It Cm [\fI#\fP]<^U>
Scroll up half a screen size. If [#], set scroll to # lines
.It Cm <^B>
Scroll up full screen size
.It Cm <^F>
Scroll down full screen size
.It Cm #
Show global and relative line numbers
.It Cm 2#
Toggle show global line numbers permanently
.It Cm 4#
Toggle show relative line numbers after indent permanently
.It Cm 8#
Toggle show relative line numbers permanently
.It Cm V
Toggle show hidden characters:<Space Tab Newline>
.It Cm <^C>
Toggle show line motion numbers for <l h e b E B w W>
.It Cm {\fI1-5\fP}<^C>
Switch to line motion number mode #
.It Cm <^V>
Loop through line motion number modes
.It Cm [\fI#\fP]<^R>
Redo # times
.It Cm [\fI#\fP]u
Undo # times
.It Cm <^I>
.It Cm <Tab>
.Bd -compact
Open file path from cursor to end of line
.Ed
.It Cm <^K>
Write current buffer to file. Force write on 2nd attempt
.It Cm [\fI#\fP]<^W>{\fIarg\fP}
Unindent arg region # times
.It Cm [\fI#\fP]<{\fIarg\fP}
Indent left arg region # times
.It Cm [\fI#\fP]>{\fIarg\fP}
Indent right arg region # times
.It Cm \&"{\fIarg\fP}{\fIarg1\fP}
Operate on arg register according to arg1 motion
.It Cm R
Print registers and their contents
.It Cm [\fI#\fP]&{\fIarg\fP}
Execute arg register macro in non-blocking mode # times
.It Cm [\fI#\fP]@{\fIarg\fP}
Execute arg register macro in blocking mode # times
.It Cm [\fI#\fP]@@
.It Cm [\fI#\fP]&&
.Bd -compact
Execute a last executed register macro # times
.Ed
.It Cm [\fI#\fP].
Repeat last normal command # times
.It Cm [\fI#\fP]v.
Repeat last normal command moving down across # lines
.It Cm [\fI#\fP]Q
Enter ex mode. # retains current horizontal scroll
.It Cm \&:
Enter ex prompt
.It Cm [\fI#\fP]!{\fIarg\fP}
Enter pipe ex prompt based on # or arg region
.It Cm vv
Enter ex prompt with the last line from history buffer b-1
.It Cm [\fI#\fP]vr
Enter %s/ ex prompt. Insert # words from cursor
.It Cm [\fI#\fP]vt[\fI#arg\fP]
Enter .,.+0s/ ex prompt. Insert # of lines from cursor. Insert #arg words from cursor
.It Cm [\fI#\fP]v/
Enter xkwd prompt to set regex keyword. Insert # words from cursor
.It Cm v;
Enter ! ex prompt
.It Cm [\fI#\fP]vi
Enter %s/ ex prompt. Contains regex for changing spaces to tabs. # modifies tab width
.It Cm [\fI#\fP]vI
Enter %s/ ex prompt. Contains regex for changing tabs to spaces. # modifies tab width
.It Cm vo
Remove trailing white spaces and <\er> line endings
.It Cm <^G>
Print buffer status infos
.It Cm 1<^G>
Enable permanent status bar row
.It Cm 2<^G>
Disable permanent status bar row
.It Cm ga
Print character info
.It Cm 1ga
Enable permanent character info bar row
.It Cm 2ga
Disable permanent character info bar row
.It Cm [\fI#\fP]gw
Hard word wrap a line to # col limit. Default: 80
.It Cm [\fI#\fP]gq
Hard word wrap a buffer to # col limit. Default: 80
.It Cm [\fI#\fP]g~{\fIarg\fP}
Switch character case for arg region # times
.It Cm [\fI#\fP]gu{\fIarg\fP}
Switch arg region to lowercase # times
.It Cm [\fI#\fP]gU{\fIarg\fP}
Switch arg region to uppercase # times
.It Cm [\fI#\fP]~
Switch character case # times forward
.It Cm i
Enter insert mode
.It Cm I
Enter insert mode at start of line after indent
.It Cm A
Enter insert mode at end of line
.It Cm a
Enter insert mode 1 character forward
.It Cm [\fI#\fP]s
Enter insert mode and delete # characters
.It Cm S
Enter insert mode and delete all characters
.It Cm o
Enter insert mode and create a new line down
.It Cm O
Enter insert mode and create a new line up
.It Cm [\fI#\fP]c{\fIarg\fP}
Enter insert mode and delete arg region # times
.It Cm C
Enter insert mode and delete from cursor to end of line
.It Cm [\fI#\fP]d{\fIarg\fP}
Delete arg region # times
.It Cm D
Delete from cursor to end of line
.It Cm [\fI#\fP]x
Delete # characters from cursor forward
.It Cm [\fI#\fP]X
Delete # characters from cursor backward
.It Cm di{\fIarg\fP}
Delete inside arg pairs <( ) \&">
.It Cm ci{\fIarg\fP}
Change inside arg pairs <( ) \&">
.It Cm [\fI#\fP]r{\fIarg\fP}
Replace # characters with arg from cursor forward
.It Cm [\fI#\fP]K
Split a line # times
.It Cm [\fI#\fP]J
Join # lines
.It Cm [\fI#\fP]y{\fIarg\fP}
Yank arg region # times
.It Cm [\fI#\fP]Y
Yank # lines
.It Cm [\fI#\fP]p
Paste default register below current line or after cursor position # times
.It Cm [\fI#\fP]P
Paste default register above current line or before cursor position # times
.It Cm m{\fIa-z ` ' [] *\fP}
Set buffer local line mark
.It Cm <^T>
Set global line mark 0. Global marks are always valid
.It Cm {\fI0 2 4 6 8\fP}<^T>
Set a global line mark #
.It Cm {\fI1 3 5 7 9\fP}<^T>
Switch to a global line mark #
.It Cm [\fI#\fP]<^7>{\fI0-9\fP}
.It Cm [\fI#\fP]<^_>{\fI0-9\fP}
.It Cm [\fI#\fP]<^/>{\fI0-9\fP}
.Bd -compact
Show buffer list and switch based on # or 0-9 index when prompted
.Ed
.It Cm <^^>
.It Cm <^6>
.Bd -compact
Swap to previous buffer
.Ed
.It Cm [\fI#\fP]<^N>
Swap to next buffer, # changes direction [forward backward]
.It Cm \e
Swap to /fm/ buffer b-2
.It Cm {\fI#\fP}\e
Swap from /fm/ buffer b-2 and backfill directory listing
.It Cm vb
Recurse into b-1 history buffer. Insert current line into ex prompt on exit
.It Cm z1
Set alternative keymap to Farsi keymap
.It Cm z2
Set alternative keymap to Russian keymap
.It Cm ze
Switch to English keymap
.It Cm zf
Switch to alternative keymap
.It Cm zL
Set td ex option to 2
.It Cm zl
Set td ex option to 1
.It Cm zr
Set td ex option to -1
.It Cm zR
Set td ex option to -2
.It Cm [\fI#\fP]/
Regex search prompt, move down 1 or # matches
.It Cm [\fI#\fP]?
Regex search prompt, move up 1 or # matches
.It Cm [\fI#\fP]n
.It Cm [\fI#\fP]N
.Bd -compact
Repeat regex search, move [down up] 1 or # matches
.Ed
.It Cm <^A>
Regex search 1 word from cursor, no center, wraparound move [up down]
.It Cm *
Regex search, no center, wraparound move [up down]
.It Cm {\fI#\fP}*
.It Cm {\fI#\fP}<^A>
Regex search, set keyword to # words from cursor
.It Cm <^]>
Filesystem regex search forward based on directory listing in
b-2. Sets global line mark 0 for <^P> fallback
.It Cm {\fI#\fP}<^]>
Filesystem regex search forward, set keyword to # words from
cursor
.It Cm [\fI#\fP]<^P>
Filesystem regex search backward
.It Cm <^Z>
Suspend vi
.It Cm <^L>
Force redraw whole screen and update terminal dimensions
.It Cm Z{*}
Exit and clean terminal, force quit in an & macro
.It Cm Zz
Exit and submit history command, force quit in an & macro
.It Cm ZZ
Exit and write unsaved changes to a file
.El
.
.Sh VI REGIONS
.Bd -literal -compact
Regions are vi normal commands that define [h v]range for vi motions.
Commands described with the word "move" define a region.
.Ed
.Bl -tag -width Ds -compact

.It Cm j + <^M> <Enter> - k h l f F t T \&, \&; B E b e W w \&( \&) { } \&[ \&] ^ 0 $ <Space> <^H> <Backspace> % ' ` G H L M / \&? n N <^A>

All regions
.El
.
.Sh VI MOTIONS
.Bd -literal -compact
Motions are vi normal commands that run in a [h v]range.
Commands described with the word "region" consume a region.
Motions can be prefixed or suffixed by [#].
.Ed
.Bl -tag -width Ds -compact

.It Cm <^W> > < \&! c d y \&" g~ gu gU
All motions

.It Cm \&"
Special motions that consume a motion

.It Cm dd yy cc g~~ guu gUU >> << <^W><^W> !!
Special motions that can use [#] as number of lines

.El
Examples:
.Bl -tag -width Ds -compact
.It Cm 3d/int
Delete text until 3rd instance of "int" keyword
.It Cm 3dw
Delete 3 words (prefix [#])
.It Cm d3w
Delete 3 words (suffix [#])
.It Cm \&"ayl
Yank a character into <a> register
.It Cm \&"Ayw
Append a word to <a> register
.El
.
.Sh VI/EX INSERT
.Bl -tag -width Dq -compact
.It Cm <^H>
.It Cm <Backspace>
.Bd -compact
Delete a character, reset ex mode when empty
.Ed
.It Cm <^U>
Delete util <^X> mark or everything
.It Cm <^W>
Delete a word
.It Cm <^T>
Increase indent
.It Cm <^D>
Decrease indent
.It Cm <^]>
Select paste register from 0-9 registers in a loop
.It Cm <^\e>{arg}
Select paste register arg. <^\e> selects default register
.It Cm <^P>
Paste a register
.It Cm <^X>
Mark autocomplete and <^U> starting position. <^X> resets the mark
.It Cm <^G>
Index current buffer for autocomplete
.It Cm <^Y>
Reset all indexed autocomplete data
.It Cm <^R>
Loop through autocomplete options backward
.It Cm <^N>
Loop through autocomplete options forward
.It Cm <^B>
Print autocomplete options when in vi insert
.It Cm <^B>
Recurse into b-1 history buffer when in ex prompt. Insert current line into ex prompt on exit
.It Cm <^A>
Loop through lines in a history buffer b-1
.It Cm <^Z>
Suspend vi/ex
.It Cm <^L>
Redraw screen in vi mode, clean terminal in ex
.It Cm <^O>
Switch between vi and ex modes recursively
.It Cm <^E>
Switch to english keymap
.It Cm <^F>
Switch to alternative keymap
.It Cm <^V>{arg}
Read a literal character arg
.It Cm <^K>{arg}
Read a digraph sequence arg
.It Cm <^C>
.It Cm <ESC>
.Bd -compact
Exit insert mode in vi, reset in ex
.Ed
.It Cm <^M>
.It Cm <Enter>
.Bd -compact
Insert <Newline> in vi, submit command in ex
.Ed
.El
.
.Sh EX
.Bd -literal -compact
Ex is a powerful line editor for Unix systems, initially developed
by Bill Joy in 1976. This essential tool serves as the backbone
of vi, enabling it to execute commands, macros and even transform
into a purely command-line interface (CLI) when desired.
.Ed
.
.Sh EX PARSING
.Bd -literal -compact
Parsing follows the structure:
[<\fIsep\fP>][\fIrange\fP][\fIcmd\fP][\fI<pad>\fP][\fIargs\fP]
Ex commands are initiated and separated by <:> prefix. Fields
can be padded by <Space> or <Tab>. Padding inside [range] structure
is collapsed. There can only be one pad in between [cmd] and
[args]. To avoid ambiguity in scripts, it is recommended to always
use a pad between [cmd] and [args].
.Bl -tag -width Ds -compact

Examples:
.It Cm :evi.c
Evaluates to ":e vi.c"
.It Cm :efbc
Evaluates to ":ef bc" not ":e fbc"
.It Cm :e \& vi.c
Edit " vi.c". <pad> is required
.El
.Ed
.
.Sh EX ESCAPES
.Bd -literal -compact
Special characters in [args] will become regular when escaped
with <\\>.
.Ed
.Bl -tag -width Ds -compact

.It Cm \&( \&^ \&] \&-
Specials in regex "[]" expression
.It Cm \&( \&) { } + * \&? ^ $ \&[ \&] \&| \e \&. \\\\< \\\\>
Specials in regex
.It Cm \&% \&! \&:
Specials in ex
.El
.
.Sh EX EXPANSION
.Bd -literal -compact
<%> in [args] expands to current buffer pathname or any buffer
pathname when followed by a corresponding buffer number.
"%#" expands to last swapped buffer pathname.
"%@" expands to register specified.

Example: make a copy of the current file and edit it
:!cp % %_:e %_
Example: insert current buffer pathname
:&i%
Example: echo the value of <a> register
:!echo "%@a"

<!> in [args] starts and optionally ends a block containing
external commands. This block executes and expands to stdout
produced.

Example: substitute "int" with the value of $RANDOM
:%s/int/!printf "%s" $RANDOM!
Example: insert output of ls shell command
:&i!ls
Example: insert output of ls more efficiently
:;c!ls!<^V><ESC>
.Ed
.
.Sh EX RANGES
.Bd -literal -compact
Some ex commands can be prefixed with ranges.
[range] implements vertical and horizontal ranges.
[vrange] implements vertical range and horizontal position.
.Ed
.Bl -tag -width Ds -compact

.It Cm [\fI% |\fP][\fI, ;\fP][\fI#\fP][\fI. $ ' > <\fP][\fI- + * / %\fP][\fI0-9\fP]
All ranges structure
'It Cm {\fI|\fP}{\fIcmd\fP}[\fI|\fP]
Ex command structure
.It Cm {\fI>\fP}[\fIregex\fP][\fI>\fP]
Search forward structure
.It Cm {\fI<\fP}[\fIregex\fP][\fI<\fP]
Search backward structure
'It Cm '{<\fImark\fP>}
Mark structure

.It Cm \&%
Range from first to last line
.It Cm \&|
Begin ex command structure
.It Cm \&,
Vertical range separator
.It Cm \&;
Horizontal range separator
.It Cm \&#
Rebase to previous value in range structure
.It Cm \&.
Current position
.It Cm \&$
Last line of a buffer or end of line
.It Cm \&'
Begin mark structure
.It Cm \&>
Begin search forward structure
.It Cm \&<
Begin search backward structure
.It Cm \&-
Subtract following number
.It Cm \&+
Add following number
.It Cm \&*
Multiply by the following number
.It Cm \&/
Divide by the following number
.It Cm \&%
Modulo by the following number
.It Cm \&0-9
Number or position
.El
.Bl -tag -width Ds -compact

Examples:
.It Cm :1,5p
Print lines 1,5
.It Cm :.-5,.+5p
Print 5 lines around current position
.It Cm :>int>p
Print first occurrence of "int"
.It Cm :<int<p
Print first occurrence of "int" in reverse
.It Cm :.,>int>p
Print until "int" is found
.It Cm :<int<,.p
Print until "int" is found in reverse
.It Cm :>
Search using previously set regex keyword
.It Cm :'d,'ap
Print lines from mark <d> to mark <a>
.It Cm :%p
Print all lines in a buffer
.It Cm :$p
Print last line in a buffer
.It Cm :$*50/100+1
Goto 50% of the file
.It Cm :;50
Goto character offset 50
.It Cm :10;50
Goto line 10 character offset 50
.It Cm :10;.+5
Goto line 10 +5 character offset
.It Cm :'a;'a
Goto line mark <a> offset mark <a>
.It Cm :;$
Goto end of line
.It Cm :5;>int>
Search for "int" on line 5
.It Cm :.;<int<
Search for "int" in reverse on the current line
.It Cm :;5;+10=
+10 is relative to the initial current offset, not 5
.It Cm :;5;#+10=
+10 is relative to 5
.It Cm :;>int>+3;#>>p
Print text enclosed by "int" on the current line
.It Cm :|grp2|;>(a)+>+1|grp|;#>>p
Print text enclosed by a non deterministic pattern "a+"
.El
.
.Sh EX COMMANDS
.Bl -tag -width Ds -compact
.It Cm [\fIrange\fP]f>[\fIregex\fP]
.It Cm [\fIvrange\fP]f<[\fIregex\fP]
Ranged search
.Bd -literal
Horizontal range performs a scoped multiline search forward.
In multiline mode, <Newline> is a regular character.

Example: no range given, current line only
:f>int
Example: reverse
:f<int
Example: range given
:10,100f>int
Example: search for "int" followed by "void" on next line
:%;0f>int.void
.Ed

.It Cm [\fIrange\fP]f+[\fIregex\fP]
.It Cm [\fIvrange\fP]f-[\fIregex\fP]
Incrementing ranged search
.Bd -literal
Equivalent to the :f> and :f< commands, except subsequent commands
within range move to the next match just like vi normal [#]n
or [#]N commands.
.Ed

.It Cm [\fIvrange\fP]f[\fIregex\fP]
Fuzzy search prompt
.Bd -literal
Enters a fuzzy search prompt with a list of matches.
Matches are prefixed by selection numbers and line numbers.
Match can be selected using numbers 0-9 if there are less than
10 matches.
<^C> or <ESC> to abort.
<^M> or <Enter> to input a selection number larger than 9.

No range evaluates to <%> range.
No range displays a maximum of xrows * 3 matches.
.Ed

.It Cm b[\fIindex\fP]
Print buffers or switch to a buffer
.Bd -literal
Temporary buffers are separate from the main buffers
and are selected by a negative index.

Example: switch to the 5th buffer
:b5
Example: switch to the /hist/ ex history buffer
:b-1
Example: switch to the /fm/ directory listing buffer
:b-2
.Ed

.It Cm bp[\fIpath\fP]
Set current buffer path

.It Cm bs[\fI*\fP]
Set current buffer saved
.Bd -literal
Argument resets undo/redo history
.Ed

.It Cm [\fIrange\fP]p[str]
Print line(s) from a buffer
.Bd -literal
No range prints a line based on the value of left ex option.
Argument prints the evaluated argument.

Example: utilize character offset ranges
:1,10;5;5p
Example: interleaved character offset ranges
:1;5,10;5p
Example: print current line from offset 5 to 10
:.;5;10p
Example: print buffer pathname
:p %
.Ed

.It Cm [\fIvrange\fP]ef[\fIregex\fP]
Open file using fuzzy search prompt
.Bd -literal
Requires directory listing in b-2 backfilled prior.

Example: backfill b-2 using :fd
:fd
Example: backfill b-2 using find
:b-2:%!find .

Prompt behavior is equivalent to the :f command.

Example: enter prompt & print entire listing
:ef
Example: search for pathname containing "v"
:ef v
.Ed

.It Cm [\fIvrange\fP]ef![\fIregex\fP]
Forced version of :ef

.It Cm [\fIvrange\fP]i[\fIstr\fP]
Enter ex insert mode before specified position
.Bd -literal
str specifies initial input into the insertion buffer.

Example: insert "hello" in vi/ex
:i hello<^M><ESC>
Example: insert "hello" in vi/ex trimming <Newline>
:i hello<^M><^M><Backspace>
Example: discard changes in vi/ex
:i hello<^M><^C>
Example: immediately insert "hello"
:i hello<^V><ESC>
Example: insert "hello" in raw ex mode
i hello<^M>.<^M>
.Ed

.It Cm [\fIvrange\fP]a[\fIstr\fP]
Enter ex insert mode after specified position

.It Cm [\fIrange\fP]c[\fIstr\fP]
Enter ex change mode
.Bd -literal
In combination with seq and lim ex options, this command is
optimal for modifying very long lines.
Max insertion buffer is ~1.33GB on a 32 bit build.
Max addressable line is 2.0GB on a 32 bit build.

Example: replace current line with "hello"
:c hello<^M><ESC>
Example: replace lines 1-5 with "hello"
:1,5c hello<^M><ESC>
Example: insert "hello" at current character offset
:;c hello<^M><ESC>
Example: insert "hello" at end of line
:;$c hello<^M><ESC>
Example: insert "hello" at line 5 and end of line
:5;$c hello<^M><ESC>
Example: delete 5 characters from current position
:;;+5c<^M><ESC>
.Ed

.It Cm [\fIrange\fP]d
Delete line(s)
.Bd -literal
Example: delete from current position to the start of the buffer
:1,.;0;d
Example: delete from current position to the end of the buffer
:.,$;;$d
.Ed

.It Cm [\fIvrange\fP]j[*]
Join line(s)
.Bd -literal
Any argument activates padding mode

Example: join all lines
:%-1j
Example: join all lines with space padding
:%-1jj
.Ed

.It Cm e[\fIpath\fP]
Open a file at a path
.Bd -literal
No argument opens "unnamed" buffer.
Files larger than 2.0GB are truncated on a 32 bit build.
Line breaking happens until the first null terminator or EOF.
.Ed

.It Cm e![\fIpath\fP]
Force open a file at a path
.Bd -literal
No argument re-reads the current buffer from the filesystem.
.Ed

.It Cm [\fIvrange\fP]g{<\fI*\fP>}[\fIregex\fP]{<\fI*\fP>}{\fIcmd\fP}
Global command
.Bd -literal
Execute an ex command on a range of lines that matches an
enclosed regex.

No range evaluates to <%> range or <.> range when nested.

Example: remove all empty lines
:g/^$/d

Example: print lines matching previously set regex
:g//p

Multiple ex commands can be chained in one global command.
To chain commands, the ex separator <:> must be escaped once.

Example: print and append lines matching "int" to register <a>
:g/int/p\e:ya ax

It is possible to nest global commands inside of global commands.
The first global command will not be executed on lines that
were changed by a nested global command.

Example: nested global command
Append "has a semicolon" to all lines that contain "int" and
end with <;>.
:g/int/g/;$/& A has a semicolon

Example: extract/print data enclosed in "()"
:grp2:err4:g/./;0\e:;>(\e().+\e)>;#>.+(\e))>+1p:err1:grp
.Ed

.It Cm [\fIvrange\fP]g!{<\fI*\fP>}[\fIregex\fP]{<\fI*\fP>}{\fIcmd\fP}
Inverted global command

.It Cm [\fIrange\fP]=[<\fI0-3\fP \fI*\fP>][\fI*\fP]
Print range numbers
.Bd -literal
Argument 0-3 selects a specific number.
Any or any extra argument circumvents buffer range check.
No argument prints all range numbers.

Example: print current character offset only
:;= 2
Example: print value of mark <a>
:'a=
Example: calculate 75 - 100
:,75-100=1p
.Ed

.It Cm [\fIrange\fP]m{\fImarks\fP}
Set a line mark(s)
.Bd -literal
Valid marks: <a-z ` ' [ ] *>

Example: store ranges in <a> and <s> for later reuse in :f>
:>top>,#>bottom>m as:'a,'sf>middle
.Ed

.It Cm &{\fImacro\fP}
Global non-blocking macro
.Bd -literal
Execute raw vi/ex input sequence.
A non-blocking macro shall not wait for input when the end of
the sequence is reached. A non-blocking macro executing other
macros will always reach a terminating point.

Example: execute vi insert statement
:& ihello
Example: execute :hello
:& \e:hello<^V><^M>
Example: execute vi "ci(int" macro
:& ci(int
Example: nest blocking macro inside non-blocking
:& \e:@ \e\e:blocking<^V><^M>i continue in non-blocking
Example: enable permanent vi line numbers
:& 2#
.Ed

.It Cm @{\fImacro\fP}
Global blocking macro
.Bd -literal
Execute raw vi/ex input sequence.
A blocking macro shall wait for input when the end of the sequence
is reached. A blocking macro executing other macros may cause
input congestion.

Example: execute vi insert statement
:@ ihello
Example: insert "hello" into <:> vi prompt
:@ \e:hello
Example: execute vi "ci(int" macro
:@ ci(int
Example: execute "ci(int" exiting insert mode
:@ ci(int<^V><^C>
Example: execute "ci)INT" as a follow-up
:@ ci(int<^V><^C>ci)INT
Example: execute vi "dw" command after user exits insert
:@i:@dw
.Ed

.It Cm [\fIcount\fP <\fI$\fP>]?{\fIcond\fP}[<\fI?\fP>][\fIthen\fP][<\fI?\fP>][\fIelse\fP]
While loop conditional
.Bd -literal
Repeat cmd #0 times or infinite with <$>.
While loop is broken once cmd returns an error or count exceeded.
No prefix creates a conditional with count set to 1.

Example: attempt to join every line in file using arbitrary count
:10000? & J
Example: undo everything
:$? u
Example: repeat chain of ex commands 10 times
:10? 1p\e:5p\e:10p
Example: calculate directory only if :cd succeeded
:? cd /blah?fd
Example: print a line only if it contains "int" at offset 5
:? ;5;#>^int>?p
Example: edit vi.c only if it exists
:? \e![ -f ./vi.c ]?e ./vi.c:mpt1
.Ed

.It Cm [\fIcount\fP <\fI$\fP>]?!{\fIcond\fP}[<\fI?\fP>][\fIelse\fP][<\fI?\fP>][\fIthen\fP]
Inverted while loop conditional

.It Cm [\fIrange\fP]pu[<\fIreg\fP>][*][\e!{\fIcmd\fP}]
Paste or pipe a register
.Bd -literal
Example: paste <a> at line 1 character offset 5
:1;5pu a
Example: copy default register to X11 clipboard
:pu \e!xclip -selection clipboard
Example: copy register <a> to X11 clipboard
:pu a \e!xclip -selection clipboard
.Ed

.It Cm [\fIrange\fP]r[\fIpath\fP]
.It Cm [\fIrange\fP]r[\e!{\fIcmd\fP}]
Read a file or a pipe
.Bd -literal
Range is computed on a target.
No range evaluates to <%> range.
No argument evaluates to current buffer path.

Example: read a file
:r vi.c
Example: pipe in all data
:r \e!ls
Example: pipe in only lines 3,5
:3,5r \e!ls
.Ed

.It Cm [\fIrange\fP]w[\fIpath\fP]
.It Cm [\fIrange\fP]w[\e!{\fIcmd\fP}]
Write a file or a pipe
.Bd -literal
No range evaluates to <%> range.
No argument evaluates to current buffer path.

Example: write a file
:w vi.c
Example: pipe out all data into less
:w \e!less
Example: pipe out only first 10 lines
:1,10w \e!less
.Ed

.It Cm [\fIrange\fP]w![\fIpath\fP]
Force write to a file

.It Cm q
Exit
.It Cm q!
Force quit

.It Cm wq
.It Cm x
.Bd -compact
Write and exit
.Ed
.It Cm wq!
.It Cm x!
.Bd -compact
Force write and quit
.Ed

.It Cm u
Undo
.It Cm rd
Redo

.It Cm [\fIvrange\fP]s{<\fI*\fP>}[\fIregex\fP]{<\fI*\fP>}{\fIstr\fP}[<\fI*\fP>][<\fIg\fP>]
Substitute
.Bd -literal
Find and replace text in a range of lines that matches an
enclosed regex with an enclosed replacement string.

Example: global replacement
:%s/term1/term2/g

Example: replace matching previously set regex
:%s//term2/g

Substitution backreference inserts the text of matched group
specified by \ex where x is group number.

Example: substitution backreference
this is an example text for subs and has int or void
:%s/(int)|(void)/pre\e0after
this is an example text for subs and has preintafter or void
:%s/(int)|(void)/pre\e2after/g
this is an example text for subs and has prepreafterafter or prevoidafter
.Ed

.It Cm [\fIrange\fP]ya[<\fIreg\fP>][\fI*\fP]
Yank into a register
.Bd -literal
Argument value range is 0x1-0xff and 0x0 without.
Any extra argument appends to the register.
Default register cannot be appended to.

Example: append to register <1>
:ya 1x
Example: yank into <a> using ranges
:1,5;5;5ya a
.Ed

.It Cm ya![<\fIreg\fP>]
Free a register

.It Cm [\fIrange\fP]![\fIcmd\fP]
Run an external program
.Bd -literal
When a range is specified, the buffer's data is piped to an external
program. The resulting stdout is then piped back into the buffer,
replacing the contents of the original range.

Example: infamously sort a buffer
:%!sort
Example: use sed to replace "int" with "uint"
:%!sed -e 's/int/uint/g'
Example: pipe in result of ls command without replace
:;$+1!ls
Example: capitalize word at current position using tr
:;;>\e\e>>!tr '[\e:lower\e:]' '[\e:upper\e:]'
.Ed

.It Cm ft[\fIfiletype\fP]
Set a filetype
.Bd -literal
No argument prints the current file type.
Reloads the highlight ft, which makes it possible to reset dynamic
highlights created by options like "hlw".
.Ed

.It Cm cm[\fIkeymap\fP]
Set a keymap
.Bd -literal
No argument prints the current keymap name.
.Ed

.It Cm cm![\fIkeymap\fP]
Set an alternative keymap

.It Cm fd[\fIpath\fP]
Set a secondary directory
.Bd -literal
Recalculates directory listing in b-2 buffer.
No argument implies current directory.
.Ed

.It Cm fp[\fIpath\fP]
Set a directory path for :fd command

.It Cm cd[\fIpath\fP]
Set a working directory
.Bd -literal
No argument relinks the current directory in case it got removed
or unmounted.

Currently open buffers' file paths will be automatically adjusted
to reflect a newly set working directory.
.Ed

.It Cm inc[\fIregex\fP]
Include regex for :fd calculation
.Bd -literal
No argument disables the filter.

Example: include only files in submodule directory that end with .c
:inc submodule.*\e.c$
Example: exclude .git and submodule folders
:inc (^(?\e:(?\e!^\e.git|^submodule).)+[^/]+$)
.Ed

.It Cm reg
Print registers and their contents
.Bd -literal
Example: shift the printing position to view offscreen register parts
:1left:reg
.Ed

.It Cm bx[\fI#\fP]
Set max number of buffers allowed
.Bd -literal
Buffers will be deallocated if the number specified is lower
than the number of buffers currently in use.
No argument will reset to the default value of 10.
.Ed

.It Cm ac[\fIregex\fP]
Set autocomplete filter regex
.Bd -literal
No argument resets to the default word filter regex as defined
in led.c.

Example: autocomplete using whole lines from a buffer
:ac .+
.Ed

.It Cm [0-2]sc[sep][exp][exe]
Set ex special characters
.Bd -literal
Prefix selects a specific character to change.
Missing arguments are set to their default values.

Example: change <%> to <a>
:1sc a
Example: change all to <a> <b> <c>
:sc abc
.Ed

.It Cm [0-2]sc![sep][exp][exe]
Set ex special characters
.Bd -literal
Missing arguments are set to <0x0>.

Example: disable [exp] and [exe]
:sc! \e:
.Ed

.It Cm uc
Toggle multibyte utf-8 decoding
.Bd -literal
This command is particularly useful when editing files with
mixed encodings, binary files, or when the terminal does not
support UTF-8 or lacks the necessary fonts to display UTF-8
characters. It's often paired with :ph command to achieve
hex editor-like functionality.
.Ed

.It Cm uz
Toggle zero width placeholders
.Bd -literal
Use only if you need to hide zero width characters.
.Ed

.It Cm ub
Toggle combining multicodepoint placeholders
.Bd -literal
Use only if your terminal can render multicodepoint utf-8 (emojis).
.Ed

.It Cm ph[\fI#clow\fP] [\fI#chigh\fP] [\fI#width\fP] [\fI#blen\fP][\fI*char\fP]
Redefine placeholders
.Bd -literal
This command replaces placeholders defined in conf.c
and subsequent :ph commands expand the list of placeholders.

Example: render 8 bit ascii (Extended ASCII) as <~>
:ph 128 255 1 1~
Example: flawless ISO/IEC 8859-1 (latin-1) support
:uc:ph 128 160 1 1~
Example: render control byte 03 as "^C"
:ph 3 3 2 1^C
Example: reset to default as in conf.c
:ph
Example: disable default placeholders in conf.c
:ph:ph0
.Ed
.
.El
.
.Sh EX OPTIONS
.Bd -literal -compact
Ex options are ex commands designed to alter global variables.
Values hold a signed integer. Values may represent a character.
Default value is specified in val=* as part of an argument notation.
No argument inverts the current value, unless stated otherwise.
.Ed

.Bl -tag -width Ds -compact
.
.It Cm ai[\fIval=1\fP]
Indent new lines
.Bd -literal
This is a max indent length multiplier: val * 128
.Ed
.
.It Cm ic[\fIval=1\fP]
Ignore case in regular expressions

.It Cm ish[\fIval=0\fP]
Interactive shell
.Bd -literal
Run every <!> command through an interactive shell.
The shell will source the .rc file before command execution.
This makes it possible to use predefined functions, aliases
and ENV variables from the .rc file.
Precondition 1:
	The .rc filename is shell specific, such as .bashrc in Bash
	and .zshrc in Zsh.
Precondition 2:
	The environment variable $SHELL determines the default
	shell, otherwise it defaults to /bin/sh.
Precondition 3:
	There must be no stdout output created by .rc file
	for <!> commands to return expected results.
.Ed

.It Cm grp[\fIval=0\fP]
Regex search group
.Bd -literal
Defines a target search group for any regex search operation.
This becomes necessary when the result of regex search is to
be based on some group rather than default match group.

The value of grp must be divisible by 2.

Example: position on a character prefixed by "int"
:grp 2:%f+int(.):grp
.Ed

.
.It Cm hl[\fIval=1\fP]
Highlight text based on rules defined in
.Pa conf.c
.
.It Cm hlr[\fIval=0\fP]
Highlight text in reverse direction
.
.It Cm hll[\fIval=0\fP]
Highlight current line based on filetype hl
.
.It Cm hlp[\fIval=0\fP]
Highlight "[]" "()" "{}" pairs based on filetype hl
.
.It Cm hlw[\fIval=0\fP]
Highlight current word based on filetype hl
.
.It Cm led[\fIval=1\fP]
Enable all terminal output

.It Cm vis[\fIval=0\fP]
Control startup flags
.Bd -literal
Example: disable :e message in ex mode
:vis 12
Example: disable :e message in vi mode
:vis 8
Example: enable raw ex mode
:vis 6
Example: disable raw ex mode
:vis 4
.Ed

.It Cm mpt[\fIval=0\fP]
Control vi prompts
.Bd -literal
When set to 0 or 1 after an ex command is called from vi, disables
the "[any key to continue]" prompt.
If mpt is negative, the prompt will remain disabled.

Example: block the prompt and the last print
:p:p:p:mpt 0
Example: block the prompt but not the last print
:p:p:p:mpt 1
.Ed

.It Cm order[\fIval=1\fP]
Reorder characters based on rules defined in
.Pa conf.c
.
.It Cm shape[\fIval=1\fP]
Perform Arabic script letter shaping
.
.It Cm pac[\fIval=0\fP]
Print autocomplete suggestions on the fly
.
.It Cm ts[\fIval=8\fP]
Number of spaces used to represent a tab
.
.It Cm td[\fIval=1\fP]
Current text direction context

This option accepts four meaningful values:
.Bl -tag -width Ds -compact
.It Ar 2
Exclusively left-to-right
.It Ar 1
Follow
.Va dctxs[]
(in
.Pa conf.c ) ,
defaulting to left-to-right
.It Ar -1
Follow
.Va dctxs[] ,
defaulting to right-to-left
.It Ar -2
Exclusively right-to-left
.El

.It Cm pr[\fIval=0\fP]
Print register
.Bd -literal
Set a special register using a character or a number.
Once the register is set, all data passed into ex_print will
be stored in the register.

If the register is uppercase, <Newline> characters are added
to match the exact output that was printed.

Print register contents cannot be displayed with R or :reg command
when register is assigned (self-referential problem).

Example: paste current buffer list exactly like from :b command
:pr A:ya! A: b:pu A
Example: store a line printed with :p
:pr A:ya! A:p
.Ed

.It Cm rcm[\fIval=1\fP]
Range command model
.Bd -literal
Controls when an ex command nested inside ex range executes.
0 - exec at command parse
1 - exec at command range
.Ed

.It Cm lim[\fIval=-1\fP]
Line length render limit
.Bd -literal
Set render cutoff length for non cursor lines in vi and all
lines in ex mode.

Improves redraw performance when editing a file containing one
or many long lines (1MB+ per line).

Example: reasonable value
:lim 5000
Example: render only the cursor line
:lim 0
Example: disable the limit
:lim -1
.Ed

.It Cm seq[\fIval=1\fP]
Control Undo/Redo
.Bd -literal
When seq is 0, multiple distinct operations undo/redo in a
single step.

To optimize memory usage under heavy workloads, undo/redo
tracking can be disabled by setting seq to a negative value.

Example: test undo/redo operations in a single step
:&ocontrol test:seq 0:&a step1:&a step2:&a step3:seq
Example: completely disable undo/redo
:seq -1
.Ed

.It Cm [\fIhscroll\fP]left[\fIval=0\fP]
Control horizontal scroll
.Bd -literal
No argument calculates the value using current character offset.
hscroll computes the value using: xcols / 2 * hscroll
.Ed

.It Cm err[\fIval=1\fP]
Control ex errors
.Bd -literal
Example: silence and ignore errors
:err 4
Example: report and return on first error
:err 3
Example: report and consider only last command for error status
:err 1
.Ed
.
.El
.
.Sh EXINIT ENV VAR
.Bd -literal
EXINIT defines a sequence of vi/ex commands to be performed
at startup. Consequently, this is the primary way for scripting
and customizing Nextvi outside of C.
Many standard text processing utils such as grep, awk, sed
can be replaced by Nextvi with EXINIT in mind.

Examples:
.Ed

.Bl -tag -width Ds -compact
.It Cm export EXINIT="$(printf '%b' 'e ./vi.c:& i\ex7\ex3:bx 1:bx')"
Index vi.c for autocomplete

.It Cm export EXINIT='b-1:r ./vi.c:b-1'
Load vi.c into a history buffer

.It Cm export EXINIT="$(printf '%b' 'e:& io{\en}\ex16\ex3kA\ex3:& 1G:& 2"aY')"
Setup @ macro in register <a>

@a macro creates <{> and closing <}> below the cursor leaving
cursor in insert mode in between the braces.

.It Cm export EXINIT='td 2:order 0:lim 5000'
Set ex options for optimal long line performance
.El
.
.Sh REGEX
.Bd -literal
Pikevm is a fast non backtracking NFA simulation regex engine
developed for Nextvi. It ensures regular expressions are evaluated
in constant space and O(n + k) time complexity where <n> is
the input string length and <k> represents the regex’s structural
complexity (e.g., state transitions or alternations). While
this does not guarantee strict O(n) linear runtime performance,
it ensures computational and memory resources are distributed
linearly and evenly across the input, with <k> directly influencing
the constant factor. This principle is similar to the concept
utilized in radix sort algorithms.

Pikevm's syntax is akin to regexp(7) from Plan 9.
Disregard manpage notation in this section.
.Ed
.Bl -tag -width Ds -compact

.It Cm \&.
Match any single char
.It Cm [\fIN\fP-\fIM\fP]
Match a set of alternate ranges N to M
.It Cm {\fIN\fP,\fIM\fP}
Match N to M times
.It Cm ()
Capture grouping
.It Cm (?:)
Non capture grouping
.It Cm *
Repeated zero or more times
.It Cm +
Repeated one or more times
.It Cm \&|
Union, alternative branch
.It Cm \&?
One or zero matches greedy
.It Cm \&??
One or zero matches lazy
.It Cm ^
Assert start of line
.It Cm $
Assert end of line
.It Cm \e<
Assert start of word
.It Cm \e>
Assert end of word
.It Cm \&(?=)
Assert positive lookahead
.It Cm \&(?!)
Assert negative lookahead
.It Cm \&(?>)
Assert positive lookbehind
.It Cm \&(?<)
Assert negative lookbehind
.It Cm \&(?#)
Lookbehind offset in bytes
.El
.
.Bd -literal
Lookaround expressions enable the creation of regular expressions
that would be impossible to construct without them. They can
be used anywhere within a regex, though some considerations
must be taken into account.
Aspect 1:
	Lookarounds contain a full regular expression.
Aspect 2:
	Lookarounds can have nested lookarounds.
Aspect 3:
	Static lookarounds like (?=^word) are optimized, bypassing
	the regex engine.
Aspect 4:
	Lookarounds are best suited for asserting near the end of a
	complex pattern, where the engine has already narrowed down
	potential matches.
Aspect 5:
	Lookbehind without offset or 0 offset begins at previous character.
	Offset begins scanning from current position minus specified
	value. Negative offset begins at the start of the string.
.Ed
.
.Sh SPECIAL MARKS
.Bl -tag -width Ds -compact
.It Cm *
Position of previous ex command
.It Cm \&[
First line of previous change
.It Cm \&]
Last line of previous change
.It Cm \&'
Position of previous line region
.It Cm \&`
Position of previous line region
.El
.
.Sh SPECIAL REGISTERS
.Bl -tag -width Ds -compact
.It Cm /
Previous regex keyword
.It Cm \&:
Previous ex command
.It Cm <0x0>
Default register
.It Cm 0
Previous value of default register (atomic)
.Bd -literal -compact
Atomic means the operation did not include a <Newline>.
.Ed
.It Cm <1-9>
Previous value(s) of default register (nonatomic)
.El
.
.Sh CODE MAP
.TS
tab(|);
| l | l |.
_
 537 kmap.h | keymap translation
 544 vi.h | definitions/aux
_
 332 conf.c | hl/ft/td config
 361 term.c | low level IO
 409 ren.c | positioning/syntax
 614 uc.c | UTF-8 support
 654 lbuf.c | file/line buffer
 718 led.c | insert mode/output
 766 regex.c | pikevm
 1604 ex.c | ex options/commands
 1836 vi.c | normal mode/general
 7294 total | wc -l *.c\(basort
_
.TE
.
.Sh COMPILING
.Bl -tag -width Ds -compact
.It Cm export CC='g++ -x c'
Set compiler, g++ example
.It Cm export CFLAGS='-s'
Set CFLAGS, strip example
.It Cm ./cbuild.sh
Build once
.It Cm ./cbuild.sh build
Build
.It Cm ./cbuild.sh debug
Build with symbols, static analysis, dynamic analysis, and no optimizations
.It Cm ./cbuild.sh pgobuild
PGO build can lead to a significant performance boost on
some application specific tasks
.It Cm ./cbuild.sh install
Install vi to $DESTDIR$PREFIX/bin
.It Cm ./cbuild.sh fetch
Merge commits from upstream repository
.It Cm ./cbuild.sh bench
Performance bench test 2000 word deletions on vi.c
.El
.
.Sh PHILOSOPHY
.Bd -literal -compact
In most text editors, flexibility is a minor or irrelevant design
goal. Nextvi is designed to be flexible where the editor adapts
to the user needs. This flexibility is achieved by heavily chaining
basic commands and allowing them to create new ones with completely
different functionality. Command reuse keeps the editor small
without infringing on your freedom to quickly get a good grasp
on the code. If you want to customize anything, you should be
able to do it using only core commands or a mix with some specific
C code for more difficult tasks. Simple and flexible design
allows for straight forward solutions to any problem long term
and filters bad inconsistent ideas.

.Sy \&"All software sucks, but some do more than others."
.Em 	- Kyryl Melekhin
.Ed
.
.Sh SEE ALSO
.Bd -literal -compact
New functionality can be obtained through optional patches provided
in the patches branch. If you have a meaningful contribution
and would love to be made public the patch can be submitted
via email or github pull request.
.Lk https://github.com/kyx0r/nextvi/tree/patches

Scripts used to generate this manual are located in the manual
branch.
.Lk https://github.com/kyx0r/nextvi/tree/manual

Original Neatvi repository
.Lk https://github.com/aligrudi/neatvi

Posix vi(1)
.Lk https://pubs.opengroup.org/onlinepubs/9699919799/utilities/vi.html

Posix ex(1)
.Lk https://pubs.opengroup.org/onlinepubs/9699919799/utilities/ex.html

NFA regular expressions by Russ Cox
.Lk https://swtch.com/~rsc/regexp/regexp1.html

Plan 9 regexp(7)
.Lk https://man.cat-v.org/p9p/7/regexp
.Ed
.
.Sh AUTHORS
.An -nosplit
.Nm
was written by
.An Kyryl Melekhin Aq Mt k.melekhin@gmail.com .
It is based on
.Xr neatvi 1 Ns ,
which was written by
.An Ali Gholami Rudi Aq Mt ali@rudi.ir .
.\" add more contributors here?
This manual page was inspired by
.An népéta Aq Mt nepeta@canaglie.net
