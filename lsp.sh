#!/bin/sh
# Generated by patch2vi from unified diff
# Available separators: 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x0b 0x0c 0x0e 0x0f 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e 0x1f 0x5e 0x7f 0x80 0x81 0x82 0x83 0x84 0x85 0x86 0x87 0x88 0x89 0x8a 0x8b 0x8c 0x8d 0x8e 0x8f 0x90 0x91 0x92 0x93 0x94 0x95 0x96 0x97 0x98 0x99 0x9a 0x9b 0x9c 0x9d 0x9e 0x9f 0xa0 0xa1 0xa2 0xa3 0xa4 0xa5 0xa6 0xa7 0xa8 0xa9 0xaa 0xab 0xac 0xad 0xae 0xaf 0xb0 0xb1 0xb2 0xb3 0xb4 0xb5 0xb6 0xb7 0xb8 0xb9 0xba 0xbb 0xbc 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 0xca 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 0xd8 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 0xe1 0xe2 0xe3 0xe4 0xe5 0xe6 0xe7 0xe8 0xe9 0xea 0xeb 0xec 0xed 0xee 0xef 0xf0 0xf1 0xf2 0xf3 0xf4 0xf5 0xf6 0xf7 0xf8 0xf9 0xfa 0xfb 0xfc 0xfd 0xfe 0xff
set -e

# Pass any argument to use patch(1) instead of nextvi ex commands
if [ -n "$1" ]; then
    sed '1,/^=== PATCH2VI PATCH ===$/d' "$0" | patch -p1 --merge=diff3
    exit $?
fi

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Uncomment to enter interactive vi on patch failure
#DBG="|sc|vis 2:e $0:@Q:q!1"
# Uncomment to skip errors (. = silent nop)
#DBG="."
# Set QF=. to continue despite errors (errors are still printed)
#QF=.

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
SEP="$(printf '\x01')"
QF=${QF-"$(printf 'vis 2\\\x01q! 1')"}
EXINIT="rcm:|sc! \\\\${SEP}|vis 3${SEP}%;f> 	if \\\\(cd == 3 \\\\|\\\\| \\\\(!rd && fd >= 0\\\\)\\\\) \\\\{
		ex_bufpostfix\\\\(ex_buf, arg\\\\[0\\\\]\\\\);
		syn_setft\\\\(xb_ft\\\\);${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 374\\${SEP}${QF}}${SEP};=
${SEP}+2a 		if (*xb_path && xb_ft)
			lsp_open(xb_path, xb_ft);
.
${SEP}.,\$;f> 			ec_setpath\\\\(NULL, NULL, path\\\\);
		lbuf_saved\\\\(xb, 0\\\\);
		ex_buf->mtime = mtime\\\\(path\\\\);${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 711\\${SEP}${QF}}${SEP};=
${SEP}+2a 		if (*xb_path)
			lsp_save(xb_path);
.
${SEP}.,\$;f> 	return NULL;
\\\\)

${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 1393\\${SEP}${QF}}${SEP};=
${SEP}+2a static void *ec_lsp(char *loc, char *cmd, char *arg)
{
	char ft[32];
	int n = 0;
	if (!*arg) { lsp_list(); return NULL; }
	while (arg[n] && arg[n] != ' ' && n < (int)sizeof(ft)-1) {
		ft[n] = arg[n];
		n++;
	}
	ft[n] = '\\\\0';
	while (arg[n] == ' ') n++;
	if (!arg[n]) return \"lsp: missing server command\";
	lsp_register(ft, arg+n);
	return NULL;
	(void)loc; (void)cmd;
}

.
${SEP}.,\$;f> 	EO\\\\(hlp\\\\),
	EO\\\\(hlr\\\\),
	EO\\\\(hl\\\\),${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 1480\\${SEP}${QF}}${SEP};=
${SEP}+2a 	{\"lsp\", ec_lsp},
.
${SEP}vis 2${SEP}wq" $VI -e 'ex.c'

# Patch: jsmn.h
SEP="$(printf '\x01')"
QF=${QF-"$(printf 'vis 2\\\x01q! 1')"}
EXINIT="rcm:|sc! \\\\${SEP}|vis 3${SEP}i /*
 * MIT License
 *
 * Copyright (c) 2010 Serge Zaitsev
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the \"Software\"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef JSMN_H
#define JSMN_H

#include <stddef.h>

#ifdef __cplusplus
extern \"C\" {
#endif

#ifdef JSMN_STATIC
#define JSMN_API static
#else
#define JSMN_API extern
#endif

/**
 * JSON type identifier. Basic types are:
 * 	o Object
 * 	o Array
 * 	o String
 * 	o Other primitive: number, boolean (true/false) or null
 */
typedef enum {
  JSMN_UNDEFINED = 0,
  JSMN_OBJECT = 1 << 0,
  JSMN_ARRAY = 1 << 1,
  JSMN_STRING = 1 << 2,
  JSMN_PRIMITIVE = 1 << 3
} jsmntype_t;

enum jsmnerr {
  /* Not enough tokens were provided */
  JSMN_ERROR_NOMEM = -1,
  /* Invalid character inside JSON string */
  JSMN_ERROR_INVAL = -2,
  /* The string is not a full JSON packet, more bytes expected */
  JSMN_ERROR_PART = -3
};

/**
 * JSON token description.
 * type		type (object, array, string etc.)
 * start	start position in JSON data string
 * end		end position in JSON data string
 */
typedef struct jsmntok {
  jsmntype_t type;
  int start;
  int end;
  int size;
#ifdef JSMN_PARENT_LINKS
  int parent;
#endif
} jsmntok_t;

/**
 * JSON parser. Contains an array of token blocks available. Also stores
 * the string being parsed now and current position in that string.
 */
typedef struct jsmn_parser {
  unsigned int pos;     /* offset in the JSON string */
  unsigned int toknext; /* next token to allocate */
  int toksuper;         /* superior token node, e.g. parent object or array */
} jsmn_parser;

/**
 * Create JSON parser over an array of tokens
 */
JSMN_API void jsmn_init(jsmn_parser *parser);

/**
 * Run JSON parser. It parses a JSON data string into and array of tokens, each
 * describing
 * a single JSON object.
 */
JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
                        jsmntok_t *tokens, const unsigned int num_tokens);

#ifndef JSMN_HEADER
/**
 * Allocates a fresh unused token from the token pool.
 */
static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
                                   const size_t num_tokens) {
  jsmntok_t *tok;
  if (parser->toknext >= num_tokens) {
    return NULL;
  }
  tok = &tokens[parser->toknext++];
  tok->start = tok->end = -1;
  tok->size = 0;
#ifdef JSMN_PARENT_LINKS
  tok->parent = -1;
#endif
  return tok;
}

/**
 * Fills token type and boundaries.
 */
static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
                            const int start, const int end) {
  token->type = type;
  token->start = start;
  token->end = end;
  token->size = 0;
}

/**
 * Fills next available token with JSON primitive.
 */
static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
                                const size_t len, jsmntok_t *tokens,
                                const size_t num_tokens) {
  jsmntok_t *token;
  int start;

  start = parser->pos;

  for (; parser->pos < len && js[parser->pos] != '\\\\0'; parser->pos++) {
    switch (js[parser->pos]) {
#ifndef JSMN_STRICT
    /* In strict mode primitive must be followed by \",\" or \"}\" or \"]\" */
    case ':':
#endif
    case '\\\\t':
    case '\\\\r':
    case '\\\\n':
    case ' ':
    case ',':
    case ']':
    case '}':
      goto found;
    default:
                   /* to quiet a warning from gcc*/
      break;
    }
    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
      parser->pos = start;
      return JSMN_ERROR_INVAL;
    }
  }
#ifdef JSMN_STRICT
  /* In strict mode primitive must be followed by a comma/object/array */
  parser->pos = start;
  return JSMN_ERROR_PART;
#endif

found:
  if (tokens == NULL) {
    parser->pos--;
    return 0;
  }
  token = jsmn_alloc_token(parser, tokens, num_tokens);
  if (token == NULL) {
    parser->pos = start;
    return JSMN_ERROR_NOMEM;
  }
  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
#ifdef JSMN_PARENT_LINKS
  token->parent = parser->toksuper;
#endif
  parser->pos--;
  return 0;
}

/**
 * Fills next token with JSON string.
 */
static int jsmn_parse_string(jsmn_parser *parser, const char *js,
                             const size_t len, jsmntok_t *tokens,
                             const size_t num_tokens) {
  jsmntok_t *token;

  int start = parser->pos;
  
  /* Skip starting quote */
  parser->pos++;
  
  for (; parser->pos < len && js[parser->pos] != '\\\\0'; parser->pos++) {
    char c = js[parser->pos];

    /* Quote: end of string */
    if (c == '\\\\\"') {
      if (tokens == NULL) {
        return 0;
      }
      token = jsmn_alloc_token(parser, tokens, num_tokens);
      if (token == NULL) {
        parser->pos = start;
        return JSMN_ERROR_NOMEM;
      }
      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
#ifdef JSMN_PARENT_LINKS
      token->parent = parser->toksuper;
#endif
      return 0;
    }

    /* Backslash: Quoted symbol expected */
    if (c == '\\\\\\\\' && parser->pos + 1 < len) {
      int i;
      parser->pos++;
      switch (js[parser->pos]) {
      /* Allowed escaped symbols */
      case '\\\\\"':
      case '/':
      case '\\\\\\\\':
      case 'b':
      case 'f':
      case 'r':
      case 'n':
      case 't':
        break;
      /* Allows escaped symbol \\\\uXXXX */
      case 'u':
        parser->pos++;
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\\\\0';
             i++) {
          /* If it isn't a hex character we have an error */
          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */
                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
            parser->pos = start;
            return JSMN_ERROR_INVAL;
          }
          parser->pos++;
        }
        parser->pos--;
        break;
      /* Unexpected symbol */
      default:
        parser->pos = start;
        return JSMN_ERROR_INVAL;
      }
    }
  }
  parser->pos = start;
  return JSMN_ERROR_PART;
}

/**
 * Parse JSON string and fill tokens.
 */
JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
                        jsmntok_t *tokens, const unsigned int num_tokens) {
  int r;
  int i;
  jsmntok_t *token;
  int count = parser->toknext;

  for (; parser->pos < len && js[parser->pos] != '\\\\0'; parser->pos++) {
    char c;
    jsmntype_t type;

    c = js[parser->pos];
    switch (c) {
    case '{':
    case '[':
      count++;
      if (tokens == NULL) {
        break;
      }
      token = jsmn_alloc_token(parser, tokens, num_tokens);
      if (token == NULL) {
        return JSMN_ERROR_NOMEM;
      }
      if (parser->toksuper != -1) {
        jsmntok_t *t = &tokens[parser->toksuper];
#ifdef JSMN_STRICT
        /* In strict mode an object or array can't become a key */
        if (t->type == JSMN_OBJECT) {
          return JSMN_ERROR_INVAL;
        }
#endif
        t->size++;
#ifdef JSMN_PARENT_LINKS
        token->parent = parser->toksuper;
#endif
      }
      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
      token->start = parser->pos;
      parser->toksuper = parser->toknext - 1;
      break;
    case '}':
    case ']':
      if (tokens == NULL) {
        break;
      }
      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
#ifdef JSMN_PARENT_LINKS
      if (parser->toknext < 1) {
        return JSMN_ERROR_INVAL;
      }
      token = &tokens[parser->toknext - 1];
      for (;;) {
        if (token->start != -1 && token->end == -1) {
          if (token->type != type) {
            return JSMN_ERROR_INVAL;
          }
          token->end = parser->pos + 1;
          parser->toksuper = token->parent;
          break;
        }
        if (token->parent == -1) {
          if (token->type != type || parser->toksuper == -1) {
            return JSMN_ERROR_INVAL;
          }
          break;
        }
        token = &tokens[token->parent];
      }
#else
      for (i = parser->toknext - 1; i >= 0; i--) {
        token = &tokens[i];
        if (token->start != -1 && token->end == -1) {
          if (token->type != type) {
            return JSMN_ERROR_INVAL;
          }
          parser->toksuper = -1;
          token->end = parser->pos + 1;
          break;
        }
      }
      /* Error if unmatched closing bracket */
      if (i == -1) {
        return JSMN_ERROR_INVAL;
      }
      for (; i >= 0; i--) {
        token = &tokens[i];
        if (token->start != -1 && token->end == -1) {
          parser->toksuper = i;
          break;
        }
      }
#endif
      break;
    case '\\\\\"':
      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
      if (r < 0) {
        return r;
      }
      count++;
      if (parser->toksuper != -1 && tokens != NULL) {
        tokens[parser->toksuper].size++;
      }
      break;
    case '\\\\t':
    case '\\\\r':
    case '\\\\n':
    case ' ':
      break;
    case ':':
      parser->toksuper = parser->toknext - 1;
      break;
    case ',':
      if (tokens != NULL && parser->toksuper != -1 &&
          tokens[parser->toksuper].type != JSMN_ARRAY &&
          tokens[parser->toksuper].type != JSMN_OBJECT) {
#ifdef JSMN_PARENT_LINKS
        parser->toksuper = tokens[parser->toksuper].parent;
#else
        for (i = parser->toknext - 1; i >= 0; i--) {
          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
            if (tokens[i].start != -1 && tokens[i].end == -1) {
              parser->toksuper = i;
              break;
            }
          }
        }
#endif
      }
      break;
#ifdef JSMN_STRICT
    /* In strict mode primitives are: numbers and booleans */
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case 't':
    case 'f':
    case 'n':
      /* And they must not be keys of the object */
      if (tokens != NULL && parser->toksuper != -1) {
        const jsmntok_t *t = &tokens[parser->toksuper];
        if (t->type == JSMN_OBJECT ||
            (t->type == JSMN_STRING && t->size != 0)) {
          return JSMN_ERROR_INVAL;
        }
      }
#else
    /* In non-strict mode every unquoted value is a primitive */
    default:
#endif
      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
      if (r < 0) {
        return r;
      }
      count++;
      if (parser->toksuper != -1 && tokens != NULL) {
        tokens[parser->toksuper].size++;
      }
      break;

#ifdef JSMN_STRICT
    /* Unexpected char in strict mode */
    default:
      return JSMN_ERROR_INVAL;
#endif
    }
  }

  if (tokens != NULL) {
    for (i = parser->toknext - 1; i >= 0; i--) {
      /* Unmatched opened object or array */
      if (tokens[i].start != -1 && tokens[i].end == -1) {
        return JSMN_ERROR_PART;
      }
    }
  }

  return count;
}

/**
 * Creates a new parser based over a given buffer with an array of tokens
 * available.
 */
JSMN_API void jsmn_init(jsmn_parser *parser) {
  parser->pos = 0;
  parser->toknext = 0;
  parser->toksuper = -1;
}

#endif /* JSMN_HEADER */

#ifdef __cplusplus
}
#endif

#endif /* JSMN_H */
.
${SEP}vis 2${SEP}wq" $VI -e 'jsmn.h'

# Patch: lsp.c
SEP="$(printf '\x01')"
QF=${QF-"$(printf 'vis 2\\\x01q! 1')"}
EXINIT="rcm:|sc! \\\\${SEP}|vis 3${SEP}i /* lsp.c - Language Server Protocol client for nextvi */
#include \"jsmn.h\"
#include <errno.h>

#define LSP_DIAG_MAX	64
#define LSP_SRV_MAX	8
#define LSP_RBUF_MAX	65536

typedef struct {
	int line, col, severity;
	char msg[256];
} lsp_diag;

typedef struct {
	char path[1024];
	lsp_diag *d;
	int n, cap;
} lsp_diagfile;

typedef struct {
	char ft[32], cmd[256];
	int pid, in_fd, out_fd;
	char rbuf[LSP_RBUF_MAX];
	int rbuf_n;
	int response_ready, pending_id;
	char *response_json;
	int response_len;
	int initialized, next_id;
	char open_path[1024];
	int open_version;
} lsp_server;

int lsp_nfds = 0;
int lsp_fds[LSP_NFDS_MAX];
void (*lsp_fd_ready)(int fd) = NULL;

static lsp_server lsp_srvs[LSP_SRV_MAX];
static int lsp_nsrvs = 0;
static lsp_diagfile lsp_diagfiles[LSP_SRV_MAX * 4];
static int lsp_ndiagfiles = 0;

/* forward declarations */
static void _lsp_process_fd(int fd);
static lsp_server *lsp_find_srv_for_fd(int fd);
static void lsp_dispatch_messages(lsp_server *srv);
static void lsp_handle_message(lsp_server *srv, char *json, int len);

void lsp_init(void)
{
	lsp_fd_ready = _lsp_process_fd;
}

void lsp_register(const char *ft, const char *cmd)
{
	int i;
	for (i = 0; i < lsp_nsrvs; i++) {
		if (!strcmp(lsp_srvs[i].ft, ft)) {
			snprintf(lsp_srvs[i].cmd, sizeof(lsp_srvs[i].cmd), \"%s\", cmd);
			return;
		}
	}
	if (lsp_nsrvs >= LSP_SRV_MAX)
		return;
	snprintf(lsp_srvs[lsp_nsrvs].ft, sizeof(lsp_srvs[0].ft), \"%s\", ft);
	snprintf(lsp_srvs[lsp_nsrvs].cmd, sizeof(lsp_srvs[0].cmd), \"%s\", cmd);
	lsp_srvs[lsp_nsrvs].pid = -1;
	lsp_srvs[lsp_nsrvs].in_fd = -1;
	lsp_srvs[lsp_nsrvs].out_fd = -1;
	lsp_nsrvs++;
}

void lsp_list(void)
{
	int i;
	char buf[512];
	for (i = 0; i < lsp_nsrvs; i++) {
		snprintf(buf, sizeof(buf), \"lsp %s %s [%s]\",
			lsp_srvs[i].ft, lsp_srvs[i].cmd,
			lsp_srvs[i].pid > 0 ? \"running\" : \"stopped\");
		ex_print(buf, bar_ft)
	}
	if (!lsp_nsrvs)
		ex_print(\"lsp: no servers registered\", bar_ft)
}

static lsp_server *lsp_srv_for_ft(const char *ft)
{
	int i;
	for (i = 0; i < lsp_nsrvs; i++)
		if (!strcmp(lsp_srvs[i].ft, ft))
			return &lsp_srvs[i];
	return NULL;
}

static lsp_diagfile *lsp_diagfile_for_path(const char *path)
{
	int i;
	for (i = 0; i < lsp_ndiagfiles; i++)
		if (!strcmp(lsp_diagfiles[i].path, path))
			return &lsp_diagfiles[i];
	if (lsp_ndiagfiles >= LSP_SRV_MAX * 4)
		return NULL;
	snprintf(lsp_diagfiles[lsp_ndiagfiles].path,
		sizeof(lsp_diagfiles[0].path), \"%s\", path);
	lsp_diagfiles[lsp_ndiagfiles].d = NULL;
	lsp_diagfiles[lsp_ndiagfiles].n = 0;
	lsp_diagfiles[lsp_ndiagfiles].cap = 0;
	return &lsp_diagfiles[lsp_ndiagfiles++];
}

static lsp_server *lsp_find_srv_for_fd(int fd)
{
	int i;
	for (i = 0; i < lsp_nsrvs; i++)
		if (lsp_srvs[i].out_fd == fd)
			return &lsp_srvs[i];
	return NULL;
}

static void lsp_json_escape(const char *src, sbuf *sb)
{
	while (*src) {
		if (*src == '\"') {
			sbuf_mem(sb, \"\\\\\\\\\\\\\"\", 2)
		} else if (*src == '\\\\\\\\') {
			sbuf_mem(sb, \"\\\\\\\\\\\\\\\\\", 2)
		} else if (*src == '\\\\n') {
			sbuf_mem(sb, \"\\\\\\\\n\", 2)
		} else if (*src == '\\\\r') {
			sbuf_mem(sb, \"\\\\\\\\r\", 2)
		} else if (*src == '\\\\t') {
			sbuf_mem(sb, \"\\\\\\\\t\", 2)
		} else {
			sbuf_chr(sb, *src)
		}
		src++;
	}
}

static void lsp_uri_from_path(const char *path, char *out, int n)
{
	snprintf(out, n, \"file://%s\", path);
}

static void lsp_path_from_uri(const char *uri, char *out, int n)
{
	if (!strncmp(uri, \"file://\", 7))
		snprintf(out, n, \"%s\", uri + 7);
	else
		snprintf(out, n, \"%s\", uri);
}

static void lsp_send(lsp_server *srv, const char *json, int len)
{
	char hdr[64];
	int hlen = snprintf(hdr, sizeof(hdr),
		\"Content-Length: %d\\\\r\\\\n\\\\r\\\\n\", len);
	write(srv->in_fd, hdr, hlen);
	write(srv->in_fd, json, len);
}

static void lsp_send_sb(lsp_server *srv, sbuf *sb)
{
	sbuf_null(sb)
	lsp_send(srv, sb->s, sb->s_n);
}

static void lsp_buf_content(struct lbuf *lb, sbuf *sb)
{
	int i;
	for (i = 0; i < lbuf_len(lb); i++) {
		char *ln = lbuf_get(lb, i);
		lsp_json_escape(ln, sb);
	}
}

static int lsp_fmt_init(lsp_server *srv, sbuf *sb)
{
	int id = ++srv->next_id;
	char idstr[32];
	itoa(id, idstr);
	char pidstr[32];
	itoa(getpid(), pidstr);
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"id\\\\\":\")
	sbuf_str(sb, idstr)
	sbuf_str(sb, \",\\\\\"method\\\\\":\\\\\"initialize\\\\\",\\\\\"params\\\\\":{\\\\\"processId\\\\\":\")
	sbuf_str(sb, pidstr)
	sbuf_str(sb, \",\\\\\"clientInfo\\\\\":{\\\\\"name\\\\\":\\\\\"nextvi\\\\\"},\\\\\"capabilities\\\\\":{\")
	sbuf_str(sb, \"\\\\\"textDocument\\\\\":{\\\\\"synchronization\\\\\":{\\\\\"didSave\\\\\":true},\")
	sbuf_str(sb, \"\\\\\"hover\\\\\":{\\\\\"contentFormat\\\\\":[\\\\\"plaintext\\\\\",\\\\\"markdown\\\\\"]},\")
	sbuf_str(sb, \"\\\\\"definition\\\\\":{}},\")
	sbuf_str(sb, \"\\\\\"general\\\\\":{\\\\\"positionEncodings\\\\\":[\\\\\"utf-8\\\\\"]}},\")
	sbuf_str(sb, \"\\\\\"rootUri\\\\\":null}}\")
	return id;
}

static void lsp_fmt_initialized(sbuf *sb)
{
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"method\\\\\":\\\\\"initialized\\\\\",\\\\\"params\\\\\":{}}\")
}

static void lsp_fmt_didopen(lsp_server *srv, sbuf *sb, const char *path,
		const char *ft, struct lbuf *lb)
{
	char uri[1280];
	lsp_uri_from_path(path, uri, sizeof(uri));
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"method\\\\\":\\\\\"textDocument/didOpen\\\\\",\")
	sbuf_str(sb, \"\\\\\"params\\\\\":{\\\\\"textDocument\\\\\":{\\\\\"uri\\\\\":\\\\\"\")
	sbuf_str(sb, uri)
	sbuf_str(sb, \"\\\\\",\\\\\"languageId\\\\\":\\\\\"\")
	sbuf_str(sb, ft)
	sbuf_str(sb, \"\\\\\",\\\\\"version\\\\\":1,\\\\\"text\\\\\":\\\\\"\")
	lsp_buf_content(lb, sb);
	sbuf_str(sb, \"\\\\\"}}}\")
	(void)srv;
}

static void lsp_fmt_didchange(lsp_server *srv, sbuf *sb, const char *path,
		struct lbuf *lb)
{
	char uri[1280];
	char ver[32];
	lsp_uri_from_path(path, uri, sizeof(uri));
	itoa(++srv->open_version, ver);
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"method\\\\\":\\\\\"textDocument/didChange\\\\\",\")
	sbuf_str(sb, \"\\\\\"params\\\\\":{\\\\\"textDocument\\\\\":{\\\\\"uri\\\\\":\\\\\"\")
	sbuf_str(sb, uri)
	sbuf_str(sb, \"\\\\\",\\\\\"version\\\\\":\")
	sbuf_str(sb, ver)
	sbuf_str(sb, \"},\\\\\"contentChanges\\\\\":[{\\\\\"text\\\\\":\\\\\"\")
	lsp_buf_content(lb, sb);
	sbuf_str(sb, \"\\\\\"}]}}\")
}

static void lsp_fmt_didsave(sbuf *sb, const char *path)
{
	char uri[1280];
	lsp_uri_from_path(path, uri, sizeof(uri));
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"method\\\\\":\\\\\"textDocument/didSave\\\\\",\")
	sbuf_str(sb, \"\\\\\"params\\\\\":{\\\\\"textDocument\\\\\":{\\\\\"uri\\\\\":\\\\\"\")
	sbuf_str(sb, uri)
	sbuf_str(sb, \"\\\\\"}}}\")
}

static int lsp_fmt_hover(lsp_server *srv, sbuf *sb, const char *path,
		int line, int col)
{
	char uri[1280];
	char idstr[32], linestr[32], colstr[32];
	int id = ++srv->next_id;
	lsp_uri_from_path(path, uri, sizeof(uri));
	itoa(id, idstr);
	itoa(line, linestr);
	itoa(col, colstr);
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"id\\\\\":\")
	sbuf_str(sb, idstr)
	sbuf_str(sb, \",\\\\\"method\\\\\":\\\\\"textDocument/hover\\\\\",\\\\\"params\\\\\":{\\\\\"textDocument\\\\\":{\\\\\"uri\\\\\":\\\\\"\")
	sbuf_str(sb, uri)
	sbuf_str(sb, \"\\\\\"},\\\\\"position\\\\\":{\\\\\"line\\\\\":\")
	sbuf_str(sb, linestr)
	sbuf_str(sb, \",\\\\\"character\\\\\":\")
	sbuf_str(sb, colstr)
	sbuf_str(sb, \"}}}\")
	return id;
}

static int lsp_fmt_definition(lsp_server *srv, sbuf *sb, const char *path,
		int line, int col)
{
	char uri[1280];
	char idstr[32], linestr[32], colstr[32];
	int id = ++srv->next_id;
	lsp_uri_from_path(path, uri, sizeof(uri));
	itoa(id, idstr);
	itoa(line, linestr);
	itoa(col, colstr);
	sbuf_str(sb, \"{\\\\\"jsonrpc\\\\\":\\\\\"2.0\\\\\",\\\\\"id\\\\\":\")
	sbuf_str(sb, idstr)
	sbuf_str(sb, \",\\\\\"method\\\\\":\\\\\"textDocument/definition\\\\\",\\\\\"params\\\\\":{\\\\\"textDocument\\\\\":{\\\\\"uri\\\\\":\\\\\"\")
	sbuf_str(sb, uri)
	sbuf_str(sb, \"\\\\\"},\\\\\"position\\\\\":{\\\\\"line\\\\\":\")
	sbuf_str(sb, linestr)
	sbuf_str(sb, \",\\\\\"character\\\\\":\")
	sbuf_str(sb, colstr)
	sbuf_str(sb, \"}}}\")
	return id;
}

/* jsmn helpers */

static int lsp_tok_eq(const char *json, jsmntok_t *tok, const char *s)
{
	int len = tok->end - tok->start;
	return tok->type == JSMN_STRING &&
		(int)strlen(s) == len &&
		!strncmp(json + tok->start, s, len);
}

static void lsp_tok_str(const char *json, jsmntok_t *tok, char *out, int n)
{
	int len = tok->end - tok->start;
	if (len >= n)
		len = n - 1;
	memcpy(out, json + tok->start, len);
	out[len] = '\\\\0';
}

static int lsp_tok_int(const char *json, jsmntok_t *tok)
{
	char buf[32];
	lsp_tok_str(json, tok, buf, sizeof(buf));
	return atoi(buf);
}

/* skip token at index i and all its children; returns next index */
static int lsp_skip(jsmntok_t *toks, int n, int i)
{
	int end, j;
	if (i >= n)
		return n;
	if (toks[i].type == JSMN_OBJECT || toks[i].type == JSMN_ARRAY) {
		end = i + 1;
		for (j = 0; j < toks[i].size; j++) {
			if (toks[i].type == JSMN_OBJECT)
				end = lsp_skip(toks, n, end); /* key */
			end = lsp_skip(toks, n, end); /* value */
		}
		return end;
	}
	return i + 1;
}

/* find value token index for key in object at toks[obj] */
static int lsp_find_key(const char *json, jsmntok_t *toks, int n,
		int obj, const char *key)
{
	int i, j;
	if (obj >= n || toks[obj].type != JSMN_OBJECT)
		return -1;
	i = obj + 1;
	for (j = 0; j < toks[obj].size; j++) {
		if (i >= n)
			break;
		int val = i + 1;
		if (lsp_tok_eq(json, &toks[i], key))
			return val < n ? val : -1;
		i = lsp_skip(toks, n, val);
	}
	return -1;
}

static void lsp_handle_diagnostics(lsp_server *srv, const char *json,
		jsmntok_t *toks, int n)
{
	int params, uri_tok, diags_tok, i, di;
	char path[1024];
	lsp_diagfile *df;

	params = lsp_find_key(json, toks, n, 0, \"params\");
	if (params < 0)
		return;
	uri_tok = lsp_find_key(json, toks, n, params, \"uri\");
	if (uri_tok < 0)
		return;
	{
		char uri[1280];
		lsp_tok_str(json, &toks[uri_tok], uri, sizeof(uri));
		lsp_path_from_uri(uri, path, sizeof(path));
	}
	diags_tok = lsp_find_key(json, toks, n, params, \"diagnostics\");
	if (diags_tok < 0 || toks[diags_tok].type != JSMN_ARRAY)
		return;
	df = lsp_diagfile_for_path(path);
	if (!df)
		return;
	df->n = 0;
	/* iterate diagnostics array */
	i = diags_tok + 1;
	for (di = 0; di < toks[diags_tok].size && i < n; di++) {
		if (toks[i].type != JSMN_OBJECT) {
			i = lsp_skip(toks, n, i);
			continue;
		}
		int diag_obj = i;
		int range_tok = lsp_find_key(json, toks, n, diag_obj, \"range\");
		int sev_tok = lsp_find_key(json, toks, n, diag_obj, \"severity\");
		int msg_tok = lsp_find_key(json, toks, n, diag_obj, \"message\");
		int line = 0, col = 0, sev = 1;
		if (range_tok >= 0) {
			int start_tok = lsp_find_key(json, toks, n, range_tok, \"start\");
			if (start_tok >= 0) {
				int lt = lsp_find_key(json, toks, n, start_tok, \"line\");
				int ct = lsp_find_key(json, toks, n, start_tok, \"character\");
				if (lt >= 0)
					line = lsp_tok_int(json, &toks[lt]);
				if (ct >= 0)
					col = lsp_tok_int(json, &toks[ct]);
			}
		}
		if (sev_tok >= 0)
			sev = lsp_tok_int(json, &toks[sev_tok]);
		if (df->n >= df->cap) {
			df->cap = df->cap ? df->cap * 2 : 8;
			if (df->cap > LSP_DIAG_MAX)
				df->cap = LSP_DIAG_MAX;
			df->d = erealloc(df->d, df->cap * sizeof(lsp_diag));
		}
		if (df->n < LSP_DIAG_MAX) {
			df->d[df->n].line = line;
			df->d[df->n].col = col;
			df->d[df->n].severity = sev;
			if (msg_tok >= 0)
				lsp_tok_str(json, &toks[msg_tok],
					df->d[df->n].msg, sizeof(df->d[0].msg));
			else
				df->d[df->n].msg[0] = '\\\\0';
			df->n++;
		}
		i = lsp_skip(toks, n, diag_obj);
	}
	(void)srv;
}

static void lsp_handle_notification(lsp_server *srv, const char *json,
		jsmntok_t *toks, int n, const char *method)
{
	if (!strcmp(method, \"textDocument/publishDiagnostics\"))
		lsp_handle_diagnostics(srv, json, toks, n);
}

static void lsp_handle_response(lsp_server *srv, const char *json,
		jsmntok_t *toks, int n, int id)
{
	if (srv->pending_id == id) {
		free(srv->response_json);
		srv->response_json = malloc(n * sizeof(jsmntok_t) + strlen(json) + 1);
		if (srv->response_json) {
			strcpy(srv->response_json, json);
			srv->response_len = n;
		}
		srv->response_ready = 1;
		srv->pending_id = 0;
	}
}

static void lsp_handle_message(lsp_server *srv, char *json, int len)
{
	jsmn_parser p;
	jsmntok_t toks[512];
	int n;
	char method[128] = \"\";
	int id = -1;

	jsmn_init(&p);
	n = jsmn_parse(&p, json, len, toks, 512);
	if (n < 1 || toks[0].type != JSMN_OBJECT)
		return;

	/* extract method */
	int mtok = lsp_find_key(json, toks, n, 0, \"method\");
	if (mtok >= 0 && toks[mtok].type == JSMN_STRING)
		lsp_tok_str(json, &toks[mtok], method, sizeof(method));

	/* extract id */
	int itok = lsp_find_key(json, toks, n, 0, \"id\");
	if (itok >= 0)
		id = lsp_tok_int(json, &toks[itok]);

	/* check if initialized response */
	if (id >= 0 && !method[0]) {
		if (!srv->initialized && id == 1) {
			/* this is the initialize response */
			sbuf_smake(sb2, 128)
			lsp_fmt_initialized(sb2);
			lsp_send_sb(srv, sb2);
			free(sb2->s);
			srv->initialized = 1;
			/* send didOpen if we have a file queued */
			if (srv->open_path[0] && ex_buf && ex_buf->lb) {
				sbuf_smake(sb3, 4096)
				lsp_fmt_didopen(srv, sb3, srv->open_path,
					srv->ft, ex_buf->lb);
				lsp_send_sb(srv, sb3);
				free(sb3->s);
			}
		}
		lsp_handle_response(srv, json, toks, n, id);
	} else if (method[0]) {
		lsp_handle_notification(srv, json, toks, n, method);
	}
}

static void lsp_dispatch_messages(lsp_server *srv)
{
	while (1) {
		/* find \\\\r\\\\n\\\\r\\\\n */
		char *hdr_end = NULL;
		int i;
		for (i = 0; i + 3 < srv->rbuf_n; i++) {
			if (srv->rbuf[i] == '\\\\r' && srv->rbuf[i+1] == '\\\\n' &&
					srv->rbuf[i+2] == '\\\\r' && srv->rbuf[i+3] == '\\\\n') {
				hdr_end = srv->rbuf + i + 4;
				break;
			}
		}
		if (!hdr_end)
			break;

		/* parse Content-Length */
		int clen = 0;
		char *cl = strstr(srv->rbuf, \"Content-Length:\");
		if (!cl || cl >= hdr_end)
			break;
		cl += 15;
		while (*cl == ' ')
			cl++;
		clen = atoi(cl);
		if (clen <= 0)
			break;

		int hdr_len = hdr_end - srv->rbuf;
		int total = hdr_len + clen;
		if (srv->rbuf_n < total)
			break; /* wait for more data */

		/* process message */
		hdr_end[clen] = '\\\\0';
		lsp_handle_message(srv, hdr_end, clen);

		/* shift buffer */
		srv->rbuf_n -= total;
		memmove(srv->rbuf, srv->rbuf + total, srv->rbuf_n);
	}
}

static void _lsp_process_fd(int fd)
{
	lsp_server *srv = lsp_find_srv_for_fd(fd);
	if (!srv)
		return;
	int space = LSP_RBUF_MAX - srv->rbuf_n - 1;
	if (space <= 0)
		return;
	int r = read(fd, srv->rbuf + srv->rbuf_n, space);
	if (r > 0) {
		srv->rbuf_n += r;
		lsp_dispatch_messages(srv);
	}
}

static int lsp_wait_response(lsp_server *srv, int id, int ms)
{
	int elapsed = 0;
	srv->pending_id = id;
	srv->response_ready = 0;
	while (elapsed < ms) {
		struct pollfd pfd;
		pfd.fd = srv->out_fd;
		pfd.events = POLLIN;
		int r = poll(&pfd, 1, 10);
		if (r > 0 && (pfd.revents & POLLIN))
			_lsp_process_fd(srv->out_fd);
		if (srv->response_ready)
			return 1;
		elapsed += 10;
	}
	srv->pending_id = 0;
	return 0;
}

static int lsp_srv_ensure(lsp_server *srv)
{
	if (srv->pid > 0)
		return 1;
	char *argv[] = {\"/bin/sh\", \"-c\", srv->cmd, NULL};
	srv->pid = cmd_make(argv, &srv->in_fd, &srv->out_fd);
	if (srv->pid <= 0) {
		srv->pid = -1;
		return 0;
	}
	fcntl(srv->out_fd, F_SETFL,
		fcntl(srv->out_fd, F_GETFL, 0) | O_NONBLOCK);
	/* register fd */
	if (lsp_nfds < LSP_NFDS_MAX)
		lsp_fds[lsp_nfds++] = srv->out_fd;
	srv->rbuf_n = 0;
	srv->initialized = 0;
	srv->next_id = 0;
	srv->response_ready = 0;
	srv->pending_id = 0;
	free(srv->response_json);
	srv->response_json = NULL;
	/* send initialize */
	sbuf_smake(sb, 512)
	int id = lsp_fmt_init(srv, sb);
	lsp_send_sb(srv, sb);
	free(sb->s);
	/* wait for initialized response */
	lsp_wait_response(srv, id, 5000);
	return srv->initialized;
}

void lsp_open(const char *path, const char *ft)
{
	lsp_server *srv = lsp_srv_for_ft(ft);
	if (!srv)
		return;
	/* check if already open */
	if (!strcmp(srv->open_path, path) && srv->pid > 0) {
		/* send didChange */
		if (ex_buf && ex_buf->lb) {
			sbuf_smake(sb, 4096)
			lsp_fmt_didchange(srv, sb, path, ex_buf->lb);
			lsp_send_sb(srv, sb);
			free(sb->s);
		}
		return;
	}
	snprintf(srv->open_path, sizeof(srv->open_path), \"%s\", path);
	srv->open_version = 1;
	if (!lsp_srv_ensure(srv))
		return;
	if (!srv->initialized)
		return;
	if (ex_buf && ex_buf->lb) {
		sbuf_smake(sb, 4096)
		lsp_fmt_didopen(srv, sb, path, ft, ex_buf->lb);
		lsp_send_sb(srv, sb);
		free(sb->s);
	}
}

void lsp_save(const char *path)
{
	int i;
	for (i = 0; i < lsp_nsrvs; i++) {
		lsp_server *srv = &lsp_srvs[i];
		if (srv->pid > 0 && !strcmp(srv->open_path, path)) {
			sbuf_smake(sb, 256)
			lsp_fmt_didsave(sb, path);
			lsp_send_sb(srv, sb);
			free(sb->s);
		}
	}
}

/* compute byte offset for row,off in lbuf (UTF-8 byte position in line) */
static int lsp_byte_offset(struct lbuf *lb, int row, int off)
{
	if (row < 0 || row >= lbuf_len(lb))
		return 0;
	char *ln = lbuf_get(lb, row);
	if (!ln)
		return 0;
	/* off is a visual column index; uc_off converts it to byte offset */
	return uc_off(ln, off);
}

void lsp_hover(const char *path, int row, int off)
{
	lsp_server *srv = NULL;
	int i;
	/* find server for this file */
	for (i = 0; i < lsp_nsrvs; i++)
		if (lsp_srvs[i].pid > 0 && !strcmp(lsp_srvs[i].open_path, path)) {
			srv = &lsp_srvs[i];
			break;
		}
	if (!srv) {
		lsp_show_msg(\"lsp: no server for file\");
		return;
	}
	int col = lsp_byte_offset(ex_buf ? ex_buf->lb : NULL, row, off);
	sbuf_smake(sb, 256)
	int id = lsp_fmt_hover(srv, sb, path, row, col);
	lsp_send_sb(srv, sb);
	free(sb->s);
	if (!lsp_wait_response(srv, id, 2000)) {
		lsp_show_msg(\"lsp: hover timeout\");
		return;
	}
	/* parse response */
	if (!srv->response_json) {
		lsp_show_msg(\"lsp: no hover result\");
		return;
	}
	char *json = srv->response_json;
	jsmn_parser p;
	jsmntok_t toks[256];
	jsmn_init(&p);
	int n = jsmn_parse(&p, json, strlen(json), toks, 256);
	if (n < 1) {
		lsp_show_msg(\"lsp: hover parse error\");
		return;
	}
	int result = lsp_find_key(json, toks, n, 0, \"result\");
	if (result < 0 || toks[result].type == JSMN_PRIMITIVE) {
		lsp_show_msg(\"lsp: no hover result\");
		return;
	}
	/* result.contents */
	int contents = lsp_find_key(json, toks, n, result, \"contents\");
	if (contents < 0) {
		lsp_show_msg(\"lsp: no hover contents\");
		return;
	}
	char msg[512] = \"\";
	if (toks[contents].type == JSMN_STRING) {
		lsp_tok_str(json, &toks[contents], msg, sizeof(msg));
	} else if (toks[contents].type == JSMN_OBJECT) {
		int val = lsp_find_key(json, toks, n, contents, \"value\");
		if (val >= 0)
			lsp_tok_str(json, &toks[val], msg, sizeof(msg));
	} else if (toks[contents].type == JSMN_ARRAY && toks[contents].size > 0) {
		int first = contents + 1;
		if (toks[first].type == JSMN_STRING) {
			lsp_tok_str(json, &toks[first], msg, sizeof(msg));
		} else if (toks[first].type == JSMN_OBJECT) {
			int val = lsp_find_key(json, toks, n, first, \"value\");
			if (val >= 0)
				lsp_tok_str(json, &toks[val], msg, sizeof(msg));
		}
	}
	if (msg[0])
		lsp_show_msg(msg);
	else
		lsp_show_msg(\"lsp: empty hover\");
}

void lsp_definition(const char *path, int row, int off)
{
	lsp_server *srv = NULL;
	int i;
	for (i = 0; i < lsp_nsrvs; i++)
		if (lsp_srvs[i].pid > 0 && !strcmp(lsp_srvs[i].open_path, path)) {
			srv = &lsp_srvs[i];
			break;
		}
	if (!srv) {
		lsp_show_msg(\"lsp: no server for file\");
		return;
	}
	int col = lsp_byte_offset(ex_buf ? ex_buf->lb : NULL, row, off);
	sbuf_smake(sb, 256)
	int id = lsp_fmt_definition(srv, sb, path, row, col);
	lsp_send_sb(srv, sb);
	free(sb->s);
	if (!lsp_wait_response(srv, id, 2000)) {
		lsp_show_msg(\"lsp: definition timeout\");
		return;
	}
	if (!srv->response_json) {
		lsp_show_msg(\"lsp: no definition result\");
		return;
	}
	char *json = srv->response_json;
	jsmn_parser p;
	jsmntok_t toks[256];
	jsmn_init(&p);
	int n = jsmn_parse(&p, json, strlen(json), toks, 256);
	if (n < 1) {
		lsp_show_msg(\"lsp: definition parse error\");
		return;
	}
	int result = lsp_find_key(json, toks, n, 0, \"result\");
	if (result < 0 || toks[result].type == JSMN_PRIMITIVE) {
		lsp_show_msg(\"lsp: no definition result\");
		return;
	}
	char uri[1280] = \"\";
	int target_line = 0;
	/* result can be object (Location), array of Location/LocationLink */
	int obj = result;
	if (toks[result].type == JSMN_ARRAY) {
		if (toks[result].size == 0) {
			lsp_show_msg(\"lsp: definition not found\");
			return;
		}
		obj = result + 1;
	}
	if (toks[obj].type == JSMN_OBJECT) {
		/* try Location: uri + range */
		int uri_tok = lsp_find_key(json, toks, n, obj, \"uri\");
		if (uri_tok < 0) /* try LocationLink: targetUri + targetRange */
			uri_tok = lsp_find_key(json, toks, n, obj, \"targetUri\");
		if (uri_tok >= 0)
			lsp_tok_str(json, &toks[uri_tok], uri, sizeof(uri));
		int range_tok = lsp_find_key(json, toks, n, obj, \"range\");
		if (range_tok < 0)
			range_tok = lsp_find_key(json, toks, n, obj, \"targetRange\");
		if (range_tok >= 0) {
			int start = lsp_find_key(json, toks, n, range_tok, \"start\");
			if (start >= 0) {
				int lt = lsp_find_key(json, toks, n, start, \"line\");
				if (lt >= 0)
					target_line = lsp_tok_int(json, &toks[lt]);
			}
		}
	}
	if (!uri[0]) {
		lsp_show_msg(\"lsp: definition not found\");
		return;
	}
	char fpath[1024];
	lsp_path_from_uri(uri, fpath, sizeof(fpath));
	/* navigate: open file and go to line */
	if (strcmp(fpath, path)) {
		ex_edit(fpath, strlen(fpath));
	}
	xrow = target_line;
	if (xrow >= lbuf_len(xb))
		xrow = lbuf_len(xb) - 1;
	if (xrow < 0)
		xrow = 0;
	xoff = 0;
	xtop = xrow > xrows / 2 ? xrow - xrows / 2 : 0;
}

const char *lsp_diag_for_line(const char *path, int line)
{
	int i, j;
	for (i = 0; i < lsp_ndiagfiles; i++) {
		if (!strcmp(lsp_diagfiles[i].path, path)) {
			for (j = 0; j < lsp_diagfiles[i].n; j++)
				if (lsp_diagfiles[i].d[j].line == line)
					return lsp_diagfiles[i].d[j].msg;
			return NULL;
		}
	}
	return NULL;
}
.
${SEP}vis 2${SEP}wq" $VI -e 'lsp.c'

# Patch: term.c
SEP="$(printf '\x01')"
QF=${QF-"$(printf 'vis 2\\\x01q! 1')"}
EXINIT="rcm:|sc! \\\\${SEP}|vis 3${SEP}%;f> 
int term_read\\\\(int winch\\\\)
\\\\{${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 152\\${SEP}${QF}}${SEP};=
${SEP}+3d${SEP}.,\$;f> 			goto ret;
		\\\\}
		cw = 0;${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 165\\${SEP}${QF}}${SEP};=
${SEP}+3,#+9c 		re:;
		{
			struct pollfd pfds[1 + LSP_NFDS_MAX];
			int _nr, _i;
			pfds[0].fd = STDIN_FILENO;
			pfds[0].events = POLLIN;
			for (_i = 0; _i < lsp_nfds; _i++) {
				pfds[1+_i].fd = lsp_fds[_i];
				pfds[1+_i].events = POLLIN;
			}
			if (xquit < 0 || (_nr = poll(pfds, 1+lsp_nfds, -1)) <= 0) {
				xquit = !isatty(STDIN_FILENO) ? -1 : xquit;
				if (term_winch && winch && xquit >= 0) {
					*ibuf = winch;
					goto ret;
				} else if (term_winch != cw && !winch && xquit >= 0) {
					cw = term_winch;
					goto re;
				}
				goto err;
			}
			if (lsp_fd_ready)
				for (_i = 0; _i < lsp_nfds; _i++)
					if (pfds[1+_i].revents & POLLIN)
						lsp_fd_ready(lsp_fds[_i]);
			if (!(pfds[0].revents & POLLIN)) {
				if (term_winch && winch) {
					*ibuf = winch;
					goto ret;
				}
.
${SEP}.,\$;f> 				goto re;
			\\\\}${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 177\\${SEP}${QF}}${SEP};=
${SEP}+2,#+1c 			if (read(STDIN_FILENO, ibuf, 1) <= 0) {
				xquit = !isatty(STDIN_FILENO) ? -1 : xquit;
				if (term_winch && winch && xquit >= 0) {
					*ibuf = winch;
					goto ret;
				} else if (term_winch != cw && !winch && xquit >= 0) {
					cw = term_winch;
					goto re;
				}
				goto err;
			}
			goto ret;
.
${SEP}.,\$f> 		\\\\}${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 179\\${SEP}${QF}}${SEP};=
${SEP}.a 		err:
		*ibuf = 0;
.
${SEP}vis 2${SEP}wq" $VI -e 'term.c'

# Patch: vi.c
SEP="$(printf '\x01')"
QF=${QF-"$(printf 'vis 2\\\x01q! 1')"}
EXINIT="rcm:|sc! \\\\${SEP}|vis 3${SEP}%;f> #include \"ren\\\\.c\"
#include \"term\\\\.c\"
#include \"uc\\\\.c\"${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 24\\${SEP}${QF}}${SEP};=
${SEP}+2a #include \"lsp.c\"
.
${SEP}.,\$;f> \\\\}
#define vi_drawmsg_mpt\\\\(msg\\\\) \\\\{ vi_drawmsg\\\\(msg\\\\); if \\\\(!xmpt\\\\) xmpt = 1; \\\\}

${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 104\\${SEP}${QF}}${SEP};=
${SEP}+2a void lsp_show_msg(char *msg) { vi_drawmsg_mpt(msg) }

.
${SEP}.,\$;f> 				\\\\} else if \\\\(k == '~' \\\\|\\\\| k == 'u' \\\\|\\\\| k == 'U'\\\\) \\\\{
					vc_motion\\\\(k\\\\);
					goto rep;${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 1615\\${SEP}${QF}}${SEP};=
${SEP}+2a 				} else if (k == 'K') {
					if (xb_path && xb_path[0])
						lsp_hover(xb_path, xrow, xoff);
				} else if (k == 'd') {
					if (xb_path && xb_path[0])
						lsp_definition(xb_path, xrow, xoff);
.
${SEP}.,\$;f> 			syn_blockhl = -1;
			vi_drawrow\\\\(xrow\\\\);
		\\\\}${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 1782\\${SEP}${QF}}${SEP};=
${SEP}+2a 		if (!xmpt && xb_path && xb_path[0]) {
			const char *_ldiag = lsp_diag_for_line(xb_path, xrow);
			if (_ldiag)
				vi_drawmsg((char *)_ldiag);
		}
.
${SEP}.,\$;f> 	setup_signals\\\\(\\\\);
	dir_init\\\\(\\\\);
	syn_init\\\\(\\\\);${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 1815\\${SEP}${QF}}${SEP};=
${SEP}+2a 	lsp_init();
.
${SEP}vis 2${SEP}wq" $VI -e 'vi.c'

# Patch: vi.h
SEP="$(printf '\x01')"
QF=${QF-"$(printf 'vis 2\\\x01q! 1')"}
EXINIT="rcm:|sc! \\\\${SEP}|vis 3${SEP}%;f> extern rset \\\\*fsincl;
void dir_calc\\\\(char \\\\*path\\\\);${SEP}??!${DBG:--5,+5p\\${SEP}p FAIL line 548\\${SEP}${QF}}${SEP};=
${SEP}+1a 
/* lsp.c */
#define LSP_NFDS_MAX	8
extern int lsp_nfds;
extern int lsp_fds[LSP_NFDS_MAX];
extern void (*lsp_fd_ready)(int fd);
void lsp_init(void);
void lsp_register(const char *ft, const char *cmd);
void lsp_open(const char *path, const char *ft);
void lsp_save(const char *path);
void lsp_hover(const char *path, int row, int off);
void lsp_definition(const char *path, int row, int off);
const char *lsp_diag_for_line(const char *path, int line);
void lsp_list(void);
void lsp_show_msg(char *msg);
.
${SEP}vis 2${SEP}wq" $VI -e 'vi.h'

exit 0
=== PATCH2VI DELTA ===
=== DELTA vi.h ===
--- /tmp/patch2vi_eeFnkE_vi.h.diff.orig
+++ /tmp/patch2vi_eeFnkE_vi.h.diff
@@ -18,9 +18,8 @@
 #abs
 === SEARCH COMMAND ===
 %;f>
-=== SEARCH PATTERN (offset: 3) ===
+=== SEARCH PATTERN (offset: 2) ===
 extern rset \*fsincl;
-extern char \*fs_exdir;
 void dir_calc\(char \*path\);
 === END GROUP ===
 
=== PATCH2VI PATCH ===
diff --git a/ex.c b/ex.c
index 81878d89..c51a3f7e 100644
--- a/ex.c
+++ b/ex.c
@@ -372,6 +372,8 @@ static void *ec_edit(char *loc, char *cmd, char *arg)
 	if (cd == 3 || (!rd && fd >= 0)) {
 		ex_bufpostfix(ex_buf, arg[0]);
 		syn_setft(xb_ft);
+		if (*xb_path && xb_ft)
+			lsp_open(xb_path, xb_ft);
 	}
 	snprintf(msg, sizeof(msg), "\"%s\" %dL [%c]",
 			*xb_path ? xb_path : "unnamed", lbuf_len(xb),
@@ -709,6 +711,8 @@ static void *ec_write(char *loc, char *cmd, char *arg)
 			ec_setpath(NULL, NULL, path);
 		lbuf_saved(xb, 0);
 		ex_buf->mtime = mtime(path);
+		if (*xb_path)
+			lsp_save(xb_path);
 	}
 	if (cmd[0] == 'x' || (cmd[0] == 'w' && cmd[1] == 'q'))
 		ec_quit("", cmd, "");
@@ -1391,6 +1395,23 @@ _EO(left,
 	return NULL;
 )
 
+static void *ec_lsp(char *loc, char *cmd, char *arg)
+{
+	char ft[32];
+	int n = 0;
+	if (!*arg) { lsp_list(); return NULL; }
+	while (arg[n] && arg[n] != ' ' && n < (int)sizeof(ft)-1) {
+		ft[n] = arg[n];
+		n++;
+	}
+	ft[n] = '\0';
+	while (arg[n] == ' ') n++;
+	if (!arg[n]) return "lsp: missing server command";
+	lsp_register(ft, arg+n);
+	return NULL;
+	(void)loc; (void)cmd;
+}
+
 #undef EO
 #define EO(opt) {#opt, eo_##opt}
 
@@ -1478,6 +1499,7 @@ static struct excmd {
 	EO(hlp),
 	EO(hlr),
 	EO(hl),
+	{"lsp", ec_lsp},
 	EO(left),
 	EO(lim),
 	EO(led),
diff --git a/jsmn.h b/jsmn.h
new file mode 100644
index 00000000..8ac14c1b
--- /dev/null
+++ b/jsmn.h
@@ -0,0 +1,471 @@
+/*
+ * MIT License
+ *
+ * Copyright (c) 2010 Serge Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef JSMN_H
+#define JSMN_H
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef JSMN_STATIC
+#define JSMN_API static
+#else
+#define JSMN_API extern
+#endif
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ * 	o String
+ * 	o Other primitive: number, boolean (true/false) or null
+ */
+typedef enum {
+  JSMN_UNDEFINED = 0,
+  JSMN_OBJECT = 1 << 0,
+  JSMN_ARRAY = 1 << 1,
+  JSMN_STRING = 1 << 2,
+  JSMN_PRIMITIVE = 1 << 3
+} jsmntype_t;
+
+enum jsmnerr {
+  /* Not enough tokens were provided */
+  JSMN_ERROR_NOMEM = -1,
+  /* Invalid character inside JSON string */
+  JSMN_ERROR_INVAL = -2,
+  /* The string is not a full JSON packet, more bytes expected */
+  JSMN_ERROR_PART = -3
+};
+
+/**
+ * JSON token description.
+ * type		type (object, array, string etc.)
+ * start	start position in JSON data string
+ * end		end position in JSON data string
+ */
+typedef struct jsmntok {
+  jsmntype_t type;
+  int start;
+  int end;
+  int size;
+#ifdef JSMN_PARENT_LINKS
+  int parent;
+#endif
+} jsmntok_t;
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string.
+ */
+typedef struct jsmn_parser {
+  unsigned int pos;     /* offset in the JSON string */
+  unsigned int toknext; /* next token to allocate */
+  int toksuper;         /* superior token node, e.g. parent object or array */
+} jsmn_parser;
+
+/**
+ * Create JSON parser over an array of tokens
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser);
+
+/**
+ * Run JSON parser. It parses a JSON data string into and array of tokens, each
+ * describing
+ * a single JSON object.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens);
+
+#ifndef JSMN_HEADER
+/**
+ * Allocates a fresh unused token from the token pool.
+ */
+static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
+                                   const size_t num_tokens) {
+  jsmntok_t *tok;
+  if (parser->toknext >= num_tokens) {
+    return NULL;
+  }
+  tok = &tokens[parser->toknext++];
+  tok->start = tok->end = -1;
+  tok->size = 0;
+#ifdef JSMN_PARENT_LINKS
+  tok->parent = -1;
+#endif
+  return tok;
+}
+
+/**
+ * Fills token type and boundaries.
+ */
+static void jsmn_fill_token(jsmntok_t *token, const jsmntype_t type,
+                            const int start, const int end) {
+  token->type = type;
+  token->start = start;
+  token->end = end;
+  token->size = 0;
+}
+
+/**
+ * Fills next available token with JSON primitive.
+ */
+static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
+                                const size_t len, jsmntok_t *tokens,
+                                const size_t num_tokens) {
+  jsmntok_t *token;
+  int start;
+
+  start = parser->pos;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    switch (js[parser->pos]) {
+#ifndef JSMN_STRICT
+    /* In strict mode primitive must be followed by "," or "}" or "]" */
+    case ':':
+#endif
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+    case ',':
+    case ']':
+    case '}':
+      goto found;
+    default:
+                   /* to quiet a warning from gcc*/
+      break;
+    }
+    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+      parser->pos = start;
+      return JSMN_ERROR_INVAL;
+    }
+  }
+#ifdef JSMN_STRICT
+  /* In strict mode primitive must be followed by a comma/object/array */
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+#endif
+
+found:
+  if (tokens == NULL) {
+    parser->pos--;
+    return 0;
+  }
+  token = jsmn_alloc_token(parser, tokens, num_tokens);
+  if (token == NULL) {
+    parser->pos = start;
+    return JSMN_ERROR_NOMEM;
+  }
+  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+  token->parent = parser->toksuper;
+#endif
+  parser->pos--;
+  return 0;
+}
+
+/**
+ * Fills next token with JSON string.
+ */
+static int jsmn_parse_string(jsmn_parser *parser, const char *js,
+                             const size_t len, jsmntok_t *tokens,
+                             const size_t num_tokens) {
+  jsmntok_t *token;
+
+  int start = parser->pos;
+  
+  /* Skip starting quote */
+  parser->pos++;
+  
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c = js[parser->pos];
+
+    /* Quote: end of string */
+    if (c == '\"') {
+      if (tokens == NULL) {
+        return 0;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        parser->pos = start;
+        return JSMN_ERROR_NOMEM;
+      }
+      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+      token->parent = parser->toksuper;
+#endif
+      return 0;
+    }
+
+    /* Backslash: Quoted symbol expected */
+    if (c == '\\' && parser->pos + 1 < len) {
+      int i;
+      parser->pos++;
+      switch (js[parser->pos]) {
+      /* Allowed escaped symbols */
+      case '\"':
+      case '/':
+      case '\\':
+      case 'b':
+      case 'f':
+      case 'r':
+      case 'n':
+      case 't':
+        break;
+      /* Allows escaped symbol \uXXXX */
+      case 'u':
+        parser->pos++;
+        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
+             i++) {
+          /* If it isn't a hex character we have an error */
+          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
+                (js[parser->pos] >= 65 && js[parser->pos] <= 70) ||   /* A-F */
+                (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
+            parser->pos = start;
+            return JSMN_ERROR_INVAL;
+          }
+          parser->pos++;
+        }
+        parser->pos--;
+        break;
+      /* Unexpected symbol */
+      default:
+        parser->pos = start;
+        return JSMN_ERROR_INVAL;
+      }
+    }
+  }
+  parser->pos = start;
+  return JSMN_ERROR_PART;
+}
+
+/**
+ * Parse JSON string and fill tokens.
+ */
+JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
+                        jsmntok_t *tokens, const unsigned int num_tokens) {
+  int r;
+  int i;
+  jsmntok_t *token;
+  int count = parser->toknext;
+
+  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+    char c;
+    jsmntype_t type;
+
+    c = js[parser->pos];
+    switch (c) {
+    case '{':
+    case '[':
+      count++;
+      if (tokens == NULL) {
+        break;
+      }
+      token = jsmn_alloc_token(parser, tokens, num_tokens);
+      if (token == NULL) {
+        return JSMN_ERROR_NOMEM;
+      }
+      if (parser->toksuper != -1) {
+        jsmntok_t *t = &tokens[parser->toksuper];
+#ifdef JSMN_STRICT
+        /* In strict mode an object or array can't become a key */
+        if (t->type == JSMN_OBJECT) {
+          return JSMN_ERROR_INVAL;
+        }
+#endif
+        t->size++;
+#ifdef JSMN_PARENT_LINKS
+        token->parent = parser->toksuper;
+#endif
+      }
+      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+      token->start = parser->pos;
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case '}':
+    case ']':
+      if (tokens == NULL) {
+        break;
+      }
+      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+#ifdef JSMN_PARENT_LINKS
+      if (parser->toknext < 1) {
+        return JSMN_ERROR_INVAL;
+      }
+      token = &tokens[parser->toknext - 1];
+      for (;;) {
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          token->end = parser->pos + 1;
+          parser->toksuper = token->parent;
+          break;
+        }
+        if (token->parent == -1) {
+          if (token->type != type || parser->toksuper == -1) {
+            return JSMN_ERROR_INVAL;
+          }
+          break;
+        }
+        token = &tokens[token->parent];
+      }
+#else
+      for (i = parser->toknext - 1; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          if (token->type != type) {
+            return JSMN_ERROR_INVAL;
+          }
+          parser->toksuper = -1;
+          token->end = parser->pos + 1;
+          break;
+        }
+      }
+      /* Error if unmatched closing bracket */
+      if (i == -1) {
+        return JSMN_ERROR_INVAL;
+      }
+      for (; i >= 0; i--) {
+        token = &tokens[i];
+        if (token->start != -1 && token->end == -1) {
+          parser->toksuper = i;
+          break;
+        }
+      }
+#endif
+      break;
+    case '\"':
+      r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+    case '\t':
+    case '\r':
+    case '\n':
+    case ' ':
+      break;
+    case ':':
+      parser->toksuper = parser->toknext - 1;
+      break;
+    case ',':
+      if (tokens != NULL && parser->toksuper != -1 &&
+          tokens[parser->toksuper].type != JSMN_ARRAY &&
+          tokens[parser->toksuper].type != JSMN_OBJECT) {
+#ifdef JSMN_PARENT_LINKS
+        parser->toksuper = tokens[parser->toksuper].parent;
+#else
+        for (i = parser->toknext - 1; i >= 0; i--) {
+          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
+            if (tokens[i].start != -1 && tokens[i].end == -1) {
+              parser->toksuper = i;
+              break;
+            }
+          }
+        }
+#endif
+      }
+      break;
+#ifdef JSMN_STRICT
+    /* In strict mode primitives are: numbers and booleans */
+    case '-':
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
+    case 't':
+    case 'f':
+    case 'n':
+      /* And they must not be keys of the object */
+      if (tokens != NULL && parser->toksuper != -1) {
+        const jsmntok_t *t = &tokens[parser->toksuper];
+        if (t->type == JSMN_OBJECT ||
+            (t->type == JSMN_STRING && t->size != 0)) {
+          return JSMN_ERROR_INVAL;
+        }
+      }
+#else
+    /* In non-strict mode every unquoted value is a primitive */
+    default:
+#endif
+      r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
+      if (r < 0) {
+        return r;
+      }
+      count++;
+      if (parser->toksuper != -1 && tokens != NULL) {
+        tokens[parser->toksuper].size++;
+      }
+      break;
+
+#ifdef JSMN_STRICT
+    /* Unexpected char in strict mode */
+    default:
+      return JSMN_ERROR_INVAL;
+#endif
+    }
+  }
+
+  if (tokens != NULL) {
+    for (i = parser->toknext - 1; i >= 0; i--) {
+      /* Unmatched opened object or array */
+      if (tokens[i].start != -1 && tokens[i].end == -1) {
+        return JSMN_ERROR_PART;
+      }
+    }
+  }
+
+  return count;
+}
+
+/**
+ * Creates a new parser based over a given buffer with an array of tokens
+ * available.
+ */
+JSMN_API void jsmn_init(jsmn_parser *parser) {
+  parser->pos = 0;
+  parser->toknext = 0;
+  parser->toksuper = -1;
+}
+
+#endif /* JSMN_HEADER */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* JSMN_H */
diff --git a/lsp.c b/lsp.c
new file mode 100644
index 00000000..42a6a183
--- /dev/null
+++ b/lsp.c
@@ -0,0 +1,831 @@
+/* lsp.c - Language Server Protocol client for nextvi */
+#include "jsmn.h"
+#include <errno.h>
+
+#define LSP_DIAG_MAX	64
+#define LSP_SRV_MAX	8
+#define LSP_RBUF_MAX	65536
+
+typedef struct {
+	int line, col, severity;
+	char msg[256];
+} lsp_diag;
+
+typedef struct {
+	char path[1024];
+	lsp_diag *d;
+	int n, cap;
+} lsp_diagfile;
+
+typedef struct {
+	char ft[32], cmd[256];
+	int pid, in_fd, out_fd;
+	char rbuf[LSP_RBUF_MAX];
+	int rbuf_n;
+	int response_ready, pending_id;
+	char *response_json;
+	int response_len;
+	int initialized, next_id;
+	char open_path[1024];
+	int open_version;
+} lsp_server;
+
+int lsp_nfds = 0;
+int lsp_fds[LSP_NFDS_MAX];
+void (*lsp_fd_ready)(int fd) = NULL;
+
+static lsp_server lsp_srvs[LSP_SRV_MAX];
+static int lsp_nsrvs = 0;
+static lsp_diagfile lsp_diagfiles[LSP_SRV_MAX * 4];
+static int lsp_ndiagfiles = 0;
+
+/* forward declarations */
+static void _lsp_process_fd(int fd);
+static lsp_server *lsp_find_srv_for_fd(int fd);
+static void lsp_dispatch_messages(lsp_server *srv);
+static void lsp_handle_message(lsp_server *srv, char *json, int len);
+
+void lsp_init(void)
+{
+	lsp_fd_ready = _lsp_process_fd;
+}
+
+void lsp_register(const char *ft, const char *cmd)
+{
+	int i;
+	for (i = 0; i < lsp_nsrvs; i++) {
+		if (!strcmp(lsp_srvs[i].ft, ft)) {
+			snprintf(lsp_srvs[i].cmd, sizeof(lsp_srvs[i].cmd), "%s", cmd);
+			return;
+		}
+	}
+	if (lsp_nsrvs >= LSP_SRV_MAX)
+		return;
+	snprintf(lsp_srvs[lsp_nsrvs].ft, sizeof(lsp_srvs[0].ft), "%s", ft);
+	snprintf(lsp_srvs[lsp_nsrvs].cmd, sizeof(lsp_srvs[0].cmd), "%s", cmd);
+	lsp_srvs[lsp_nsrvs].pid = -1;
+	lsp_srvs[lsp_nsrvs].in_fd = -1;
+	lsp_srvs[lsp_nsrvs].out_fd = -1;
+	lsp_nsrvs++;
+}
+
+void lsp_list(void)
+{
+	int i;
+	char buf[512];
+	for (i = 0; i < lsp_nsrvs; i++) {
+		snprintf(buf, sizeof(buf), "lsp %s %s [%s]",
+			lsp_srvs[i].ft, lsp_srvs[i].cmd,
+			lsp_srvs[i].pid > 0 ? "running" : "stopped");
+		ex_print(buf, bar_ft)
+	}
+	if (!lsp_nsrvs)
+		ex_print("lsp: no servers registered", bar_ft)
+}
+
+static lsp_server *lsp_srv_for_ft(const char *ft)
+{
+	int i;
+	for (i = 0; i < lsp_nsrvs; i++)
+		if (!strcmp(lsp_srvs[i].ft, ft))
+			return &lsp_srvs[i];
+	return NULL;
+}
+
+static lsp_diagfile *lsp_diagfile_for_path(const char *path)
+{
+	int i;
+	for (i = 0; i < lsp_ndiagfiles; i++)
+		if (!strcmp(lsp_diagfiles[i].path, path))
+			return &lsp_diagfiles[i];
+	if (lsp_ndiagfiles >= LSP_SRV_MAX * 4)
+		return NULL;
+	snprintf(lsp_diagfiles[lsp_ndiagfiles].path,
+		sizeof(lsp_diagfiles[0].path), "%s", path);
+	lsp_diagfiles[lsp_ndiagfiles].d = NULL;
+	lsp_diagfiles[lsp_ndiagfiles].n = 0;
+	lsp_diagfiles[lsp_ndiagfiles].cap = 0;
+	return &lsp_diagfiles[lsp_ndiagfiles++];
+}
+
+static lsp_server *lsp_find_srv_for_fd(int fd)
+{
+	int i;
+	for (i = 0; i < lsp_nsrvs; i++)
+		if (lsp_srvs[i].out_fd == fd)
+			return &lsp_srvs[i];
+	return NULL;
+}
+
+static void lsp_json_escape(const char *src, sbuf *sb)
+{
+	while (*src) {
+		if (*src == '"') {
+			sbuf_mem(sb, "\\\"", 2)
+		} else if (*src == '\\') {
+			sbuf_mem(sb, "\\\\", 2)
+		} else if (*src == '\n') {
+			sbuf_mem(sb, "\\n", 2)
+		} else if (*src == '\r') {
+			sbuf_mem(sb, "\\r", 2)
+		} else if (*src == '\t') {
+			sbuf_mem(sb, "\\t", 2)
+		} else {
+			sbuf_chr(sb, *src)
+		}
+		src++;
+	}
+}
+
+static void lsp_uri_from_path(const char *path, char *out, int n)
+{
+	snprintf(out, n, "file://%s", path);
+}
+
+static void lsp_path_from_uri(const char *uri, char *out, int n)
+{
+	if (!strncmp(uri, "file://", 7))
+		snprintf(out, n, "%s", uri + 7);
+	else
+		snprintf(out, n, "%s", uri);
+}
+
+static void lsp_send(lsp_server *srv, const char *json, int len)
+{
+	char hdr[64];
+	int hlen = snprintf(hdr, sizeof(hdr),
+		"Content-Length: %d\r\n\r\n", len);
+	write(srv->in_fd, hdr, hlen);
+	write(srv->in_fd, json, len);
+}
+
+static void lsp_send_sb(lsp_server *srv, sbuf *sb)
+{
+	sbuf_null(sb)
+	lsp_send(srv, sb->s, sb->s_n);
+}
+
+static void lsp_buf_content(struct lbuf *lb, sbuf *sb)
+{
+	int i;
+	for (i = 0; i < lbuf_len(lb); i++) {
+		char *ln = lbuf_get(lb, i);
+		lsp_json_escape(ln, sb);
+	}
+}
+
+static int lsp_fmt_init(lsp_server *srv, sbuf *sb)
+{
+	int id = ++srv->next_id;
+	char idstr[32];
+	itoa(id, idstr);
+	char pidstr[32];
+	itoa(getpid(), pidstr);
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"id\":")
+	sbuf_str(sb, idstr)
+	sbuf_str(sb, ",\"method\":\"initialize\",\"params\":{\"processId\":")
+	sbuf_str(sb, pidstr)
+	sbuf_str(sb, ",\"clientInfo\":{\"name\":\"nextvi\"},\"capabilities\":{")
+	sbuf_str(sb, "\"textDocument\":{\"synchronization\":{\"didSave\":true},")
+	sbuf_str(sb, "\"hover\":{\"contentFormat\":[\"plaintext\",\"markdown\"]},")
+	sbuf_str(sb, "\"definition\":{}},")
+	sbuf_str(sb, "\"general\":{\"positionEncodings\":[\"utf-8\"]}},")
+	sbuf_str(sb, "\"rootUri\":null}}")
+	return id;
+}
+
+static void lsp_fmt_initialized(sbuf *sb)
+{
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"method\":\"initialized\",\"params\":{}}")
+}
+
+static void lsp_fmt_didopen(lsp_server *srv, sbuf *sb, const char *path,
+		const char *ft, struct lbuf *lb)
+{
+	char uri[1280];
+	lsp_uri_from_path(path, uri, sizeof(uri));
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didOpen\",")
+	sbuf_str(sb, "\"params\":{\"textDocument\":{\"uri\":\"")
+	sbuf_str(sb, uri)
+	sbuf_str(sb, "\",\"languageId\":\"")
+	sbuf_str(sb, ft)
+	sbuf_str(sb, "\",\"version\":1,\"text\":\"")
+	lsp_buf_content(lb, sb);
+	sbuf_str(sb, "\"}}}")
+	(void)srv;
+}
+
+static void lsp_fmt_didchange(lsp_server *srv, sbuf *sb, const char *path,
+		struct lbuf *lb)
+{
+	char uri[1280];
+	char ver[32];
+	lsp_uri_from_path(path, uri, sizeof(uri));
+	itoa(++srv->open_version, ver);
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didChange\",")
+	sbuf_str(sb, "\"params\":{\"textDocument\":{\"uri\":\"")
+	sbuf_str(sb, uri)
+	sbuf_str(sb, "\",\"version\":")
+	sbuf_str(sb, ver)
+	sbuf_str(sb, "},\"contentChanges\":[{\"text\":\"")
+	lsp_buf_content(lb, sb);
+	sbuf_str(sb, "\"}]}}")
+}
+
+static void lsp_fmt_didsave(sbuf *sb, const char *path)
+{
+	char uri[1280];
+	lsp_uri_from_path(path, uri, sizeof(uri));
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didSave\",")
+	sbuf_str(sb, "\"params\":{\"textDocument\":{\"uri\":\"")
+	sbuf_str(sb, uri)
+	sbuf_str(sb, "\"}}}")
+}
+
+static int lsp_fmt_hover(lsp_server *srv, sbuf *sb, const char *path,
+		int line, int col)
+{
+	char uri[1280];
+	char idstr[32], linestr[32], colstr[32];
+	int id = ++srv->next_id;
+	lsp_uri_from_path(path, uri, sizeof(uri));
+	itoa(id, idstr);
+	itoa(line, linestr);
+	itoa(col, colstr);
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"id\":")
+	sbuf_str(sb, idstr)
+	sbuf_str(sb, ",\"method\":\"textDocument/hover\",\"params\":{\"textDocument\":{\"uri\":\"")
+	sbuf_str(sb, uri)
+	sbuf_str(sb, "\"},\"position\":{\"line\":")
+	sbuf_str(sb, linestr)
+	sbuf_str(sb, ",\"character\":")
+	sbuf_str(sb, colstr)
+	sbuf_str(sb, "}}}")
+	return id;
+}
+
+static int lsp_fmt_definition(lsp_server *srv, sbuf *sb, const char *path,
+		int line, int col)
+{
+	char uri[1280];
+	char idstr[32], linestr[32], colstr[32];
+	int id = ++srv->next_id;
+	lsp_uri_from_path(path, uri, sizeof(uri));
+	itoa(id, idstr);
+	itoa(line, linestr);
+	itoa(col, colstr);
+	sbuf_str(sb, "{\"jsonrpc\":\"2.0\",\"id\":")
+	sbuf_str(sb, idstr)
+	sbuf_str(sb, ",\"method\":\"textDocument/definition\",\"params\":{\"textDocument\":{\"uri\":\"")
+	sbuf_str(sb, uri)
+	sbuf_str(sb, "\"},\"position\":{\"line\":")
+	sbuf_str(sb, linestr)
+	sbuf_str(sb, ",\"character\":")
+	sbuf_str(sb, colstr)
+	sbuf_str(sb, "}}}")
+	return id;
+}
+
+/* jsmn helpers */
+
+static int lsp_tok_eq(const char *json, jsmntok_t *tok, const char *s)
+{
+	int len = tok->end - tok->start;
+	return tok->type == JSMN_STRING &&
+		(int)strlen(s) == len &&
+		!strncmp(json + tok->start, s, len);
+}
+
+static void lsp_tok_str(const char *json, jsmntok_t *tok, char *out, int n)
+{
+	int len = tok->end - tok->start;
+	if (len >= n)
+		len = n - 1;
+	memcpy(out, json + tok->start, len);
+	out[len] = '\0';
+}
+
+static int lsp_tok_int(const char *json, jsmntok_t *tok)
+{
+	char buf[32];
+	lsp_tok_str(json, tok, buf, sizeof(buf));
+	return atoi(buf);
+}
+
+/* skip token at index i and all its children; returns next index */
+static int lsp_skip(jsmntok_t *toks, int n, int i)
+{
+	int end, j;
+	if (i >= n)
+		return n;
+	if (toks[i].type == JSMN_OBJECT || toks[i].type == JSMN_ARRAY) {
+		end = i + 1;
+		for (j = 0; j < toks[i].size; j++) {
+			if (toks[i].type == JSMN_OBJECT)
+				end = lsp_skip(toks, n, end); /* key */
+			end = lsp_skip(toks, n, end); /* value */
+		}
+		return end;
+	}
+	return i + 1;
+}
+
+/* find value token index for key in object at toks[obj] */
+static int lsp_find_key(const char *json, jsmntok_t *toks, int n,
+		int obj, const char *key)
+{
+	int i, j;
+	if (obj >= n || toks[obj].type != JSMN_OBJECT)
+		return -1;
+	i = obj + 1;
+	for (j = 0; j < toks[obj].size; j++) {
+		if (i >= n)
+			break;
+		int val = i + 1;
+		if (lsp_tok_eq(json, &toks[i], key))
+			return val < n ? val : -1;
+		i = lsp_skip(toks, n, val);
+	}
+	return -1;
+}
+
+static void lsp_handle_diagnostics(lsp_server *srv, const char *json,
+		jsmntok_t *toks, int n)
+{
+	int params, uri_tok, diags_tok, i, di;
+	char path[1024];
+	lsp_diagfile *df;
+
+	params = lsp_find_key(json, toks, n, 0, "params");
+	if (params < 0)
+		return;
+	uri_tok = lsp_find_key(json, toks, n, params, "uri");
+	if (uri_tok < 0)
+		return;
+	{
+		char uri[1280];
+		lsp_tok_str(json, &toks[uri_tok], uri, sizeof(uri));
+		lsp_path_from_uri(uri, path, sizeof(path));
+	}
+	diags_tok = lsp_find_key(json, toks, n, params, "diagnostics");
+	if (diags_tok < 0 || toks[diags_tok].type != JSMN_ARRAY)
+		return;
+	df = lsp_diagfile_for_path(path);
+	if (!df)
+		return;
+	df->n = 0;
+	/* iterate diagnostics array */
+	i = diags_tok + 1;
+	for (di = 0; di < toks[diags_tok].size && i < n; di++) {
+		if (toks[i].type != JSMN_OBJECT) {
+			i = lsp_skip(toks, n, i);
+			continue;
+		}
+		int diag_obj = i;
+		int range_tok = lsp_find_key(json, toks, n, diag_obj, "range");
+		int sev_tok = lsp_find_key(json, toks, n, diag_obj, "severity");
+		int msg_tok = lsp_find_key(json, toks, n, diag_obj, "message");
+		int line = 0, col = 0, sev = 1;
+		if (range_tok >= 0) {
+			int start_tok = lsp_find_key(json, toks, n, range_tok, "start");
+			if (start_tok >= 0) {
+				int lt = lsp_find_key(json, toks, n, start_tok, "line");
+				int ct = lsp_find_key(json, toks, n, start_tok, "character");
+				if (lt >= 0)
+					line = lsp_tok_int(json, &toks[lt]);
+				if (ct >= 0)
+					col = lsp_tok_int(json, &toks[ct]);
+			}
+		}
+		if (sev_tok >= 0)
+			sev = lsp_tok_int(json, &toks[sev_tok]);
+		if (df->n >= df->cap) {
+			df->cap = df->cap ? df->cap * 2 : 8;
+			if (df->cap > LSP_DIAG_MAX)
+				df->cap = LSP_DIAG_MAX;
+			df->d = erealloc(df->d, df->cap * sizeof(lsp_diag));
+		}
+		if (df->n < LSP_DIAG_MAX) {
+			df->d[df->n].line = line;
+			df->d[df->n].col = col;
+			df->d[df->n].severity = sev;
+			if (msg_tok >= 0)
+				lsp_tok_str(json, &toks[msg_tok],
+					df->d[df->n].msg, sizeof(df->d[0].msg));
+			else
+				df->d[df->n].msg[0] = '\0';
+			df->n++;
+		}
+		i = lsp_skip(toks, n, diag_obj);
+	}
+	(void)srv;
+}
+
+static void lsp_handle_notification(lsp_server *srv, const char *json,
+		jsmntok_t *toks, int n, const char *method)
+{
+	if (!strcmp(method, "textDocument/publishDiagnostics"))
+		lsp_handle_diagnostics(srv, json, toks, n);
+}
+
+static void lsp_handle_response(lsp_server *srv, const char *json,
+		jsmntok_t *toks, int n, int id)
+{
+	if (srv->pending_id == id) {
+		free(srv->response_json);
+		srv->response_json = malloc(n * sizeof(jsmntok_t) + strlen(json) + 1);
+		if (srv->response_json) {
+			strcpy(srv->response_json, json);
+			srv->response_len = n;
+		}
+		srv->response_ready = 1;
+		srv->pending_id = 0;
+	}
+}
+
+static void lsp_handle_message(lsp_server *srv, char *json, int len)
+{
+	jsmn_parser p;
+	jsmntok_t toks[512];
+	int n;
+	char method[128] = "";
+	int id = -1;
+
+	jsmn_init(&p);
+	n = jsmn_parse(&p, json, len, toks, 512);
+	if (n < 1 || toks[0].type != JSMN_OBJECT)
+		return;
+
+	/* extract method */
+	int mtok = lsp_find_key(json, toks, n, 0, "method");
+	if (mtok >= 0 && toks[mtok].type == JSMN_STRING)
+		lsp_tok_str(json, &toks[mtok], method, sizeof(method));
+
+	/* extract id */
+	int itok = lsp_find_key(json, toks, n, 0, "id");
+	if (itok >= 0)
+		id = lsp_tok_int(json, &toks[itok]);
+
+	/* check if initialized response */
+	if (id >= 0 && !method[0]) {
+		if (!srv->initialized && id == 1) {
+			/* this is the initialize response */
+			sbuf_smake(sb2, 128)
+			lsp_fmt_initialized(sb2);
+			lsp_send_sb(srv, sb2);
+			free(sb2->s);
+			srv->initialized = 1;
+			/* send didOpen if we have a file queued */
+			if (srv->open_path[0] && ex_buf && ex_buf->lb) {
+				sbuf_smake(sb3, 4096)
+				lsp_fmt_didopen(srv, sb3, srv->open_path,
+					srv->ft, ex_buf->lb);
+				lsp_send_sb(srv, sb3);
+				free(sb3->s);
+			}
+		}
+		lsp_handle_response(srv, json, toks, n, id);
+	} else if (method[0]) {
+		lsp_handle_notification(srv, json, toks, n, method);
+	}
+}
+
+static void lsp_dispatch_messages(lsp_server *srv)
+{
+	while (1) {
+		/* find \r\n\r\n */
+		char *hdr_end = NULL;
+		int i;
+		for (i = 0; i + 3 < srv->rbuf_n; i++) {
+			if (srv->rbuf[i] == '\r' && srv->rbuf[i+1] == '\n' &&
+					srv->rbuf[i+2] == '\r' && srv->rbuf[i+3] == '\n') {
+				hdr_end = srv->rbuf + i + 4;
+				break;
+			}
+		}
+		if (!hdr_end)
+			break;
+
+		/* parse Content-Length */
+		int clen = 0;
+		char *cl = strstr(srv->rbuf, "Content-Length:");
+		if (!cl || cl >= hdr_end)
+			break;
+		cl += 15;
+		while (*cl == ' ')
+			cl++;
+		clen = atoi(cl);
+		if (clen <= 0)
+			break;
+
+		int hdr_len = hdr_end - srv->rbuf;
+		int total = hdr_len + clen;
+		if (srv->rbuf_n < total)
+			break; /* wait for more data */
+
+		/* process message */
+		hdr_end[clen] = '\0';
+		lsp_handle_message(srv, hdr_end, clen);
+
+		/* shift buffer */
+		srv->rbuf_n -= total;
+		memmove(srv->rbuf, srv->rbuf + total, srv->rbuf_n);
+	}
+}
+
+static void _lsp_process_fd(int fd)
+{
+	lsp_server *srv = lsp_find_srv_for_fd(fd);
+	if (!srv)
+		return;
+	int space = LSP_RBUF_MAX - srv->rbuf_n - 1;
+	if (space <= 0)
+		return;
+	int r = read(fd, srv->rbuf + srv->rbuf_n, space);
+	if (r > 0) {
+		srv->rbuf_n += r;
+		lsp_dispatch_messages(srv);
+	}
+}
+
+static int lsp_wait_response(lsp_server *srv, int id, int ms)
+{
+	int elapsed = 0;
+	srv->pending_id = id;
+	srv->response_ready = 0;
+	while (elapsed < ms) {
+		struct pollfd pfd;
+		pfd.fd = srv->out_fd;
+		pfd.events = POLLIN;
+		int r = poll(&pfd, 1, 10);
+		if (r > 0 && (pfd.revents & POLLIN))
+			_lsp_process_fd(srv->out_fd);
+		if (srv->response_ready)
+			return 1;
+		elapsed += 10;
+	}
+	srv->pending_id = 0;
+	return 0;
+}
+
+static int lsp_srv_ensure(lsp_server *srv)
+{
+	if (srv->pid > 0)
+		return 1;
+	char *argv[] = {"/bin/sh", "-c", srv->cmd, NULL};
+	srv->pid = cmd_make(argv, &srv->in_fd, &srv->out_fd);
+	if (srv->pid <= 0) {
+		srv->pid = -1;
+		return 0;
+	}
+	fcntl(srv->out_fd, F_SETFL,
+		fcntl(srv->out_fd, F_GETFL, 0) | O_NONBLOCK);
+	/* register fd */
+	if (lsp_nfds < LSP_NFDS_MAX)
+		lsp_fds[lsp_nfds++] = srv->out_fd;
+	srv->rbuf_n = 0;
+	srv->initialized = 0;
+	srv->next_id = 0;
+	srv->response_ready = 0;
+	srv->pending_id = 0;
+	free(srv->response_json);
+	srv->response_json = NULL;
+	/* send initialize */
+	sbuf_smake(sb, 512)
+	int id = lsp_fmt_init(srv, sb);
+	lsp_send_sb(srv, sb);
+	free(sb->s);
+	/* wait for initialized response */
+	lsp_wait_response(srv, id, 5000);
+	return srv->initialized;
+}
+
+void lsp_open(const char *path, const char *ft)
+{
+	lsp_server *srv = lsp_srv_for_ft(ft);
+	if (!srv)
+		return;
+	/* check if already open */
+	if (!strcmp(srv->open_path, path) && srv->pid > 0) {
+		/* send didChange */
+		if (ex_buf && ex_buf->lb) {
+			sbuf_smake(sb, 4096)
+			lsp_fmt_didchange(srv, sb, path, ex_buf->lb);
+			lsp_send_sb(srv, sb);
+			free(sb->s);
+		}
+		return;
+	}
+	snprintf(srv->open_path, sizeof(srv->open_path), "%s", path);
+	srv->open_version = 1;
+	if (!lsp_srv_ensure(srv))
+		return;
+	if (!srv->initialized)
+		return;
+	if (ex_buf && ex_buf->lb) {
+		sbuf_smake(sb, 4096)
+		lsp_fmt_didopen(srv, sb, path, ft, ex_buf->lb);
+		lsp_send_sb(srv, sb);
+		free(sb->s);
+	}
+}
+
+void lsp_save(const char *path)
+{
+	int i;
+	for (i = 0; i < lsp_nsrvs; i++) {
+		lsp_server *srv = &lsp_srvs[i];
+		if (srv->pid > 0 && !strcmp(srv->open_path, path)) {
+			sbuf_smake(sb, 256)
+			lsp_fmt_didsave(sb, path);
+			lsp_send_sb(srv, sb);
+			free(sb->s);
+		}
+	}
+}
+
+/* compute byte offset for row,off in lbuf (UTF-8 byte position in line) */
+static int lsp_byte_offset(struct lbuf *lb, int row, int off)
+{
+	if (row < 0 || row >= lbuf_len(lb))
+		return 0;
+	char *ln = lbuf_get(lb, row);
+	if (!ln)
+		return 0;
+	/* off is a visual column index; uc_off converts it to byte offset */
+	return uc_off(ln, off);
+}
+
+void lsp_hover(const char *path, int row, int off)
+{
+	lsp_server *srv = NULL;
+	int i;
+	/* find server for this file */
+	for (i = 0; i < lsp_nsrvs; i++)
+		if (lsp_srvs[i].pid > 0 && !strcmp(lsp_srvs[i].open_path, path)) {
+			srv = &lsp_srvs[i];
+			break;
+		}
+	if (!srv) {
+		lsp_show_msg("lsp: no server for file");
+		return;
+	}
+	int col = lsp_byte_offset(ex_buf ? ex_buf->lb : NULL, row, off);
+	sbuf_smake(sb, 256)
+	int id = lsp_fmt_hover(srv, sb, path, row, col);
+	lsp_send_sb(srv, sb);
+	free(sb->s);
+	if (!lsp_wait_response(srv, id, 2000)) {
+		lsp_show_msg("lsp: hover timeout");
+		return;
+	}
+	/* parse response */
+	if (!srv->response_json) {
+		lsp_show_msg("lsp: no hover result");
+		return;
+	}
+	char *json = srv->response_json;
+	jsmn_parser p;
+	jsmntok_t toks[256];
+	jsmn_init(&p);
+	int n = jsmn_parse(&p, json, strlen(json), toks, 256);
+	if (n < 1) {
+		lsp_show_msg("lsp: hover parse error");
+		return;
+	}
+	int result = lsp_find_key(json, toks, n, 0, "result");
+	if (result < 0 || toks[result].type == JSMN_PRIMITIVE) {
+		lsp_show_msg("lsp: no hover result");
+		return;
+	}
+	/* result.contents */
+	int contents = lsp_find_key(json, toks, n, result, "contents");
+	if (contents < 0) {
+		lsp_show_msg("lsp: no hover contents");
+		return;
+	}
+	char msg[512] = "";
+	if (toks[contents].type == JSMN_STRING) {
+		lsp_tok_str(json, &toks[contents], msg, sizeof(msg));
+	} else if (toks[contents].type == JSMN_OBJECT) {
+		int val = lsp_find_key(json, toks, n, contents, "value");
+		if (val >= 0)
+			lsp_tok_str(json, &toks[val], msg, sizeof(msg));
+	} else if (toks[contents].type == JSMN_ARRAY && toks[contents].size > 0) {
+		int first = contents + 1;
+		if (toks[first].type == JSMN_STRING) {
+			lsp_tok_str(json, &toks[first], msg, sizeof(msg));
+		} else if (toks[first].type == JSMN_OBJECT) {
+			int val = lsp_find_key(json, toks, n, first, "value");
+			if (val >= 0)
+				lsp_tok_str(json, &toks[val], msg, sizeof(msg));
+		}
+	}
+	if (msg[0])
+		lsp_show_msg(msg);
+	else
+		lsp_show_msg("lsp: empty hover");
+}
+
+void lsp_definition(const char *path, int row, int off)
+{
+	lsp_server *srv = NULL;
+	int i;
+	for (i = 0; i < lsp_nsrvs; i++)
+		if (lsp_srvs[i].pid > 0 && !strcmp(lsp_srvs[i].open_path, path)) {
+			srv = &lsp_srvs[i];
+			break;
+		}
+	if (!srv) {
+		lsp_show_msg("lsp: no server for file");
+		return;
+	}
+	int col = lsp_byte_offset(ex_buf ? ex_buf->lb : NULL, row, off);
+	sbuf_smake(sb, 256)
+	int id = lsp_fmt_definition(srv, sb, path, row, col);
+	lsp_send_sb(srv, sb);
+	free(sb->s);
+	if (!lsp_wait_response(srv, id, 2000)) {
+		lsp_show_msg("lsp: definition timeout");
+		return;
+	}
+	if (!srv->response_json) {
+		lsp_show_msg("lsp: no definition result");
+		return;
+	}
+	char *json = srv->response_json;
+	jsmn_parser p;
+	jsmntok_t toks[256];
+	jsmn_init(&p);
+	int n = jsmn_parse(&p, json, strlen(json), toks, 256);
+	if (n < 1) {
+		lsp_show_msg("lsp: definition parse error");
+		return;
+	}
+	int result = lsp_find_key(json, toks, n, 0, "result");
+	if (result < 0 || toks[result].type == JSMN_PRIMITIVE) {
+		lsp_show_msg("lsp: no definition result");
+		return;
+	}
+	char uri[1280] = "";
+	int target_line = 0;
+	/* result can be object (Location), array of Location/LocationLink */
+	int obj = result;
+	if (toks[result].type == JSMN_ARRAY) {
+		if (toks[result].size == 0) {
+			lsp_show_msg("lsp: definition not found");
+			return;
+		}
+		obj = result + 1;
+	}
+	if (toks[obj].type == JSMN_OBJECT) {
+		/* try Location: uri + range */
+		int uri_tok = lsp_find_key(json, toks, n, obj, "uri");
+		if (uri_tok < 0) /* try LocationLink: targetUri + targetRange */
+			uri_tok = lsp_find_key(json, toks, n, obj, "targetUri");
+		if (uri_tok >= 0)
+			lsp_tok_str(json, &toks[uri_tok], uri, sizeof(uri));
+		int range_tok = lsp_find_key(json, toks, n, obj, "range");
+		if (range_tok < 0)
+			range_tok = lsp_find_key(json, toks, n, obj, "targetRange");
+		if (range_tok >= 0) {
+			int start = lsp_find_key(json, toks, n, range_tok, "start");
+			if (start >= 0) {
+				int lt = lsp_find_key(json, toks, n, start, "line");
+				if (lt >= 0)
+					target_line = lsp_tok_int(json, &toks[lt]);
+			}
+		}
+	}
+	if (!uri[0]) {
+		lsp_show_msg("lsp: definition not found");
+		return;
+	}
+	char fpath[1024];
+	lsp_path_from_uri(uri, fpath, sizeof(fpath));
+	/* navigate: open file and go to line */
+	if (strcmp(fpath, path)) {
+		ex_edit(fpath, strlen(fpath));
+	}
+	xrow = target_line;
+	if (xrow >= lbuf_len(xb))
+		xrow = lbuf_len(xb) - 1;
+	if (xrow < 0)
+		xrow = 0;
+	xoff = 0;
+	xtop = xrow > xrows / 2 ? xrow - xrows / 2 : 0;
+}
+
+const char *lsp_diag_for_line(const char *path, int line)
+{
+	int i, j;
+	for (i = 0; i < lsp_ndiagfiles; i++) {
+		if (!strcmp(lsp_diagfiles[i].path, path)) {
+			for (j = 0; j < lsp_diagfiles[i].n; j++)
+				if (lsp_diagfiles[i].d[j].line == line)
+					return lsp_diagfiles[i].d[j].msg;
+			return NULL;
+		}
+	}
+	return NULL;
+}
diff --git a/term.c b/term.c
index 68990b78..8b893398 100644
--- a/term.c
+++ b/term.c
@@ -149,7 +149,6 @@ void term_back(int c)
 
 int term_read(int winch)
 {
-	static struct pollfd ufd = {STDIN_FILENO, POLLIN};
 	int cw;
 	if (ibuf_pos >= ibuf_cnt) {
 		if (texec) {
@@ -162,21 +161,53 @@ int term_read(int winch)
 			goto ret;
 		}
 		cw = 0;
-		re:
-		/* read a single input character */
-		if (xquit < 0 || poll(&ufd, 1, -1) <= 0 ||
-				read(STDIN_FILENO, ibuf, 1) <= 0) {
-			xquit = !isatty(STDIN_FILENO) ? -1 : xquit;
-			if (term_winch && winch && xquit >= 0) {
-				*ibuf = winch;
-				goto ret;
-			} else if (term_winch != cw && !winch && xquit >= 0) {
-				cw = term_winch;
+		re:;
+		{
+			struct pollfd pfds[1 + LSP_NFDS_MAX];
+			int _nr, _i;
+			pfds[0].fd = STDIN_FILENO;
+			pfds[0].events = POLLIN;
+			for (_i = 0; _i < lsp_nfds; _i++) {
+				pfds[1+_i].fd = lsp_fds[_i];
+				pfds[1+_i].events = POLLIN;
+			}
+			if (xquit < 0 || (_nr = poll(pfds, 1+lsp_nfds, -1)) <= 0) {
+				xquit = !isatty(STDIN_FILENO) ? -1 : xquit;
+				if (term_winch && winch && xquit >= 0) {
+					*ibuf = winch;
+					goto ret;
+				} else if (term_winch != cw && !winch && xquit >= 0) {
+					cw = term_winch;
+					goto re;
+				}
+				goto err;
+			}
+			if (lsp_fd_ready)
+				for (_i = 0; _i < lsp_nfds; _i++)
+					if (pfds[1+_i].revents & POLLIN)
+						lsp_fd_ready(lsp_fds[_i]);
+			if (!(pfds[0].revents & POLLIN)) {
+				if (term_winch && winch) {
+					*ibuf = winch;
+					goto ret;
+				}
 				goto re;
 			}
-			err:
-			*ibuf = 0;
+			if (read(STDIN_FILENO, ibuf, 1) <= 0) {
+				xquit = !isatty(STDIN_FILENO) ? -1 : xquit;
+				if (term_winch && winch && xquit >= 0) {
+					*ibuf = winch;
+					goto ret;
+				} else if (term_winch != cw && !winch && xquit >= 0) {
+					cw = term_winch;
+					goto re;
+				}
+				goto err;
+			}
+			goto ret;
 		}
+		err:
+		*ibuf = 0;
 		ret:
 		ibuf_cnt = 1;
 		ibuf_pos = 0;
diff --git a/vi.c b/vi.c
index 5479b948..8ab925b4 100644
--- a/vi.c
+++ b/vi.c
@@ -22,6 +22,7 @@
 #include "ren.c"
 #include "term.c"
 #include "uc.c"
+#include "lsp.c"
 
 int vi_hidch;			/* show hidden chars */
 int vi_lncol;			/* line numbers cursor offset */
@@ -102,6 +103,8 @@ static void vi_drawmsg(char *msg)
 }
 #define vi_drawmsg_mpt(msg) { vi_drawmsg(msg); if (!xmpt) xmpt = 1; }
 
+void lsp_show_msg(char *msg) { vi_drawmsg_mpt(msg) }
+
 static int vi_nextcol(char *ln, int dir, int *off)
 {
 	int o = ren_off(ln, ren_next(ln, ren_pos(ln, *off), dir));
@@ -1613,6 +1616,12 @@ void vi(int init)
 				} else if (k == '~' || k == 'u' || k == 'U') {
 					vc_motion(k);
 					goto rep;
+				} else if (k == 'K') {
+					if (xb_path && xb_path[0])
+						lsp_hover(xb_path, xrow, xoff);
+				} else if (k == 'd') {
+					if (xb_path && xb_path[0])
+						lsp_definition(xb_path, xrow, xoff);
 				}
 				break;
 			case 'x':
@@ -1780,6 +1789,11 @@ void vi(int init)
 			syn_blockhl = -1;
 			vi_drawrow(xrow);
 		}
+		if (!xmpt && xb_path && xb_path[0]) {
+			const char *_ldiag = lsp_diag_for_line(xb_path, xrow);
+			if (_ldiag)
+				vi_drawmsg((char *)_ldiag);
+		}
 		if (vi_status && xmpt < 1) {
 			xrows -= term_resized != vi_status;
 			vi_status = term_resized;
@@ -1813,6 +1827,7 @@ int main(int argc, char *argv[])
 	setup_signals();
 	dir_init();
 	syn_init();
+	lsp_init();
 	temp_open(0, "/hist/", _ft);
 	temp_open(1, "/fm/", fm_ft);
 	for (i = 1; i < argc && argv[i][0] == '-'; i++) {
diff --git a/vi.h b/vi.h
index cba8d35b..641ae519 100644
--- a/vi.h
+++ b/vi.h
@@ -546,3 +546,18 @@ extern int vi_lncol;
 extern rset *fsincl;
 extern char *fs_exdir;
 void dir_calc(char *path);
+
+/* lsp.c */
+#define LSP_NFDS_MAX	8
+extern int lsp_nfds;
+extern int lsp_fds[LSP_NFDS_MAX];
+extern void (*lsp_fd_ready)(int fd);
+void lsp_init(void);
+void lsp_register(const char *ft, const char *cmd);
+void lsp_open(const char *path, const char *ft);
+void lsp_save(const char *path);
+void lsp_hover(const char *path, int row, int off);
+void lsp_definition(const char *path, int row, int off);
+const char *lsp_diag_for_line(const char *path, int line);
+void lsp_list(void);
+void lsp_show_msg(char *msg);
