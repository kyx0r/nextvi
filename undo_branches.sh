#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! @|vis 6@1385a 	{\"up\", ec_undoleafs},
.
@1297a static void *ec_undoleafs(char *loc, char *cmd, char *arg)
{
	char *s = lbuf_getleafs(xb);
	if (*arg)
		lbuf_setleaf(xb, atoi(arg));
	else
		ex_print(s, msg_ft)
	return NULL;
}

.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! @|vis 6@398a 		sbuf_make(lb->rehist, 128)
.
@395,396c 		lbuf_freeleafs(lb);
.
@153,154c 		int i = lb->hist_n - lb->hist_u;
		if (i) {
			sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
			sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
		}
.
@144a void lbuf_setleaf(struct lbuf *lb, int leaf)
{
	char *ptr1 = lb->rehist->s, *ptr2;
	int n, i, off = -1;
	for (i = 0; lb->rehist->s_n > ptr1 - lb->rehist->s; i++) {
		n = *(int*)ptr1;
		if (i == leaf) {
			off = ptr1 - lb->rehist->s;
			break;
		}
		ptr1 += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
	}
	if (off < 0)
		return;
	while (!lbuf_undo(lb, &xrow, &xoff));
	i = lb->hist_n - lb->hist_u;
	if (i) {
		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
		ptr1 = lb->rehist->s + off;
		lb->hist_n = n;
		lb->hist_u = 0;
		if (lb->hist_n >= lb->hist_sz) {
			free(lb->hist);
			int sz = lb->hist_n * 2;
			struct lopt *hist = emalloc(sz * sizeof(hist[0]));
			lb->hist = hist;
			lb->hist_sz = sz;
		}
		memcpy(lb->hist, &ptr1[sizeof(n)], n * sizeof(lb->hist[0]));
		ptr2 = &ptr1[n * sizeof(lb->hist[0]) + sizeof(n)];
		if (lb->rehist->s_n > ptr2 - lb->rehist->s)
			memmove(ptr1, ptr2, lb->rehist->s_n - (ptr2 - lb->rehist->s));
		lb->rehist->s_n -= ptr2 - ptr1;
		while (!lbuf_redo(lb, &xrow, &xoff));
	}
}

char *lbuf_getleafs(struct lbuf *lb)
{
	char *ptr = lb->rehist->s, *bptr;
	int n, i;
	char buf[100];
	sbuf_smake(sb, 128)
	for (i = 0; lb->rehist->s_n > ptr - lb->rehist->s; i++) {
		n = *(int*)ptr;
		bptr = itoa(i, buf);
		*bptr++ = '=';
		bptr = itoa(n, bptr);
		*bptr++ = '|';
		*bptr++ = '\\0';
		sbuf_str(sb, buf);
		ptr += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
	}
	sbufn_ret(sb, sb->s)
}

.
@67,68c 	lbuf_freeleafs(lb);
.
@61a static void lbuf_freeleafs(struct lbuf *lb)
{
	char *ptr = lb->rehist->s;
	struct lopt *hist;
	int n, i, c;
	sbuf *freedsb; sbuf_make(freedsb, 128)
	for (i = 0; i < lb->hist_n; i++) {
		sbuf_mem(freedsb, &lb->hist[i].mark, (int)sizeof(void*))
		lopt_done(&lb->hist[i]);
	}
	while (lb->rehist->s_n > ptr - lb->rehist->s) {
		n = *(int*)ptr;
		hist = (struct lopt*)&ptr[sizeof(n)];
		for (i = 0; i < n; i++) {
			for (c = 0; c < freedsb->s_n; c+=sizeof(void*))
				if (*(void**)((char*)freedsb->s + c) == hist[i].mark)
					goto skip;
			sbuf_mem(freedsb, &hist[i].mark, (int)sizeof(void*))
			lopt_done(&hist[i]);
			skip:;
		}
		ptr += n * sizeof(lb->hist[0]) + sizeof(n);
	}
	sbuf_free(lb->rehist)
	sbuf_free(freedsb)
}

.
@5a 	sbuf_make(lb->rehist, 128)
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: vi.h
EXINIT="rcm:|sc! @|vis 6@188a void lbuf_setleaf(struct lbuf *lb, int leaf);
char *lbuf_getleafs(struct lbuf *lb);
.
@151a 	sbuf *rehist;		/* alternate redo timelines */
.
@vis 4@wq" $VI -e 'vi.h'
