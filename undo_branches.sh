#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 
static void \\\\*ec_null\\\\(char \\\\*loc, char \\\\*cmd, char \\\\*arg\\\\) \\\\{ return NULL; \\\\}
@;=
@.+2a static void *ec_undoleafs(char *loc, char *cmd, char *arg)
{
	char *s = lbuf_getleafs(xb);
	if (*arg)
		lbuf_setleaf(xb, atoi(arg));
	else
		ex_print(s, msg_ft)
	return NULL;
}

.
@.,$;f+ 	\\\\{\"uc\", ec_setenc\\\\},
	\\\\{\"uz\", ec_setenc\\\\},
	\\\\{\"ub\", ec_setenc\\\\},@;=
@.+2a 	{\"up\", ec_undoleafs},
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	struct lbuf \\\\*lb = emalloc\\\\(sizeof\\\\(\\\\*lb\\\\)\\\\);
	memset\\\\(lb, 0, sizeof\\\\(\\\\*lb\\\\)\\\\);
	memset\\\\(lb->mark, -1, sizeof\\\\(lb->mark\\\\) / 2\\\\);@;=
@.+2a 	sbuf_make(lb->rehist, 128)
.
@.,$;f+ 	return 0;
\\\\}
@;=
@.+2a static void lbuf_freeleafs(struct lbuf *lb)
{
	char *ptr = lb->rehist->s;
	struct lopt *hist;
	int n, i, c;
	sbuf *freedsb; sbuf_make(freedsb, 128)
	for (i = 0; i < lb->hist_n; i++) {
		sbuf_mem(freedsb, &lb->hist[i].mark, (int)sizeof(void*))
		lopt_done(&lb->hist[i]);
	}
	while (lb->rehist->s_n > ptr - lb->rehist->s) {
		n = *(int*)ptr;
		hist = (struct lopt*)&ptr[sizeof(n)];
		for (i = 0; i < n; i++) {
			for (c = 0; c < freedsb->s_n; c+=sizeof(void*))
				if (*(void**)((char*)freedsb->s + c) == hist[i].mark)
					goto skip;
			sbuf_mem(freedsb, &hist[i].mark, (int)sizeof(void*))
			lopt_done(&hist[i]);
			skip:;
		}
		ptr += n * sizeof(lb->hist[0]) + sizeof(n);
	}
	sbuf_free(lb->rehist)
	sbuf_free(freedsb)
}

.
@.,$;f+ 	int i;
	for \\\\(i = 0; i < lb->ln_n; i\\\\+\\\\+\\\\)
		free\\\\(lbuf_i\\\\(lb, i\\\\)\\\\);@;=
@.+3,#+1c 	lbuf_freeleafs(lb);
.
@.,$;f+ 		lopt_done\\\\(lo\\\\);
\\\\}
@;=
@.+2a void lbuf_setleaf(struct lbuf *lb, int leaf)
{
	char *ptr1 = lb->rehist->s, *ptr2;
	int n, i, off = -1;
	for (i = 0; lb->rehist->s_n > ptr1 - lb->rehist->s; i++) {
		n = *(int*)ptr1;
		if (i == leaf) {
			off = ptr1 - lb->rehist->s;
			break;
		}
		ptr1 += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
	}
	if (off < 0)
		return;
	while (!lbuf_undo(lb, &xrow, &xoff));
	i = lb->hist_n - lb->hist_u;
	if (i) {
		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
		ptr1 = lb->rehist->s + off;
		lb->hist_n = n;
		lb->hist_u = 0;
		if (lb->hist_n >= lb->hist_sz) {
			free(lb->hist);
			int sz = lb->hist_n * 2;
			struct lopt *hist = emalloc(sz * sizeof(hist[0]));
			lb->hist = hist;
			lb->hist_sz = sz;
		}
		memcpy(lb->hist, &ptr1[sizeof(n)], n * sizeof(lb->hist[0]));
		ptr2 = &ptr1[n * sizeof(lb->hist[0]) + sizeof(n)];
		if (lb->rehist->s_n > ptr2 - lb->rehist->s)
			memmove(ptr1, ptr2, lb->rehist->s_n - (ptr2 - lb->rehist->s));
		lb->rehist->s_n -= ptr2 - ptr1;
		while (!lbuf_redo(lb, &xrow, &xoff));
	}
}

char *lbuf_getleafs(struct lbuf *lb)
{
	char *ptr = lb->rehist->s, *bptr;
	int n, i;
	char buf[100];
	sbuf_smake(sb, 128)
	for (i = 0; lb->rehist->s_n > ptr - lb->rehist->s; i++) {
		n = *(int*)ptr;
		bptr = itoa(i, buf);
		*bptr++ = '=';
		bptr = itoa(n, bptr);
		*bptr++ = '|';
		*bptr++ = '\\\\0';
		sbuf_str(sb, buf);
		ptr += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
	}
	sbufn_ret(sb, sb->s)
}

.
@.,$;f+ 	if \\\\(xseq < 0\\\\)
		lo = &slo;
	else \\\\{@;=
@.+3,#+1c 		int i = lb->hist_n - lb->hist_u;
		if (i) {
			sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
			sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
		}
.
@.,$;f+ void lbuf_saved\\\\(struct lbuf \\\\*lb, int clear\\\\)
\\\\{
	if \\\\(clear\\\\) \\\\{@;=
@.+3,#+1c 		lbuf_freeleafs(lb);
.
@.,$;f+ 		lb->hist_n = 0;
		lb->hist_u = 0;@;=
@.+1a 		sbuf_make(lb->rehist, 128)
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: vi.h
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> struct lbuf \\\\{
	char \\\\*\\\\*ln;			/\\\\* buffer lines \\\\*/
	struct lopt \\\\*hist;		/\\\\* buffer history \\\\*/@;=
@.+2a 	sbuf *rehist;		/* alternate redo timelines */
.
@.,$;f+ int lbuf_findchar\\\\(struct lbuf \\\\*lb, char \\\\*cs, int cmd, int n, int \\\\*r, int \\\\*o\\\\);
int lbuf_search\\\\(struct lbuf \\\\*lb, rset \\\\*re, int dir, int beg, int end, int pskip,
		int nskip, int \\\\*r, int \\\\*o\\\\);@;=
@.+2a void lbuf_setleaf(struct lbuf *lb, int leaf);
char *lbuf_getleafs(struct lbuf *lb);
.
@vis 4@wq" $VI -e 'vi.h'
