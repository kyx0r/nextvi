#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! @|vis 6@369;14;14c , cd == 3
.
@vis 4@vis 6@348;10;10c , 1
.
@vis 4@vis 6@332c 	errchk _lbuf_rd(xb, fd, 0, lbuf_len(xb), init); \\
.
@vis 4@vis 6@329;23;23c , init
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! @|vis 6@229,231c 	long nr, l, nins = 0, nl = 0;
	struct linfo *n, *cn = NULL;
	const int rchunk = 4096;
	char sm[rchunk+1], *s, *ln;
	sbuf_smake(sb, 0)
	while ((nr = read(fd, sm, rchunk)) > 0) {
		s = sm;
		s[nr] = '\\0';
		for (; *s; nins++) {
			l = linelength(s);
			nl = (s[l - !!l] == '\\n');
			int l_nonl = l - nl;
			if (!cn) {
				n = emalloc(l_nonl + 7 + sizeof(struct linfo));
				n->len = l_nonl;
				n->grec = 0;
				ln = (char*)(n + 1);
				memcpy(ln, s, l_nonl);
				memset(&ln[l_nonl + 1], 0, 5);	/* fault tolerance pad */
				ln[l_nonl] = '\\n';
			} else {
				n = erealloc(cn, cn->len + l_nonl + 7 + sizeof(struct linfo));
				ln = (char*)(n + 1);
				memcpy(ln + n->len, s, l_nonl);
				n->len += l_nonl;
				cn = NULL;
				memset(&ln[n->len + 1], 0, 5);	/* fault tolerance pad */
				ln[n->len] = '\\n';
			}
			sbuf_mem(sb, &ln, (int)sizeof(ln))
			s += l;
		}
		if (s - sm != rchunk) {
			nr = 0;
			break;
		}
		if (!nl) {
			cn = n;
			nins--;
			sb->s_n -= sizeof(ln);
		}
	}
	sbuf_null(sb)
	lbuf_edit(lb, sb->s, beg, end, 0, 0);
	lb->ln_n = nins;
	lb->ln = emalloc((nins + 512) * sizeof(lb->ln[0]));
	lb->ln_sz = nins + 512;
	for (int i = 0; i < nins; i++)
		lb->ln[i] = *((char**)sb->s + i);
	free(sb->s);
.
@vis 4@vis 6@227a 		s[n] = '\\0';
		lbuf_edit(lb, s, beg, end, 0, 0);
		free(s);
		return nr != 0;
.
@vis 4@221,226d@vis 6@208,219c 	if (!init) {
		struct stat st;
		long nr;	/* 1048575 caps at 2147481600 on 32 bit */
		int sz = 1048575, step = 1, n = 0;
		if (fstat(fd, &st) >= 0 && S_ISREG(st.st_mode))
			sz = st.st_size >= INT_MAX ? INT_MAX : st.st_size + step;
		char *s = emalloc(sz--);
		while ((nr = read(fd, s + n, sz - n)) > 0) {
			n += nr;
			if (n >= sz + step) {
				if (n > INT_MAX / 2) {
					n -= nr;
					break;
				}
				sz = n * 2;
				s = erealloc(s, sz--);
				step = 1;
			} else if (n == sz) {
				sz++;
				step = 0;
.
@vis 4@vis 6@206c int _lbuf_rd(struct lbuf *lb, int fd, int beg, int end, int init)
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: vi.h
EXINIT="rcm:|sc! @|vis 6@168c int _lbuf_rd(struct lbuf *lb, int fd, int beg, int end, int init);
#define lbuf_rd(lb, fd, beg, end) _lbuf_rd(lb, fd, beg, end, 0)
.
@vis 4@wq" $VI -e 'vi.h'
