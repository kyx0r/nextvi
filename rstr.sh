#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! @|vis 6@1206;23;27c tr_
.
@1203;3;5c tr
.
@1113;3;5c tr
.
@1104;8;10c tr
.
@1094;9;13c tr_
.
@1092;9;13c tr_
.
@1084;3;5c tr
.
@1026;4;6c tr
.
@995;20;29c (rs->rs ? rs->rs->nsubc : 2)
.
@980;11;13c tr
.
@976;14;19c rs ? rs->rs->nsubc : 2
.
@966;9;13c tr_
.
@959;3;5c tr
.
@495;3;5c tr
.
@486;4;6c tr
.
@459;4;6c tr
.
@421;10;12c tr
.
@414;43;50c 
.
@412;9;13c tr_
.
@382;3;5c tr
.
@177,179c 			|| ((xkwdrs->flg & REG_ICASE) != xic))) {
		rstr_free(xkwdrs);
		xkwdrs = rstr_make(kwd, xic ? REG_ICASE : 0);
.
@38;2;4c tr
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! @|vis 6@499;11;13c tr
.
@486;14;19c rs ? re->rs->nsubc : 2
.
@482;35;37c tr
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: regex.c
EXINIT="rcm:|sc! @|vis 6@766a 
/* return zero if a simple pattern is given */
static int rstr_simple(rstr *rs, char *re, int icase)
{
	char *beg;
	char *end;
	if (!strcmp(re, \"^\$\"))
		return 1;
	rs->lbeg = re[0] == '^';
	if (rs->lbeg)
		re++;
	rs->wbeg = re[0] == '\\\\' && re[1] == '<';
	if (rs->wbeg)
		re += 2;
	beg = re;
	while (re[0] && !strchr(\"\\\\.*+?[]{}()\$\", (unsigned char) re[0]))
		re++;
	end = re;
	rs->wend = re[0] == '\\\\' && re[1] == '>';
	if (rs->wend)
		re += 2;
	rs->lend = re[0] == '\$';
	if (rs->lend)
		re++;
	if (!re[0]) {
		int len = end - beg;
		rs->len = len;
		rs->str = emalloc(len + 1);
		rs->str[len] = '\\0';
		if (icase) {
			while (--len >= 0)
				rs->str[len] = tolower((unsigned char)beg[len]);
		} else
			memcpy(rs->str, beg, len);
		return 0;
	}
	return 1;
}

rstr *rstr_make(char *re, int flg)
{
	rstr *rs = emalloc(sizeof(*rs));
	memset(rs, 0, sizeof(*rs));
	rs->flg = flg;
	if (rstr_simple(rs, re, flg & REG_ICASE))
		rs->rs = rset_make(1, &re, flg);
	if (!rs->rs && !rs->str) {
		free(rs);
		return NULL;
	}
	return rs;
}

#define rstr_cmp(gen, wbeg, wend, cmpcase) \\
wbeg wend \\
m = rs->str; t = r; \\
for (; *m && *t; t++, m++) { \\
	if (cmpcase) \\
		goto break##gen; \\
} \\
if (!*m) { \\
	if (grps) { \\
		grps[0] = r - s; \\
		grps[1] = r - s + len; \\
	} \\
	return 0; \\
} \\
break##gen:; \\

#define rstr_match1(gen, wbeg, wend, cmpcase) \\
{ for (r = beg; r <= end; r++) { \\
	rstr_cmp(2##gen, wbeg, wend, cmpcase) \\
} } \\

#define _wbeg if (r > s && (isword(r - 1) || !isword(r))) continue;
#define _wend if (r[len] && (!isword(r + len - 1) || isword(r + len))) continue;

#define template(gen, cmpcase) \\
if (!rs->wbeg && !rs->wend) \\
	rstr_match1(1##gen, /*nop*/, /*nop*/, cmpcase) \\
else if (rs->wbeg && !rs->wend) \\
	rstr_match1(2##gen, _wbeg, /*nop*/, cmpcase) \\
else if (!rs->wbeg && rs->wend) \\
	rstr_match1(3##gen, /*nop*/, _wend, cmpcase) \\
else \\
	rstr_match1(4##gen, _wbeg, _wend, cmpcase) \\

/* return zero if an occurrence is found */
int rstr_find(rstr *rs, char *s, int *grps, int flg)
{
	int len;
	char *beg, *end, *r, *t, *m;
	if (rs->rs)
		return rset_find(rs->rs, s, grps, flg);
	flg = rs->flg | flg;
	if ((rs->lbeg && (flg & REG_NOTBOL)) || (rs->lend && (flg & REG_NOTEOL)))
		return -1;
	if (!*s)
		return -1;
	len = rs->len;
	beg = s;
	end = s + strlen(s) - len - (flg & REG_NEWLINE ? 1 : 0);
	if (end < beg)
		return -1;
	if (rs->lend)
		beg = end;
	if (rs->lbeg)
		end = s;
	if (flg & REG_ICASE) {
		template(4, tolower((unsigned char) *t) != *m)
	} else {
		template(3, *t != *m)
	}
	return -1;
}

int rstr_match(rstr *rs, char *s, int flg)
{
	if (rs->rs)
		return re_pikevm(rs->rs->regex, s, NULL, 0, flg);
	int ret = rstr_find(rs, s, NULL, flg);
	return ret < 0 ? 0 : 1;
}

void rstr_free(rstr *rs)
{
	if (!rs)
		return;
	rset_free(rs->rs);
	free(rs->str);
	free(rs);
}
.
@vis 4@wq" $VI -e 'regex.c'

# Patch: vi.c
EXINIT="rcm:|sc! @|vis 6@479;21;23c tr
.
@439;2;4c tr
.
@vis 4@wq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! @|vis 6@541;9;11c tr
.
@480;13;15c tr
.
@447;9;11c tr
.
@190a 
.
@189;35;37c tr
.
@131a rstr *rstr_make(char *re, int flg);
int rstr_find(rstr *rs, char *s, int *grps, int flg);
int rstr_match(rstr *rs, char *s, int flg);
void rstr_free(rstr *rs);
.
@124a typedef struct {
	rset *rs;		/* only for regex patterns */
	char *str;		/* for simple, non-regex patterns  */
	int len;		/* str length */
	int flg;		/* flags */
	int lbeg, lend;		/* match line beg/end */
	int wbeg, wend;		/* match word beg/end */
} rstr;
.
@vis 4@wq" $VI -e 'vi.h'
