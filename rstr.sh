#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> int xsep = ':';			/\\\\* ex command separator \\\\*/
int xesc = '\\\\\\\\\\\\\\\\';		/\\\\* ex command arg escape character \\\\*/
sbuf \\\\*xacreg;			/\\\\* autocomplete db filter regex \\\\*/@;=
@.+3;2;4c tr
.
@.,$;f+ \\\\{
	sbuf \\\\*reg = xregs\\\\['/'\\\\];
	if \\\\(kwd && \\\\*kwd && \\\\(\\\\(!reg \\\\|\\\\| !xkwdrs \\\\|\\\\| strcmp\\\\(kwd, reg->s\\\\)\\\\)@;=
@.+3,#+2c 			|| ((xkwdrs->flg & REG_ICASE) != xic))) {
		rstr_free(xkwdrs);
		xkwdrs = rstr_make(kwd, xic ? REG_ICASE : 0);
.
@.,$;f+ 
static void \\\\*ec_fuzz\\\\(char \\\\*loc, char \\\\*cmd, char \\\\*arg\\\\)
\\\\{@;=
@.+3;3;5c tr
.
@.,$;f+ 	while\\\\(1\\\\) \\\\{
		sbuf_null\\\\(fuzz\\\\)
		c = 0;@;=
@.+3;9;13c tr_
.
@.-1@>		if \\(rs\\) \\{>+1;43;50c 
.
@.,$;f+ 			dwid1 = max == INT_MAX \\\\? dwid2 : MIN\\\\(dwid1, dwid2\\\\);
			for \\\\(pos = beg; c < max && pos < end; pos\\\\+\\\\+\\\\) \\\\{
				path = xb->ln\\\\[pos\\\\];@;=
@.+3;10;12c tr
.
@.,$;f+ 				break;
			\\\\}
		\\\\}@;=
@.+3;4;6c tr
.
@.,$;f+ 	free\\\\(sb->s\\\\);
	path = lbuf_get\\\\(xb, lnum\\\\);
	if \\\\(\\\\*cmd == 'f' && path\\\\) \\\\{@;=
@.+3;4;6c tr
.
@.,$;f+ 		path\\\\[lbuf_s\\\\(path\\\\)->len\\\\] = '\\\\\\\\n';
	\\\\} else if \\\\(\\\\*cmd != 'f'\\\\)
		temp_switch\\\\(1, 1\\\\);@;=
@.+3;3;5c tr
.
@.,$;f+ 		return xserr;
	if \\\\(o1 >= 0 && dir > 0\\\\) \\\\{
		sbuf sb;@;=
@.+3;19;24c rs ? xkwdrs->rs->nsubc : 2
.
@.,$;f+ 			soff = lbuf_pos2off\\\\(xb, beg, o1, r2, o2, xrow, xoff \\\\+ skip\\\\);
		if \\\\(soff < 0\\\\)
			soff = 0;@;=
@.+3;8;10c tr
.
@.,$;f+ 	int beg, end, grp;
	char \\\\*pat, \\\\*rep = NULL, \\\\*_rep;
	char \\\\*s = arg;@;=
@.+3;3;5c tr
.
@.,$;f+ 		return xrerr;
	pat = re_read\\\\(&s, 0\\\\);
	if \\\\(pat && \\\\(\\\\*pat \\\\|\\\\| !rs\\\\)\\\\)@;=
@.+3;9;13c tr_
.
@.,$;f+ 		rep = re_read\\\\(&s, 0\\\\);
	\\\\}
	free\\\\(pat\\\\);@;=
@.+3;14;19c rs ? rs->rs->nsubc : 2
.
@.,$;f+ 	for \\\\(i = beg; i < end; i\\\\+\\\\+\\\\) \\\\{
		char \\\\*ln = lbuf_get\\\\(xb, i\\\\);
		sbuf \\\\*r = NULL;@;=
@.+3;11;13c tr
.
@.,$;f+ 					\\\\}
					_rep\\\\+\\\\+;
					grp = abs\\\\(\\\\(\\\\*_rep - '0'\\\\) \\\\* 2\\\\);@;=
@.+3;20;29c (rs->rs ? rs->rs->nsubc : 2)
.
@.,$;f+ 		lbuf_emark\\\\(xb, lo, last, 0\\\\);
	\\\\}
	if \\\\(rs != xkwdrs\\\\)@;=
@.+3;4;6c tr
.
@.,$;f+ \\\\{
	int i, beg, end, not;
	char \\\\*pat, \\\\*s = arg;@;=
@.+3;3;5c tr
.
@.,$;f+ 	not = !!strchr\\\\(cmd, '!'\\\\);
	pat = re_read\\\\(&s, 0\\\\);
	if \\\\(pat && \\\\*pat\\\\)@;=
@.+3;9;13c tr_
.
@.-1@>	else>+1;9;13c tr_
.
@.,$;f+ 	for \\\\(i = beg; i < lbuf_len\\\\(xb\\\\);\\\\) \\\\{
		char \\\\*ln = lbuf_get\\\\(xb, i\\\\);
		lbuf_s\\\\(ln\\\\)->grec &= ~xgdep;@;=
@.+3;8;10c tr
.
@.,$;f+ 		while \\\\(i < lbuf_len\\\\(xb\\\\) && !\\\\(lbuf_i\\\\(xb, i\\\\)->grec & xgdep\\\\)\\\\)
			i\\\\+\\\\+;
	\\\\}@;=
@.+3;3;5c tr
.
@.,$;f+ 
static void \\\\*ec_setincl\\\\(char \\\\*loc, char \\\\*cmd, char \\\\*arg\\\\)
\\\\{@;=
@.+3;3;5c tr
.
@.,$;f+ 	if \\\\(!\\\\*arg\\\\)
		fsincl = NULL;@;=
@.+2;23;27c tr_
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	return n != 0;
\\\\}
@;=
@.+3;35;37c tr
.
@.,$;f+ 		int nskip, int \\\\*r, int \\\\*o\\\\)
\\\\{
	int r0 = \\\\*r, o0 = \\\\*o;@;=
@.+3;14;19c rs ? re->rs->nsubc : 2
.
@.,$;f+ 		step = 0;
		flg = REG_NEWLINE;
		s = lb->ln\\\\[i\\\\];@;=
@.+3;11;13c tr
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: regex.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	\\\\*src = \\\\*s \\\\? s \\\\+ 1 : s;
	sbufn_ret\\\\(sb, sb->s\\\\)
\\\\}@;=
@.+2a 
/* return zero if a simple pattern is given */
static int rstr_simple(rstr *rs, char *re, int icase)
{
	char *beg;
	char *end;
	if (!strcmp(re, \"^\$\"))
		return 1;
	rs->lbeg = re[0] == '^';
	if (rs->lbeg)
		re++;
	rs->wbeg = re[0] == '\\\\\\\\' && re[1] == '<';
	if (rs->wbeg)
		re += 2;
	beg = re;
	while (re[0] && !strchr(\"\\\\\\\\.*+?[]{}()\$\", (unsigned char) re[0]))
		re++;
	end = re;
	rs->wend = re[0] == '\\\\\\\\' && re[1] == '>';
	if (rs->wend)
		re += 2;
	rs->lend = re[0] == '\$';
	if (rs->lend)
		re++;
	if (!re[0]) {
		int len = end - beg;
		rs->len = len;
		rs->str = emalloc(len + 1);
		rs->str[len] = '\\\\0';
		if (icase) {
			while (--len >= 0)
				rs->str[len] = tolower((unsigned char)beg[len]);
		} else
			memcpy(rs->str, beg, len);
		return 0;
	}
	return 1;
}

rstr *rstr_make(char *re, int flg)
{
	rstr *rs = emalloc(sizeof(*rs));
	memset(rs, 0, sizeof(*rs));
	rs->flg = flg;
	if (rstr_simple(rs, re, flg & REG_ICASE))
		rs->rs = rset_make(1, &re, flg);
	if (!rs->rs && !rs->str) {
		free(rs);
		return NULL;
	}
	return rs;
}

#define rstr_cmp(gen, wbeg, wend, cmpcase) \\\\
wbeg wend \\\\
m = rs->str; t = r; \\\\
for (; *m && *t; t++, m++) { \\\\
	if (cmpcase) \\\\
		goto break##gen; \\\\
} \\\\
if (!*m) { \\\\
	if (grps) { \\\\
		grps[0] = r - s; \\\\
		grps[1] = r - s + len; \\\\
	} \\\\
	return 0; \\\\
} \\\\
break##gen:; \\\\

#define rstr_match1(gen, wbeg, wend, cmpcase) \\\\
{ for (r = beg; r <= end; r++) { \\\\
	rstr_cmp(2##gen, wbeg, wend, cmpcase) \\\\
} } \\\\

#define _wbeg if (r > s && (isword(r - 1) || !isword(r))) continue;
#define _wend if (r[len] && (!isword(r + len - 1) || isword(r + len))) continue;

#define template(gen, cmpcase) \\\\
if (!rs->wbeg && !rs->wend) \\\\
	rstr_match1(1##gen, /*nop*/, /*nop*/, cmpcase) \\\\
else if (rs->wbeg && !rs->wend) \\\\
	rstr_match1(2##gen, _wbeg, /*nop*/, cmpcase) \\\\
else if (!rs->wbeg && rs->wend) \\\\
	rstr_match1(3##gen, /*nop*/, _wend, cmpcase) \\\\
else \\\\
	rstr_match1(4##gen, _wbeg, _wend, cmpcase) \\\\

/* return zero if an occurrence is found */
int rstr_find(rstr *rs, char *s, int *grps, int flg)
{
	int len;
	char *beg, *end, *r, *t, *m;
	if (rs->rs)
		return rset_find(rs->rs, s, grps, flg);
	flg = rs->flg | flg;
	if ((rs->lbeg && (flg & REG_NOTBOL)) || (rs->lend && (flg & REG_NOTEOL)))
		return -1;
	if (!*s)
		return -1;
	len = rs->len;
	beg = s;
	end = s + strlen(s) - len - (flg & REG_NEWLINE ? 1 : 0);
	if (end < beg)
		return -1;
	if (rs->lend)
		beg = end;
	if (rs->lbeg)
		end = s;
	if (flg & REG_ICASE) {
		template(4, tolower((unsigned char) *t) != *m)
	} else {
		template(3, *t != *m)
	}
	return -1;
}

int rstr_match(rstr *rs, char *s, int flg)
{
	if (rs->rs)
		return re_pikevm(rs->rs->regex, s, NULL, 0, flg);
	int ret = rstr_find(rs, s, NULL, flg);
	return ret < 0 ? 0 : 1;
}

void rstr_free(rstr *rs)
{
	if (!rs)
		return;
	rset_free(rs->rs);
	free(rs->str);
	free(rs);
}
.
@vis 4@wq" $VI -e 'regex.c'

# Patch: vi.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	ex_regput\\\\(tolower\\\\(c\\\\), s, isupper\\\\(c\\\\)\\\\);
\\\\}
@;=
@.+3;2;4c tr
.
@.,$;f+ 				memcpy\\\\(cpath, ptrs\\\\[i\\\\], pathlen \\\\+ len\\\\);
				plen\\\\[i\\\\+\\\\+\\\\] = pathlen \\\\+ len;
			\\\\} else if \\\\(ret >= 0 && S_ISREG\\\\(statbuf\\\\.st_mode\\\\)\\\\)@;=
@.+3;21;23c tr
.
@vis 4@wq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	int nsubc;		/\\\\* total sub count \\\\*/
	int n;			/\\\\* number of regular expressions in this set \\\\*/
\\\\} rset;@;=
@.+2a typedef struct {
	rset *rs;		/* only for regex patterns */
	char *str;		/* for simple, non-regex patterns  */
	int len;		/* str length */
	int flg;		/* flags */
	int lbeg, lend;		/* match line beg/end */
	int wbeg, wend;		/* match word beg/end */
} rstr;
.
@.,$;f+ int rset_match\\\\(rset \\\\*rs, char \\\\*s, int flg\\\\);
void rset_free\\\\(rset \\\\*re\\\\);
char \\\\*re_read\\\\(char \\\\*\\\\*src, int delim\\\\);@;=
@.+2a rstr *rstr_make(char *re, int flg);
int rstr_find(rstr *rs, char *s, int *grps, int flg);
int rstr_match(rstr *rs, char *s, int flg);
void rstr_free(rstr *rs);
.
@.,$;f+ int lbuf_eol\\\\(struct lbuf \\\\*lb, int r, int state\\\\);
int lbuf_next\\\\(struct lbuf \\\\*lb, int dir, int \\\\*r, int \\\\*o\\\\);
int lbuf_findchar\\\\(struct lbuf \\\\*lb, char \\\\*cs, int cmd, int n, int \\\\*r, int \\\\*o\\\\);@;=
@.+3;35;37c tr
.
@.-1@>		int nskip, int \\*r, int \\*o\\);>a 
.
@.,$;f+ extern int xsep;
extern int xesc;
extern sbuf \\\\*xacreg;@;=
@.+3;9;11c tr
.
@.,$;f+ #define ex_print\\\\(line, ft\\\\) \\\\{ RS\\\\(2, ex_cprint\\\\(line, ft, -1, 0, 0, 1\\\\)\\\\); \\\\}
void ex_init\\\\(char \\\\*\\\\*files, int n\\\\);
void ex_bufpostfix\\\\(struct buf \\\\*p, int clear\\\\);@;=
@.+3;13;15c tr
.
@.,$;f+ extern int vi_hidch;
extern int vi_lncol;
/\\\\* file system \\\\*/@;=
@.+3;9;11c tr
.
@vis 4@wq" $VI -e 'vi.h'
