diff --git a/conf.c b/conf.c
index ddacc04e..96d8f060 100644
--- a/conf.c
+++ b/conf.c
@@ -50,7 +50,7 @@ char msg_ft[] = "/>";	/* ex message (is never '\n' terminated) */
 #define CY1	14	/* bright cyan */
 #define WH1	15	/* bright white */
 
-#define A(...) (int[]){__VA_ARGS__}
+#define A(...) {__VA_ARGS__}
 
 /* At least 1 entry is required in this struct for fallback */
 /* lbuf lines are *always "\n\0" terminated, for $ to work one needs to account for '\n' too */
diff --git a/ex.c b/ex.c
index 2bc1e43c..82bd5be1 100644
--- a/ex.c
+++ b/ex.c
@@ -875,7 +875,7 @@ static void *ec_substitute(char *loc, char *cmd, char *arg)
 		rep = re_read(&s);
 	}
 	free(pat);
-	int offs[rs->grpcnt * 2];
+	int *offs = emalloc(rs->grpcnt * 2 * sizeof(int));
 	for (i = beg; i < end; i++) {
 		char *ln = lbuf_get(xb, i);
 		sbuf *r = NULL;
@@ -922,6 +922,7 @@ static void *ec_substitute(char *loc, char *cmd, char *arg)
 	if (rs != xkwdrs)
 		rset_free(rs);
 	free(rep);
+	free(offs);
 	return NULL;
 }
 
@@ -1324,7 +1325,7 @@ void *ex_exec(const char *ln)
 {
 	int idx = 0, len = strlen(ln) + 1;
 	int r1 = -1, r2 = -1;
-	char loc[len], arg[len], *ecmd, *ret = NULL;
+	char *loc = emalloc(len), *arg = emalloc(len), *ecmd, *ret = NULL;
 	sbuf_smake(sb, 1024)
 	for (int i = 0; *ln; i++) {
 		ln = ex_parse(ln, loc, &idx, arg);
@@ -1341,6 +1342,8 @@ void *ex_exec(const char *ln)
 		sbuf_cut(sb, 0)
 	}
 	free(sb->s);
+	free(loc);
+	free(arg);
 	return ret;
 }
 
diff --git a/lbuf.c b/lbuf.c
index 62cbaa10..e5b2bc10 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -376,7 +376,7 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int *o, int ln_n, int skip)
 {
 	int r0 = *r, o0 = *o;
-	int offs[re->grpcnt * 2], i = r0;
+	int *offs = emalloc(re->grpcnt * 2 * sizeof(int)), i = r0;
 	char *s = lbuf_get(lb, i);
 	int off, g1, g2, _o, step, flg;
 	if (skip >= 0 && s)
@@ -401,14 +401,17 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 				break;
 			*o = _o;
 			*r = i;
-			if (dir > 0)
+			if (dir > 0) {
+				free(offs);
 				return 0;
+			}
 			step = off + g1;
 			off += g2 > 0 ? g2 : 1;
 			ln_n = -1; /* break outer loop efficiently */
 		}
 		off = 0;
 	}
+	free(offs);
 	return ln_n < 0 ? 0 : 1;
 }
 
diff --git a/led.c b/led.c
index 503b153e..c0386e89 100644
--- a/led.c
+++ b/led.c
@@ -47,7 +47,7 @@ static void file_index(struct lbuf *buf)
 	rset *rs = rset_smake(xacreg ? xacreg->s : reg, xic ? REG_ICASE : 0);
 	if (!rs)
 		return;
-	int subs[rs->grpcnt * 2];
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int));
 	sbuf_smake(ibuf, 1024)
 	for (n = 1; n <= acsb->s_n; n++)
 		if (acsb->s[n - 1] == '\n')
@@ -81,6 +81,7 @@ static void file_index(struct lbuf *buf)
 	sbuf_null(acsb)
 	free(ibuf->s);
 	rset_free(rs);
+	free(subs);
 }
 
 static char *kmap_map(int kmap, int c)
@@ -151,10 +152,10 @@ void led_render(char *s0, int cbeg, int cend)
 	int att_old = 0, atti = 0, cterm = cend - cbeg;
 	char *bound = NULL;
 	char **chrs = r->chrs;	/* chrs[i]: the i-th character in s0 */
-	int off[cterm+1];	/* off[i]: the character at screen position i */
-	int att[cterm+1];	/* att[i]: the attributes of i-th character */
-	int stt[cterm+1];	/* stt[i]: remap off indexes */
-	int ctt[cterm+1];	/* ctt[i]: cterm bound attrs */
+	int *off = emalloc((cterm+1) * sizeof(int));	/* off[i]: the character at screen position i */
+	int *att = emalloc((cterm+1) * sizeof(int));	/* att[i]: the attributes of i-th character */
+	int *stt = NULL;	/* stt[i]: remap off indexes */
+	int *ctt = NULL;	/* ctt[i]: cterm bound attrs */
 	int ctx = r->ctx;
 	off[cterm] = -1;
 	if (ctx < 0) {
@@ -176,6 +177,8 @@ void led_render(char *s0, int cbeg, int cend)
 		if (o >= 0 && r->cmax > cterm && r->pos[o] + r->wid[o] > cend)
 			while (off[i] == o)
 				off[ctx < 0 ? i++ : i--] = -1;
+		stt = emalloc((cterm+1) * sizeof(int));
+		ctt = emalloc((cterm+1) * sizeof(int));
 		for (i = 0, c = 0; i < cterm;) {
 			if ((o = off[i++]) >= 0) {
 				att[c++] = o;
@@ -258,6 +261,10 @@ void led_render(char *s0, int cbeg, int cend)
 		memcpy(chrs[n], r->nullhole, r->holelen);
 		r->holelen = 0;
 	}
+	free(off);
+	free(att);
+	free(stt);
+	free(ctt);
 }
 
 static int led_lastchar(char *s)
diff --git a/regex.c b/regex.c
index daeeea06..969d2276 100644
--- a/regex.c
+++ b/regex.c
@@ -382,7 +382,15 @@ static int reg_comp(rcode *prog, char *re, int nsubs, int laidx, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; \
+free(pcs); \
+free(subs); \
+free(sdense); \
+free(_clist); \
+free(_nlist); \
+free(nsubs); \
+free(lb); \
+return state; } \
 
 #define newsub(init, copy) \
 if (freesub) { \
@@ -614,18 +622,19 @@ static int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, i
 	if (!*s)
 		return 0;
 	const char *sp = s, *_sp = s, *str;
-	int *pcs[prog->splits], *npc, *pc, *insts = prog->insts;
-	rsub *subs[prog->splits];
+	int *npc, *pc, *insts = prog->insts;
+	int **pcs = emalloc((prog->splits) * sizeof(int*));
+	rsub **subs = emalloc(prog->splits * sizeof(rsub*));
+	unsigned int *sdense = emalloc(prog->sparsesz * sizeof(unsigned int)), sparsesz = 0;
 	rsub *nsub, *s1, *matched = NULL, *freesub = NULL;
-	rthread _clist[prog->len], _nlist[prog->len];
+	rthread *_clist = emalloc(prog->len * sizeof(rthread)), *_nlist = emalloc(prog->len * sizeof(rthread));
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
-	const void *lb[prog->laidx * 3];
+	const void **lb = emalloc(prog->laidx * 3 * sizeof(void*));
 	int rsubsize = prog->presub, suboff = 0, lblen = 0;
 	int cnt, spc, i, j, c, osubp = nsubp * sizeof(char*);
 	int si = 0, clistidx = 0, nlistidx, mcont = MATCH;
 	int eol_ch = flg & REG_NEWLINE ? '\n' : 0;
-	unsigned int sdense[prog->sparsesz], sparsesz = 0;
-	char nsubs[prog->sub];
+	char *nsubs = emalloc(prog->sub);
 	flg = prog->flg | flg;
 	if (eol_ch)
 		utf8_length[eol_ch] = 0;
@@ -706,7 +715,7 @@ rset *rset_make(int n, char **re, int flg)
 /* return the index of the matching regular expression or -1 if none matches */
 int rset_find(rset *rs, char *s, int *grps, int flg)
 {
-	regmatch_t subs[rs->grpcnt+1];
+	regmatch_t *subs = emalloc((rs->grpcnt+1) * sizeof(regmatch_t));
 	regmatch_t *sub = subs+1;
 	if (re_pikevm(rs->regex, s, (const char**)sub, rs->grpcnt * 2, flg)) {
 		subs[0].rm_eo = NULL; /* make sure sub[-1] never matches */
@@ -723,10 +732,12 @@ int rset_find(rset *rs, char *s, int *grps, int flg)
 						grps[gi * 2 + 1] = -1;
 					}
 				}
+				free(subs);
 				return i;
 			}
 		}
 	}
+	free(subs);
 	return -1;
 }
 
diff --git a/ren.c b/ren.c
index a552bd9b..0f11952c 100644
--- a/ren.c
+++ b/ren.c
@@ -255,13 +255,14 @@ int syn_blockhl;
 static void syn_initft(int fti, int n, char *name)
 {
 	int i = n;
-	char *pats[hlslen];
+	char **pats = emalloc((hlslen) * sizeof(char*));
 	for (; i < hlslen && !strcmp(hls[i].ft, name); i++)
 		pats[i - n] = hls[i].pat;
 	ftmap[fti].setbidx = n;
 	ftmap[fti].ft = name;
 	ftmap[fti].rs = rset_make(i - n, pats, 0);
 	ftmap[fti].seteidx = i;
+	free(pats);
 }
 
 char *syn_setft(char *ft)
@@ -302,7 +303,7 @@ int syn_merge(int old, int new)
 void syn_highlight(int *att, char *s, int n)
 {
 	rset *rs = ftmap[ftidx].rs;
-	int subs[rs->grpcnt * 2], sl;
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int)), sl;
 	int blk = 0, blkm = 0, sidx = 0, flg = 0, hl, j, i;
 	int bend = 0, cend = 0;
 	while ((sl = rset_find(rs, s + sidx, subs, flg)) >= 0) {
@@ -348,6 +349,7 @@ void syn_highlight(int *att, char *s, int n)
 	if (syn_blockhl && !blk)
 		for (j = 0; j < n; j++)
 			att[j] = att[j] && SYN_SOSET(*blockatt) ? att[j] : *blockatt;
+	free(subs);
 }
 
 char *syn_filetype(char *path)
@@ -388,9 +390,10 @@ void syn_addhl(char *reg, int id, int reload)
 
 void syn_init(void)
 {
-	char *pats[ftslen];
+	char **pats = emalloc(ftslen * sizeof(char *));
 	int i = 0;
 	for (; i < ftslen; i++)
 		pats[i] = fts[i].pat;
 	syn_ftrs = rset_make(i, pats, 0);
+	free(pats);
 }
diff --git a/vi.c b/vi.c
index 39e37aec..34a213ef 100644
--- a/vi.c
+++ b/vi.c
@@ -141,7 +141,8 @@ static void vi_drawrow(int row)
 			vi_rshift = 0;
 		if (row != xrow+1 || !c || *c == '\n')
 			goto skip;
-		char tmp[xcols+3], snum[32];
+		char *tmp = emalloc(xcols+3);
+		char *snum = emalloc(32);
 		memset(tmp, ' ', xcols+1);
 		tmp[xcols+1] = '\n';
 		tmp[xcols+2] = '\0';
@@ -166,6 +167,8 @@ static void vi_drawrow(int row)
 		restore(xorder)
 		restore(syn_blockhl)
 		restore(xtd)
+		free(tmp);
+		free(snum);
 		return;
 	}
 	s = lbuf_get(xb, row);
@@ -1261,10 +1264,11 @@ void vi(int init)
 				if (!(ln = lbuf_get(xb, xrow)))
 					break;
 				ln += xoff;
-				char buf[strlen(ln)+4];
+				char *buf = emalloc(strlen(ln)+4);
 				strcpy(buf, ":e ");
 				strcpy(buf+3, ln);
 				term_push(buf, strlen(ln)+3);
+				free(buf);
 				break; }
 			case TK_CTL('n'):
 				vi_cndir = vi_arg ? -vi_cndir : vi_cndir;
@@ -1396,7 +1400,7 @@ void vi(int init)
 					strcpy(vi_msg, "arg2:(0|#)");
 					vi_drawmsg();
 					cs = vi_curword(xb, xrow, xoff, vi_prefix());
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, ".,.+");
 					char *buf1 = itoa(vi_arg, buf+4);
 					strcat(buf1, "s/");
@@ -1406,10 +1410,11 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_enprompt(":", buf, &n);
+					free(buf);
 					goto do_excmd; }
 				case 'r': {
 					cs = vi_curword(xb, xrow, xoff, vi_arg);
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, "%s/");
 					if (cs) {
 						strcat(buf, cs);
@@ -1417,6 +1422,7 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_enprompt(":", buf, &n);
+					free(buf);
 					goto do_excmd; }
 				default:
 					term_dec()
diff --git a/vi.h b/vi.h
index 959d54db..be5f43cd 100644
--- a/vi.h
+++ b/vi.h
@@ -463,7 +463,7 @@ extern const int ftslen;
 struct highlight {
 	char *ft;		/* the filetype of this pattern */
 	char *pat;		/* regular expression */
-	int *att;		/* attributes of the matched groups */
+	int att[16];		/* attributes of the matched groups */
 	signed char blkend;	/* the ending group for multi-line patterns;
 				negative group is able to start and end itself */
 	char id;		/* id of this hl */
