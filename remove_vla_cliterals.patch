diff --git a/conf.c b/conf.c
index 4e07054e..7aea43a1 100644
--- a/conf.c
+++ b/conf.c
@@ -50,7 +50,7 @@ char msg_ft[] = "/>";	/* ex message (is never '\n' terminated) */
 #define CY1	14	/* bright cyan */
 #define WH1	15	/* bright white */
 
-#define A(...) (int[]){__VA_ARGS__}
+#define A(...) {__VA_ARGS__}
 
 /* At least 1 entry is required in this struct for fallback */
 /* lbuf lines are *always "\n\0" terminated, for $ to work one needs to account for '\n' too */
diff --git a/ex.c b/ex.c
index 372a5688..8d2391d4 100644
--- a/ex.c
+++ b/ex.c
@@ -846,7 +846,7 @@ static void *ec_substitute(char *loc, char *cmd, char *arg)
 		rep = re_read(&s);
 	}
 	free(pat);
-	int offs[rs->grpcnt * 2];
+	int *offs = emalloc(rs->grpcnt * 2 * sizeof(int));
 	for (i = beg; i < end; i++) {
 		char *ln = lbuf_get(xb, i);
 		sbuf *r = NULL;
@@ -898,6 +898,7 @@ static void *ec_substitute(char *loc, char *cmd, char *arg)
 	if (rs != xkwdrs)
 		rset_free(rs);
 	free(rep);
+	free(offs);
 	return NULL;
 }
 
diff --git a/lbuf.c b/lbuf.c
index cedc3cdf..8e1f95e8 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -407,7 +407,7 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int *o, int ln_n, int skip)
 {
 	int r0 = *r, o0 = *o;
-	int offs[re->grpcnt * 2], i = r0;
+	int *offs = emalloc(re->grpcnt * 2 * sizeof(int)), i = r0;
 	char *s = lbuf_get(lb, i);
 	int off, g1, g2, _o, step, flg;
 	if (skip >= 0 && s)
@@ -432,14 +432,17 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 				break;
 			*o = _o;
 			*r = i;
-			if (dir > 0)
+			if (dir > 0) {
+				free(offs);
 				return 0;
+			}
 			step = off + g1;
 			off += g2 > 0 ? g2 : 1;
 			ln_n = -1; /* break outer loop efficiently */
 		}
 		off = 0;
 	}
+	free(offs);
 	return ln_n < 0 ? 0 : 1;
 }
 
diff --git a/led.c b/led.c
index 7a124730..dcfddc46 100644
--- a/led.c
+++ b/led.c
@@ -47,7 +47,7 @@ static void file_index(struct lbuf *buf)
 	rset *rs = rset_smake(xacreg ? xacreg->s : reg, xic ? REG_ICASE : 0);
 	if (!rs)
 		return;
-	int subs[rs->grpcnt * 2];
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int));
 	sbuf_smake(ibuf, 1024)
 	for (n = 1; n <= acsb->s_n; n++)
 		if (acsb->s[n - 1] == '\n')
@@ -81,6 +81,7 @@ static void file_index(struct lbuf *buf)
 	sbuf_null(acsb)
 	free(ibuf->s);
 	rset_free(rs);
+	free(subs);
 }
 
 static char *kmap_map(int kmap, int c)
@@ -151,10 +152,10 @@ void led_render(char *s0, int cbeg, int cend)
 	int att_old = 0, atti = 0, cterm = cend - cbeg;
 	char *bound = NULL;
 	char **chrs = r->chrs;	/* chrs[i]: the i-th character in s0 */
-	int off[cterm+1];	/* off[i]: the character at screen position i */
-	int att[cterm+1];	/* att[i]: the attributes of i-th character */
-	int stt[cterm+1];	/* stt[i]: remap off indexes */
-	int ctt[cterm+1];	/* ctt[i]: cterm bound attrs */
+	int *off = emalloc((cterm+1) * sizeof(int));	/* off[i]: the character at screen position i */
+	int *att = emalloc((cterm+1) * sizeof(int));	/* att[i]: the attributes of i-th character */
+	int *stt = NULL;	/* stt[i]: remap off indexes */
+	int *ctt = NULL;	/* ctt[i]: cterm bound attrs */
 	int ctx = r->ctx;
 	off[cterm] = -1;
 	if (ctx < 0) {
@@ -176,6 +177,8 @@ void led_render(char *s0, int cbeg, int cend)
 		if (o >= 0 && r->cmax > cterm && r->pos[o] + r->wid[o] > cend)
 			while (off[i] == o)
 				off[ctx < 0 ? i++ : i--] = -1;
+		stt = emalloc((cterm+1) * sizeof(int));
+		ctt = emalloc((cterm+1) * sizeof(int));
 		for (i = 0, c = 0; i < cterm;) {
 			if ((o = off[i++]) >= 0) {
 				att[c++] = o;
@@ -258,6 +261,10 @@ void led_render(char *s0, int cbeg, int cend)
 		memcpy(chrs[n], r->nullhole, r->holelen);
 		r->holelen = 0;
 	}
+	free(off);
+	free(att);
+	free(stt);
+	free(ctt);
 }
 
 static int led_lastchar(char *s)
diff --git a/regex.c b/regex.c
index 700158e4..9d64262c 100644
--- a/regex.c
+++ b/regex.c
@@ -380,7 +380,15 @@ static int reg_comp(rcode *prog, char *re, int nsubs, int laidx, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; \
+free(pcs); \
+free(subs); \
+free(sdense); \
+free(_clist); \
+free(_nlist); \
+free(nsubs); \
+free(lb); \
+return state; } \
 
 #define newsub(init, copy) \
 if (freesub) { \
@@ -595,18 +603,19 @@ static int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, i
 	if (!*s)
 		return 0;
 	const char *sp = s, *_sp = s, *str;
-	int *pcs[prog->splits], *npc, *pc, *insts = prog->insts;
-	rsub *subs[prog->splits];
+	int *npc, *pc, *insts = prog->insts;
+	int **pcs = emalloc((prog->splits) * sizeof(int*));
+	rsub **subs = emalloc(prog->splits * sizeof(rsub*));
+	unsigned int *sdense = emalloc(prog->sparsesz * sizeof(unsigned int)), sparsesz = 0;
 	rsub *nsub, *s1, *matched = NULL, *freesub = NULL;
-	rthread _clist[prog->len], _nlist[prog->len];
+	rthread *_clist = emalloc(prog->len * sizeof(rthread)), *_nlist = emalloc(prog->len * sizeof(rthread));
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
-	const char *_subp[2], *lb[prog->laidx+1];
+	const char *_subp[2], **lb = emalloc(prog->laidx * sizeof(lb[0]));
 	int rsubsize = prog->presub, suboff = 0;
 	int cnt, spc, i, c, j, osubp = nsubp * sizeof(char*);
 	int si = 0, clistidx = 0, nlistidx, mcont = MATCH;
 	int eol_ch = flg & REG_NEWLINE ? '\n' : 0;
-	unsigned int sdense[prog->sparsesz], sparsesz = 0;
-	char nsubs[prog->sub];
+	char *nsubs = emalloc(prog->sub);
 	flg = prog->flg | flg;
 	for (i = 0; i < prog->laidx; i++)
 		lb[i] = NULL;
@@ -685,7 +694,7 @@ rset *rset_make(int n, char **re, int flg)
 /* return the index of the matching regular expression or -1 if none matches */
 int rset_find(rset *rs, char *s, int *grps, int flg)
 {
-	regmatch_t subs[rs->grpcnt+1];
+	regmatch_t *subs = emalloc((rs->grpcnt+1) * sizeof(regmatch_t));
 	regmatch_t *sub = subs+1;
 	if (re_pikevm(rs->regex, s, (const char**)sub, rs->grpcnt * 2, flg)) {
 		subs[0].rm_eo = NULL; /* make sure sub[-1] never matches */
@@ -702,10 +711,12 @@ int rset_find(rset *rs, char *s, int *grps, int flg)
 						grps[gi * 2 + 1] = -1;
 					}
 				}
+				free(subs);
 				return i;
 			}
 		}
 	}
+	free(subs);
 	return -1;
 }
 
diff --git a/ren.c b/ren.c
index 6a1f4ef2..2824b15b 100644
--- a/ren.c
+++ b/ren.c
@@ -252,13 +252,14 @@ int syn_blockhl;
 static int syn_initft(int fti, int n, char *name)
 {
 	int i = n, set = hls[i].set;
-	char *pats[hlslen];
+	char **pats = emalloc(hlslen * sizeof(char *));
 	for (; i < hlslen && hls[i].ft == name && hls[i].set == set; i++)
 		pats[i - n] = hls[i].pat;
 	ftmap[fti].setbidx = n;
 	ftmap[fti].ft = name;
 	ftmap[fti].rs = rset_make(i - n, pats, 0);
 	ftmap[fti].seteidx = i;
+	free(pats);
 	return i < hlslen && hls[i].ft == name && hls[i].set != set;
 }
 
@@ -306,7 +307,7 @@ void syn_highlight(int *att, char *s, int n)
 	int fti = ftidx, blockhl = syn_blockhl, blockca = -1;
 	re:;
 	rset *rs = ftmap[fti].rs;
-	int subs[rs->grpcnt * 2], *catt, *aign, sl, c;
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int)), *catt, *aign, sl, c;
 	int cend, sidx = 0, flg = 0, hl, j, i;
 	while ((sl = rset_find(rs, s + sidx, subs, flg)) >= 0) {
 		cend = 1;
@@ -352,15 +353,20 @@ void syn_highlight(int *att, char *s, int n)
 		flg = REG_NOTBOL;
 	}
 	fti++;
-	if (ftmidx > fti && ftmap[fti-1].ft == ftmap[fti].ft)
+	if (ftmidx > fti && ftmap[fti-1].ft == ftmap[fti].ft) {
+		free(subs);
 		goto re;
+	}
 	if (blockca >= 0 && SYN_BSSET(blockca) && !SYN_BESET(blockca) && last_scdir > 0)
 		syn_blockhl = -1;
-	if (syn_blockhl < 0 || blockhl < 0)
+	if (syn_blockhl < 0 || blockhl < 0) {
+		free(subs);
 		return;
+	}
 	for (j = 0; j < n; j++)
 		if (!att[j] || !SYN_BPSET(blockatt))
 			att[j] = blockatt;
+	free(subs);
 }
 
 char *syn_filetype(char *path)
@@ -404,9 +410,10 @@ int syn_addhl(char *reg, int id)
 
 void syn_init(void)
 {
-	char *pats[ftslen];
+	char **pats = emalloc(ftslen * sizeof(char *));
 	int i = 0;
 	for (; i < ftslen; i++)
 		pats[i] = fts[i].pat;
 	syn_ftrs = rset_make(i, pats, 0);
+	free(pats);
 }
diff --git a/vi.c b/vi.c
index b83a1df9..410158cc 100644
--- a/vi.c
+++ b/vi.c
@@ -141,7 +141,8 @@ static void vi_drawrow(int row)
 			vi_rshift = 0;
 		if (row != xrow+1 || !c || *c == '\n')
 			goto skip;
-		char tmp[xcols+3], snum[32];
+		char *tmp = emalloc(xcols+3);
+		char *snum = emalloc(32);
 		memset(tmp, ' ', xcols+1);
 		tmp[xcols+1] = '\n';
 		tmp[xcols+2] = '\0';
@@ -166,6 +167,8 @@ static void vi_drawrow(int row)
 		restore(xorder)
 		restore(syn_blockhl)
 		restore(xtd)
+		free(tmp);
+		free(snum);
 		return;
 	}
 	s = lbuf_get(xb, row);
@@ -1269,10 +1272,11 @@ void vi(int init)
 				if (!(ln = lbuf_get(xb, xrow)))
 					break;
 				ln += xoff;
-				char buf[strlen(ln)+4];
+				char *buf = emalloc(strlen(ln)+4);
 				strcpy(buf, ":e ");
 				strcpy(buf+3, ln);
 				term_push(buf, strlen(ln)+3);
+				free(buf);
 				break; }
 			case TK_CTL('n'):
 				vi_cndir = vi_arg ? -vi_cndir : vi_cndir;
@@ -1402,7 +1406,7 @@ void vi(int init)
 					strcpy(vi_msg, "arg2:(0|#)");
 					vi_drawmsg();
 					cs = vi_curword(xb, xrow, xoff, vi_prefix());
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, ".,.+");
 					char *buf1 = itoa(vi_arg, buf+4);
 					strcat(buf1, "s/");
@@ -1412,10 +1416,11 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_enprompt(":", buf, &n);
+					free(buf);
 					goto do_excmd; }
 				case 'r': {
 					cs = vi_curword(xb, xrow, xoff, vi_arg);
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, "%s/");
 					if (cs) {
 						strcat(buf, cs);
@@ -1423,6 +1428,7 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_enprompt(":", buf, &n);
+					free(buf);
 					goto do_excmd; }
 				default:
 					term_dec()
diff --git a/vi.h b/vi.h
index 1bef0600..d2ed5e65 100644
--- a/vi.h
+++ b/vi.h
@@ -473,7 +473,7 @@ extern const int ftslen;
 struct highlight {
 	char *ft;		/* the filetype of this pattern */
 	char *pat;		/* regular expression */
-	int *att;		/* attributes of the matched groups */
+	int att[16];		/* attributes of the matched groups */
 	unsigned char set;	/* subset index */
 	unsigned char id;	/* id of this hl */
 };
