#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: 'J'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: conf.c
EXINIT="rcm:|sc! J|vis 6J261;32;62c q|e[f!]?!?|f[-+><tdp]?|inc|i|sc!?|vs|sp
.
Jvis 4Jwq" $VI -e 'conf.c'

# Patch: ex.c
EXINIT="rcm:|sc! J|vis 6J1578a /* window management functions */
static void curwin_save(void)
{
	if (curwin) {
		curwin->row = xrow;
		curwin->off = xoff;
		curwin->top = xtop;
		curwin->left = xleft;
		curwin->buf = ex_buf;
	}
}

static void curwin_load(void)
{
	if (curwin) {
		/* Save old buffer state BEFORE loading new window positions */
		if (curwin->buf != ex_buf) {
			exbuf_save(ex_buf)
			ex_buf = curwin->buf;
			xtd = ex_buf->td;
			syn_setft(xb_ft);
		}
		/* Load window-specific position (not buffer position) */
		xrow = curwin->row;
		xoff = curwin->off;
		xtop = curwin->top;
		xleft = curwin->left;
	}
}

void win_init(void)
{
	if (!wins) {
		wins = emalloc(sizeof(struct win));
		wins->buf = ex_buf;
		wins->y = 0;
		wins->x = 0;
		wins->h = xrows;
		wins->w = xcols;
		wins->row = 0;
		wins->off = 0;
		wins->top = 0;
		wins->left = 0;
		wins->vsplit = 0;
		wins->next = wins;  /* circular list */
		curwin = wins;
		nwins = 1;
	}
}

void win_size(void)
{
	/* recalculate window sizes after terminal resize */
	struct win *w = wins;
	if (!w || nwins == 1) {
		if (w) {
			w->h = xrows;
			w->w = xcols;
			w->y = 0;
			w->x = 0;
		}
		return;
	}
	/* for multiple windows, redistribute proportionally */
	int y = 0, x = 0;
	/* check if this is a vertical split layout */
	int is_vsplit = wins->next->vsplit;
	do {
		if (!is_vsplit) {
			/* horizontal split: stacked vertically */
			w->h = (xrows - (nwins - 1)) / nwins;
			w->w = xcols;
			w->y = y;
			w->x = 0;
			y += w->h + 1;  /* +1 for separator */
		} else {
			/* vertical split: side by side */
			w->w = (xcols - (nwins - 1)) / nwins;
			w->h = xrows;
			w->x = x;
			w->y = 0;
			x += w->w + 1;  /* +1 for separator */
		}
		w = w->next;
	} while (w != wins);
}

void win_switch(struct win *w)
{
	if (w && w != curwin) {
		curwin_save();
		curwin = w;
		curwin_load();
	}
}

void win_close(void)
{
	struct win *w, *prev, *closing;
	if (nwins <= 1)
		return;
	closing = curwin;
	/* find previous window in circular list */
	prev = curwin;
	while (prev->next != curwin)
		prev = prev->next;
	/* find adjacent window to absorb closed window's space */
	w = wins;
	do {
		if (w != closing) {
			/* horizontal neighbors: same y and h */
			if (w->y == closing->y && w->h == closing->h) {
				if (w->x + w->w + 1 == closing->x) {
					/* w is LEFT of closing, expand right */
					w->w += closing->w + 1;
					break;
				}
				if (closing->x + closing->w + 1 == w->x) {
					/* w is RIGHT of closing, expand left */
					w->x = closing->x;
					w->w += closing->w + 1;
					break;
				}
			}
			/* vertical neighbors: same x and w */
			if (w->x == closing->x && w->w == closing->w) {
				if (w->y + w->h + 1 == closing->y) {
					/* w is ABOVE closing, expand down */
					w->h += closing->h + 1;
					break;
				}
				if (closing->y + closing->h + 1 == w->y) {
					/* w is BELOW closing, expand up */
					w->y = closing->y;
					w->h += closing->h + 1;
					break;
				}
			}
		}
		w = w->next;
	} while (w != wins);
	/* remove curwin from list */
	prev->next = closing->next;
	if (wins == closing)
		wins = closing->next;
	curwin = prev->next;
	free(closing);
	nwins--;
	/* single window fills entire screen */
	if (nwins == 1) {
		wins->y = 0;
		wins->x = 0;
		wins->h = xrows;
		wins->w = xcols;
	}
	curwin_load();
}

void *win_split(int vertical, char *arg)
{
	struct win *newwin;
	int newh, neww;
	if (curwin->h < 4 || curwin->w < 10)
		return \"window too small\";

	newwin = emalloc(sizeof(struct win));
	if (vertical) {
		/* vertical split: new window on right */
		neww = curwin->w / 2;
		newwin->y = curwin->y;
		newwin->x = curwin->x + neww + 1;  /* +1 for separator */
		newwin->h = curwin->h;
		newwin->w = curwin->w - neww - 1;
		curwin->w = neww;
	} else {
		/* horizontal split: new window below */
		newh = curwin->h / 2;
		newwin->y = curwin->y + newh + 1;  /* +1 for separator */
		newwin->x = curwin->x;
		newwin->h = curwin->h - newh - 1;
		newwin->w = curwin->w;
		curwin->h = newh;
	}

	/* copy cursor state from current window */
	curwin_save();
	newwin->row = curwin->row;
	newwin->off = curwin->off;
	newwin->top = curwin->top;
	newwin->left = curwin->left;
	newwin->vsplit = vertical;

	/* handle buffer for new window */
	if (arg && *arg) {
		/* save original buffer for current window */
		struct buf *origbuf = curwin->buf;
		/* open specified file */
		int fd = bufs_find(arg, strlen(arg));
		if (fd >= 0) {
			newwin->buf = &bufs[fd];
		} else {
			bufs_switch(bufs_open(arg, strlen(arg)));
			newwin->buf = ex_buf;
			int f = open(xb_path, O_RDONLY);
			if (f >= 0) {
				lbuf_rd(xb, f, 0, lbuf_len(xb));
				close(f);
			}
			ex_bufpostfix(ex_buf, arg[0]);
		}
		/* restore current window's buffer and global state */
		curwin->buf = origbuf;
		ex_buf = origbuf;
		exbuf_load(ex_buf)
		syn_setft(xb_ft);
		newwin->row = 0;
		newwin->off = 0;
		newwin->top = 0;
		newwin->left = 0;
	} else {
		/* same buffer as current window */
		newwin->buf = curwin->buf;
	}

	/* insert into circular list after current window */
	newwin->next = curwin->next;
	curwin->next = newwin;
	nwins++;

	return NULL;
}

.
Jvis 4J1415dJvis 6J1393a 	{\"sp\", ec_split},
.
Jvis 4Jvis 6J1389a 	EO(vis),
	{\"vs\", ec_vsplit},
.
Jvis 4Jvis 6J1355a 	{\"eq\", ec_equalize},
.
Jvis 4Jvis 6J1328a static void *ec_split(char *loc, char *cmd, char *arg)
{
	return win_split(0, arg);
}

static void *ec_vsplit(char *loc, char *cmd, char *arg)
{
	return win_split(1, arg);
}

static void *ec_equalize(char *loc, char *cmd, char *arg)
{
	struct win *w, **group;
	int ngroup = 0, i, j;
	if (nwins <= 1)
		return NULL;
	group = emalloc(nwins * sizeof(struct win *));
	/* try horizontal grouping: same y and h as curwin */
	w = wins;
	do {
		if (w->y == curwin->y && w->h == curwin->h)
			group[ngroup++] = w;
		w = w->next;
	} while (w != wins);
	if (ngroup > 1) {
		/* sort by x */
		for (i = 0; i < ngroup - 1; i++)
			for (j = i + 1; j < ngroup; j++)
				if (group[j]->x < group[i]->x) {
					struct win *tmp = group[i];
					group[i] = group[j];
					group[j] = tmp;
				}
		/* check contiguity */
		int contiguous = 1;
		for (i = 0; i < ngroup - 1; i++) {
			if (group[i]->x + group[i]->w + 1 != group[i+1]->x) {
				contiguous = 0;
				break;
			}
		}
		if (contiguous) {
			/* redistribute width evenly */
			int total = group[ngroup-1]->x + group[ngroup-1]->w - group[0]->x;
			int new_w = (total - (ngroup - 1)) / ngroup;
			int extra = (total - (ngroup - 1)) % ngroup;
			int x = group[0]->x;
			for (i = 0; i < ngroup; i++) {
				group[i]->x = x;
				group[i]->w = new_w + (i < extra ? 1 : 0);
				x += group[i]->w + 1;
			}
			free(group);
			return NULL;
		}
	}
	/* try vertical grouping: same x and w as curwin */
	ngroup = 0;
	w = wins;
	do {
		if (w->x == curwin->x && w->w == curwin->w)
			group[ngroup++] = w;
		w = w->next;
	} while (w != wins);
	if (ngroup > 1) {
		/* sort by y */
		for (i = 0; i < ngroup - 1; i++)
			for (j = i + 1; j < ngroup; j++)
				if (group[j]->y < group[i]->y) {
					struct win *tmp = group[i];
					group[i] = group[j];
					group[j] = tmp;
				}
		/* check contiguity */
		int contiguous = 1;
		for (i = 0; i < ngroup - 1; i++) {
			if (group[i]->y + group[i]->h + 1 != group[i+1]->y) {
				contiguous = 0;
				break;
			}
		}
		if (contiguous) {
			/* redistribute height evenly */
			int total = group[ngroup-1]->y + group[ngroup-1]->h - group[0]->y;
			int new_h = (total - (ngroup - 1)) / ngroup;
			int extra = (total - (ngroup - 1)) % ngroup;
			int y = group[0]->y;
			for (i = 0; i < ngroup; i++) {
				group[i]->y = y;
				group[i]->h = new_h + (i < extra ? 1 : 0);
				y += group[i]->h + 1;
			}
			free(group);
			return NULL;
		}
	}
	free(group);
	return NULL;
}

.
Jvis 4Jvis 6J558c 	if (!xquit)
		xquit = 1;
.
Jvis 4Jvis 6J555c 	/* q! always force quits */
	if (strchr(cmd, '!')) {
		xquit = -1;
		return NULL;
	}
	/* if multiple windows, close current window */
	if (!(xvis & 4) && nwins > 1) {
		win_close();
		return NULL;
	}
	/* single window: check for modified buffers and quit */
	for (int i = 0; i < xbufcur; i++)
.
Jvis 4Jvis 6J159a 	/* update current window's buffer reference */
	if (curwin)
		curwin->buf = ex_buf;
.
Jvis 4Jvis 6J98a 	/* update current window's buffer reference */
	if (curwin)
		curwin->buf = ex_buf;
.
Jvis 4Jvis 6J43a struct win *wins;		/* head of window list */
struct win *curwin;		/* current active window */
int nwins;			/* number of windows */
.
Jvis 4Jwq" $VI -e 'ex.c'

# Patch: led.c
EXINIT="rcm:|sc! J|vis 6J611;46;46c , ai_max
.
Jvis 4Jvis 6J588a 			if (curwin)
				curwin->buf = ex_buf;
.
Jvis 4Jvis 6J568;46;46c , ai_max
.
Jvis 4Jvis 6J509;46;46c , ai_max
.
Jvis 4Jvis 6J386;23;24c winx
.
Jvis 4Jvis 6J384c 			winx + vi_lncol, xleft, xleft + winw - vi_lncol)
.
Jvis 4Jvis 6J377;25;55c winx + vi_lncol, xleft, xleft + winw
.
Jvis 4Jvis 6J368;15;16c winx
.
Jvis 4Jvis 6J366;22;27c winh
.
Jvis 4Jvis 6J364a 	/* window offset for vsplit (not for prompts) */
	int winx = (ai_max >= 0 && curwin) ? curwin->x : 0;
	int winw = (ai_max >= 0 && curwin) ? curwin->w : xcols;
	int winh = (ai_max >= 0 && curwin) ? curwin->h : xrows;
.
Jvis 4Jvis 6J363;77;77c , int ai_max
.
Jvis 4Jvis 6J311,312c 	led_crender(r->s, -1, winx + vi_lncol, xleft, xleft + winw - vi_lncol);
	term_pos(-1, winx + led_pos(r->s, pos) + vi_lncol);
.
Jvis 4Jvis 6J308,309c 	if (pos >= xleft + winw || pos < xleft)
		xleft = pos < winw ? 0 : pos - winw / 2;
.
Jvis 4Jvis 6J289a 	/* window offset for vsplit (not for prompts) */
	int winx = (ai_max >= 0 && curwin) ? curwin->x : 0;
	int winw = (ai_max >= 0 && curwin) ? curwin->w : xcols;
.
Jvis 4Jvis 6J97;17;22c ww
.
Jvis 4Jvis 6J95a 	int ww = curwin ? curwin->w : xcols;
.
Jvis 4Jwq" $VI -e 'led.c'

# Patch: vi.c
EXINIT="rcm:|sc! J|vis 6J1772;11;23c (curwin ? curwin->y : 0) + xrow - xtop, (curwin ? curwin->x : 0) +
.
Jvis 4Jvis 6J1755;53;58c win_height()
.
Jvis 4Jvis 6J1747,1748c 		} else if (*vi_word && (ooff != xoff || vi_mod & 2)
				&& xrow+1 < xtop + win_height()) {
.
Jvis 4Jvis 6J1745;34;34c  {
.
Jvis 4Jvis 6J1743c 		/* save cursor position to current window */
		if (curwin) {
			curwin->row = xrow;
			curwin->off = xoff;
			curwin->top = xtop;
			curwin->left = xleft;
		}
		/* always do full redraw when multiple windows are active */
		if (nwins > 1) {
			vi_draw_allwins();
		} else if (vi_mod & 1 || xleft != oleft
.
Jvis 4Jvis 6J1700,1701c 		{ int _ww = win_width();
		if (vi_col >= xleft + _ww || vi_col < xleft)
			xleft = vi_col < _ww ? 0 : vi_col - _ww / 2; }
.
Jvis 4Jvis 6J1538;10;10c  }
.
Jvis 4Jvis 6J1535a 				if (xrows != orows || xcols != ocols)
					win_size();
.
Jvis 4Jvis 6J1528c 			case TK_CTL('l'): {
				int orows = xrows, ocols = xcols;
.
Jvis 4Jvis 6J1399a 				case 'c':
					/* switch to next window */
					if (nwins > 1) {
						curwin->row = xrow;
						curwin->off = xoff;
						curwin->top = xtop;
						curwin->left = xleft;
						win_switch(curwin->next);
						vi_mod |= 1;
					}
					break;
				case 'd':
					/* close current window */
					if (nwins > 1) {
						win_close();
						vi_mod |= 1;
					}
					break;
.
Jvis 4Jvis 6J1281,1282c 				if (xtop < lbuf_len(xb) - win_height())
					xtop = MIN(lbuf_len(xb) - win_height(), xtop + n);
.
Jvis 4Jvis 6J1279;36;41c win_height()
.
Jvis 4Jvis 6J1267;36;41c win_height()
.
Jvis 4Jvis 6J1248;39;44c win_height()
.
Jvis 4Jvis 6J1243;40;45c win_height()
.
Jvis 4Jvis 6J1195,1196c 		if (nwins > 1) {
			if (curwin) {
				curwin->row = xrow;
				curwin->off = xoff;
				curwin->top = xtop;
				curwin->left = xleft;
			}
			vi_draw_allwins();
		} else
			vi_drawagain(xtop);
		term_pos((curwin ? curwin->y : 0) + xrow - xtop,
			(curwin ? curwin->x : 0) + led_pos(lbuf_get(xb, xrow), vi_col));
.
Jvis 4Jvis 6J1192a 		win_init();
.
Jvis 4Jvis 6J1181,1185c 	xtop = xtop - _wh / 2 > xrow ? \\
			MAX(0, xrow - _wh / 2) : xrow; \\
if (xtop + _wh <= xrow) \\
	xtop = xtop + _wh + _wh / 2 <= xrow ? \\
			xrow - _wh / 2 : xrow - _wh + 1; } \\
.
Jvis 4Jvis 6J1177a { int _wh = win_height(); \\
.
Jvis 4Jvis 6J1114;25;30c win_height()
.
Jvis 4Jvis 6J1028;21;26c win_height()
.
Jvis 4Jvis 6J796,797c 		else if (*row < xtop || *row >= xtop + win_height() - 1)
			xtop = MAX(0, *row - win_height() / 2);
.
Jvis 4Jvis 6J783;23;28c win_height()
.
Jvis 4Jvis 6J750;23;28c win_height()
.
Jvis 4Jvis 6J374;20;25c win_height()
.
Jvis 4Jvis 6J371;20;25c win_height()
.
Jvis 4Jvis 6J238;13;14c w
.
Jvis 4Jvis 6J236;21;22c w
.
Jvis 4Jvis 6J234;14;15c w
.
Jvis 4Jvis 6J230c 	int wrows = win_height();
	term_pos(curwin ? curwin->y : 0, 0);
.
Jvis 4Jvis 6J225a /* draw all windows and separators */
static void vi_draw_allwins(void)
{
	struct win *w = wins;
	struct win *saved = curwin;
	/* draw each window */
	do {
		curwin = w;
		/* temporarily load window state */
		xrow = w->row;
		xoff = w->off;
		xtop = w->top;
		xleft = w->left;
		if (w->buf != ex_buf) {
			ex_buf = w->buf;
			syn_setft(xb_ft);
		}
		syn_scdir(0);
		for (int i = xtop; i < xtop + w->h; i++)
			vi_drawrow(i);
		/* draw separators based on actual adjacency */
		struct win *w2 = wins;
		do {
			if (w2 != w) {
				/* vertical separator: w2 is to the right of w */
				if (w2->x == w->x + w->w + 1) {
					int y1 = MAX(w->y, w2->y);
					int y2 = MIN(w->y + w->h, w2->y + w2->h);
					if (y1 < y2)
						vi_draw_vsep(w->x + w->w, y1, y2 - y1);
				}
				/* horizontal separator: w2 is below w */
				if (w2->y == w->y + w->h + 1) {
					int x1 = MAX(w->x, w2->x);
					int x2 = MIN(w->x + w->w, w2->x + w2->w);
					if (x1 < x2)
						vi_draw_hsep(w->y + w->h, x1, x2 - x1);
				}
			}
			w2 = w2->next;
		} while (w2 != wins);
		w = w->next;
	} while (w != wins);
	/* restore current window */
	curwin = saved;
	xrow = saved->row;
	xoff = saved->off;
	xtop = saved->top;
	xleft = saved->left;
	if (saved->buf != ex_buf) {
		ex_buf = saved->buf;
		syn_setft(xb_ft);
	}
}

.
Jvis 4Jvis 6J222;19;20c w
.
Jvis 4Jvis 6J220a 	int wrows = win_height();
.
Jvis 4Jvis 6J214c 	led_crender(s, scrrow, curwin ? curwin->x : 0, xleft, xleft + wcols)
.
Jvis 4Jvis 6J209;25;36c scrrow, curwin ? curwin->x :
.
Jvis 4Jvis 6J206;28;39c scrrow, (curwin ? curwin->x : 0) +
.
Jvis 4Jvis 6J195c 		led_crender(s, scrrow, (curwin ? curwin->x : 0) + l1, xleft, xleft + wcols - l1)
.
Jvis 4Jvis 6J163;25;44c scrrow, curwin ? curwin->x : 0, 0, w
.
Jvis 4Jvis 6J143,146c 		char tmp[wcols+3], snum[32];
		memset(tmp, ' ', wcols+1);
		tmp[wcols+1] = '\\n';
		tmp[wcols+2] = '\\0';
.
Jvis 4Jvis 6J139;20;21c w
.
Jvis 4Jvis 6J133;18;31c scrrow ==
.
Jvis 4Jvis 6J130a 	int wrows = win_height();
	int wcols = win_width();
	int scrrow = win_scrrow(row);
.
Jvis 4Jvis 6J127a /* calculate screen row for buffer row in current window */
static int win_scrrow(int row)
{
	return curwin ? curwin->y + (row - xtop) : row - xtop;
}

/* calculate effective window width */
static int win_width(void)
{
	return curwin ? curwin->w : xcols;
}

/* calculate effective window height (rows visible) */
static int win_height(void)
{
	return curwin ? curwin->h : xrows;
}

.
Jvis 4Jvis 6J120;10;11c w
.
Jvis 4Jvis 6J104a /* draw horizontal separator line at screen row, from x for w columns */
static void vi_draw_hsep(int row, int x, int w)
{
	term_pos(row, x);
	for (int i = 0; i < w; i++)
		term_chr('-');
}

/* draw vertical separator line at screen column */
static void vi_draw_vsep(int col, int y, int h)
{
	for (int i = 0; i < h; i++) {
		term_pos(y + i, col);
		term_chr('|');
	}
}

.
Jvis 4Jwq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! J|vis 6J409a 
/* window management for splits */
struct win {
	struct buf *buf;		/* buffer displayed in this window */
	int y, x;			/* top-left screen position */
	int h, w;			/* height and width */
	int row, off, top;		/* cursor position within window */
	int left;			/* horizontal scroll offset */
	int vsplit;			/* 1 if created by vertical split */
	struct win *next;		/* next window (circular list) */
};
extern struct win *wins;		/* head of window list */
extern struct win *curwin;		/* current active window */
extern int nwins;			/* number of windows */
void win_init(void);
void win_size(void);
void win_switch(struct win *w);
void win_close(void);
void *win_split(int vertical, char *arg);
.
Jvis 4Jwq" $VI -e 'vi.h'
