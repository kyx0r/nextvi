#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: 'J'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: conf.c
EXINIT="rcm:|sc! \\\\J|vis 6J%;f> \\\\(\\\\(\\\\?:\\\\\\\\\\\\\\\\\\\\|\\\\.\\\\*\\\\?\\\\(\\\\?:\\\\(\\\\?<\\\\^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\|\\\\|\\\\\$\\\\)\\\\)\\\\*\\\\(\\\\?:<\\\\.\\\\*\\\\?\\\\(\\\\?:\\\\(\\\\?<\\\\^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)<\\\\|\\\\\$\\\\)\\\\|>\\\\.\\\\*\\\\?\\\\(\\\\?:\\\\(\\\\?<\\\\^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)>\\\\|\\\\\$\\\\)\\\\)\\\\?\\\\[\\\\.\\\\\$\\\\]\\\\?\\\\(\\\\?:'\\\\[a-z'\`\\\\[\\\\\\\\\\\\\\\\\\\\]\\\\*\\\\]\\\\)\\\\?\\\\\\\\
\\\\(\\\\[0-9\\\\]\\\\*\\\\)\\\\?\\\\)\\\\(\\\\?:\\\\(\\\\[-\\\\*-\\\\+/%\\\\]\\\\)\\\\(\\\\[0-9\\\\]\\\\+\\\\)\\\\)\\\\*\\\\(\\\\?:\\\\\\\\\\\\\\\\\\\\|\\\\.\\\\*\\\\?\\\\(\\\\?:\\\\(\\\\?<\\\\^\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\|\\\\|\\\\\$\\\\)\\\\)\\\\*\\\\[ \\\\\\\\t\\\\]\\\\*\\\\)\\\\*\\\\)\\\\\\\\
\\\\(\\\\(pac\\\\|pr\\\\|ai\\\\|ish\\\\|err\\\\|ic\\\\|grp\\\\|mpt\\\\|rcm\\\\|shape\\\\|seq\\\\|ts\\\\|td\\\\|order\\\\|hl\\\\[lwpr\\\\]\\\\?\\\\|left\\\\|lim\\\\|led\\\\|vis\\\\)\\\\\\\\J??!.-5,.+5p\Jp FAIL line 261\Jq!J;=
J.+3;47;77c q|e[f!]?!?|f[-+><tdp]?|inc|i|sc!?|vs|sp
.
Jvis 4Jwq" $VI -e 'conf.c'

# Patch: ex.c
EXINIT="rcm:|sc! \\\\J|vis 6J%;f> struct buf tempbufs\\\\[2\\\\];		/\\\\* temporary buffers, for internal use \\\\*/
struct buf \\\\*ex_buf;		/\\\\* current buffer \\\\*/
struct buf \\\\*ex_pbuf;		/\\\\* prev buffer \\\\*/J??!.-5,.+5p\Jp FAIL line 44\Jq!J;=
J.+2a struct win *wins;		/* head of window list */
struct win *curwin;		/* current active window */
int nwins;			/* number of windows */
.
J.,$;f+ 		ex_buf = &bufs\\\\[idx\\\\];
	\\\\}
	exbuf_load\\\\(ex_buf\\\\)J??!.-5,.+5p\Jp FAIL line 100\Jq!J;=
J.+2a 	/* update current window's buffer reference */
	if (curwin)
		curwin->buf = ex_buf;
.
J.,$;f+ 	\\\\}
	exbuf_load\\\\(ex_buf\\\\)
	syn_setft\\\\(xb_ft\\\\);J??!.-5,.+5p\Jp FAIL line 161\Jq!J;=
J.+2a 	/* update current window's buffer reference */
	if (curwin)
		curwin->buf = ex_buf;
.
J.,$;f+ 
static void \\\\*ec_quit\\\\(char \\\\*loc, char \\\\*cmd, char \\\\*arg\\\\)
\\\\{J??!.-5,.+5p\Jp FAIL line 575\Jq!J;=
J.+3c 	/* q! always force quits */
	if (strchr(cmd, '!')) {
		xquit = -1;
		return NULL;
	}
	/* if multiple windows, close current window */
	if (!(xvis & 4) && nwins > 1) {
		win_close();
		return NULL;
	}
	/* single window: check for modified buffers and quit */
	for (int i = 0; i < xbufcur; i++)
.
J.,$;f+ 		if \\\\(\\\\(xquit < 0 \\\\|\\\\| xgrec < 2\\\\) && bufs\\\\[i\\\\]\\\\.lb->modified\\\\)
			return \"buffers modified\";J??!.-5,.+5p\Jp FAIL line 578\Jq!J;=
J.+2c 	if (!xquit)
		xquit = 1;
.
J.,$;f+ 	return NULL;
\\\\)
J??!.-5,.+5p\Jp FAIL line 1354\Jq!J;=
J.+2a static void *ec_split(char *loc, char *cmd, char *arg)
{
	return win_split(0, arg);
}

static void *ec_vsplit(char *loc, char *cmd, char *arg)
{
	return win_split(1, arg);
}

static void *ec_equalize(char *loc, char *cmd, char *arg)
{
	struct win *w, **group;
	int ngroup = 0, i, j;
	if (nwins <= 1)
		return NULL;
	group = emalloc(nwins * sizeof(struct win *));
	/* try horizontal grouping: same y and h as curwin */
	w = wins;
	do {
		if (w->y == curwin->y && w->h == curwin->h)
			group[ngroup++] = w;
		w = w->next;
	} while (w != wins);
	if (ngroup > 1) {
		/* sort by x */
		for (i = 0; i < ngroup - 1; i++)
			for (j = i + 1; j < ngroup; j++)
				if (group[j]->x < group[i]->x) {
					struct win *tmp = group[i];
					group[i] = group[j];
					group[j] = tmp;
				}
		/* check contiguity */
		int contiguous = 1;
		for (i = 0; i < ngroup - 1; i++) {
			if (group[i]->x + group[i]->w + 1 != group[i+1]->x) {
				contiguous = 0;
				break;
			}
		}
		if (contiguous) {
			/* redistribute width evenly */
			int total = group[ngroup-1]->x + group[ngroup-1]->w - group[0]->x;
			int new_w = (total - (ngroup - 1)) / ngroup;
			int extra = (total - (ngroup - 1)) % ngroup;
			int x = group[0]->x;
			for (i = 0; i < ngroup; i++) {
				group[i]->x = x;
				group[i]->w = new_w + (i < extra ? 1 : 0);
				x += group[i]->w + 1;
			}
			free(group);
			return NULL;
		}
	}
	/* try vertical grouping: same x and w as curwin */
	ngroup = 0;
	w = wins;
	do {
		if (w->x == curwin->x && w->w == curwin->w)
			group[ngroup++] = w;
		w = w->next;
	} while (w != wins);
	if (ngroup > 1) {
		/* sort by y */
		for (i = 0; i < ngroup - 1; i++)
			for (j = i + 1; j < ngroup; j++)
				if (group[j]->y < group[i]->y) {
					struct win *tmp = group[i];
					group[i] = group[j];
					group[j] = tmp;
				}
		/* check contiguity */
		int contiguous = 1;
		for (i = 0; i < ngroup - 1; i++) {
			if (group[i]->y + group[i]->h + 1 != group[i+1]->y) {
				contiguous = 0;
				break;
			}
		}
		if (contiguous) {
			/* redistribute height evenly */
			int total = group[ngroup-1]->y + group[ngroup-1]->h - group[0]->y;
			int new_h = (total - (ngroup - 1)) / ngroup;
			int extra = (total - (ngroup - 1)) % ngroup;
			int y = group[0]->y;
			for (i = 0; i < ngroup; i++) {
				group[i]->y = y;
				group[i]->h = new_h + (i < extra ? 1 : 0);
				y += group[i]->h + 1;
			}
			free(group);
			return NULL;
		}
	}
	free(group);
	return NULL;
}

.
J.,$;f+ 	EO\\\\(err\\\\),
	\\\\{\"ef!\", ec_fuzz\\\\},
	\\\\{\"ef\", ec_fuzz\\\\},J??!.-5,.+5p\Jp FAIL line 1384\Jq!J;=
J.+2a 	{\"eq\", ec_equalize},
.
J.,$;f+ 	\\\\{\"uz\", ec_setenc\\\\},
	\\\\{\"ub\", ec_setenc\\\\},
	\\\\{\"u\", ec_undoredo\\\\},J??!.-5,.+5p\Jp FAIL line 1418\Jq!J;=
J.+2a 	EO(vis),
	{\"vs\", ec_vsplit},
.
J.,$;f+ 	EO\\\\(seq\\\\),
	\\\\{\"sc!\", ec_specials\\\\},
	\\\\{\"sc\", ec_specials\\\\},J??!.-5,.+5p\Jp FAIL line 1422\Jq!J;=
J.+2a 	{\"sp\", ec_split},
.
J.,$;f+ 	EO\\\\(left\\\\),
	EO\\\\(lim\\\\),
	EO\\\\(led\\\\),J??!.-5,.+5p\Jp FAIL line 1444\Jq!J;=
J.+3dJ.,$;f+ 	xgrec--;
\\\\}
J??!.-5,.+5p\Jp FAIL line 1599\Jq!J;=
J.+2a /* window management functions */
static void curwin_save(void)
{
	if (curwin) {
		curwin->row = xrow;
		curwin->off = xoff;
		curwin->top = xtop;
		curwin->left = xleft;
		curwin->buf = ex_buf;
	}
}

static void curwin_load(void)
{
	if (curwin) {
		/* Save old buffer state BEFORE loading new window positions */
		if (curwin->buf != ex_buf) {
			exbuf_save(ex_buf)
			ex_buf = curwin->buf;
			xtd = ex_buf->td;
			syn_setft(xb_ft);
		}
		/* Load window-specific position (not buffer position) */
		xrow = curwin->row;
		xoff = curwin->off;
		xtop = curwin->top;
		xleft = curwin->left;
	}
}

void win_init(void)
{
	if (!wins) {
		wins = emalloc(sizeof(struct win));
		wins->buf = ex_buf;
		wins->y = 0;
		wins->x = 0;
		wins->h = xrows;
		wins->w = xcols;
		wins->row = 0;
		wins->off = 0;
		wins->top = 0;
		wins->left = 0;
		wins->vsplit = 0;
		wins->next = wins;  /* circular list */
		curwin = wins;
		nwins = 1;
	}
}

void win_size(void)
{
	/* recalculate window sizes after terminal resize */
	struct win *w = wins;
	if (!w || nwins == 1) {
		if (w) {
			w->h = xrows;
			w->w = xcols;
			w->y = 0;
			w->x = 0;
		}
		return;
	}
	/* for multiple windows, redistribute proportionally */
	int y = 0, x = 0;
	/* check if this is a vertical split layout */
	int is_vsplit = wins->next->vsplit;
	do {
		if (!is_vsplit) {
			/* horizontal split: stacked vertically */
			w->h = (xrows - (nwins - 1)) / nwins;
			w->w = xcols;
			w->y = y;
			w->x = 0;
			y += w->h + 1;  /* +1 for separator */
		} else {
			/* vertical split: side by side */
			w->w = (xcols - (nwins - 1)) / nwins;
			w->h = xrows;
			w->x = x;
			w->y = 0;
			x += w->w + 1;  /* +1 for separator */
		}
		w = w->next;
	} while (w != wins);
}

void win_switch(struct win *w)
{
	if (w && w != curwin) {
		curwin_save();
		curwin = w;
		curwin_load();
	}
}

void win_close(void)
{
	struct win *w, *prev, *closing;
	if (nwins <= 1)
		return;
	closing = curwin;
	/* find previous window in circular list */
	prev = curwin;
	while (prev->next != curwin)
		prev = prev->next;
	/* find adjacent window to absorb closed window's space */
	w = wins;
	do {
		if (w != closing) {
			/* horizontal neighbors: same y and h */
			if (w->y == closing->y && w->h == closing->h) {
				if (w->x + w->w + 1 == closing->x) {
					/* w is LEFT of closing, expand right */
					w->w += closing->w + 1;
					break;
				}
				if (closing->x + closing->w + 1 == w->x) {
					/* w is RIGHT of closing, expand left */
					w->x = closing->x;
					w->w += closing->w + 1;
					break;
				}
			}
			/* vertical neighbors: same x and w */
			if (w->x == closing->x && w->w == closing->w) {
				if (w->y + w->h + 1 == closing->y) {
					/* w is ABOVE closing, expand down */
					w->h += closing->h + 1;
					break;
				}
				if (closing->y + closing->h + 1 == w->y) {
					/* w is BELOW closing, expand up */
					w->y = closing->y;
					w->h += closing->h + 1;
					break;
				}
			}
		}
		w = w->next;
	} while (w != wins);
	/* remove curwin from list */
	prev->next = closing->next;
	if (wins == closing)
		wins = closing->next;
	curwin = prev->next;
	free(closing);
	nwins--;
	/* single window fills entire screen */
	if (nwins == 1) {
		wins->y = 0;
		wins->x = 0;
		wins->h = xrows;
		wins->w = xcols;
	}
	curwin_load();
}

void *win_split(int vertical, char *arg)
{
	struct win *newwin;
	int newh, neww;
	if (curwin->h < 4 || curwin->w < 10)
		return \"window too small\";

	newwin = emalloc(sizeof(struct win));
	if (vertical) {
		/* vertical split: new window on right */
		neww = curwin->w / 2;
		newwin->y = curwin->y;
		newwin->x = curwin->x + neww + 1;  /* +1 for separator */
		newwin->h = curwin->h;
		newwin->w = curwin->w - neww - 1;
		curwin->w = neww;
	} else {
		/* horizontal split: new window below */
		newh = curwin->h / 2;
		newwin->y = curwin->y + newh + 1;  /* +1 for separator */
		newwin->x = curwin->x;
		newwin->h = curwin->h - newh - 1;
		newwin->w = curwin->w;
		curwin->h = newh;
	}

	/* copy cursor state from current window */
	curwin_save();
	newwin->row = curwin->row;
	newwin->off = curwin->off;
	newwin->top = curwin->top;
	newwin->left = curwin->left;
	newwin->vsplit = vertical;

	/* handle buffer for new window */
	if (arg && *arg) {
		/* save original buffer for current window */
		struct buf *origbuf = curwin->buf;
		/* open specified file */
		int fd = bufs_find(arg, strlen(arg));
		if (fd >= 0) {
			newwin->buf = &bufs[fd];
		} else {
			bufs_switch(bufs_open(arg, strlen(arg)));
			newwin->buf = ex_buf;
			int f = open(xb_path, O_RDONLY);
			if (f >= 0) {
				lbuf_rd(xb, f, 0, lbuf_len(xb));
				close(f);
			}
			ex_bufpostfix(ex_buf, arg[0]);
		}
		/* restore current window's buffer and global state */
		curwin->buf = origbuf;
		ex_buf = origbuf;
		exbuf_load(ex_buf)
		syn_setft(xb_ft);
		newwin->row = 0;
		newwin->off = 0;
		newwin->top = 0;
		newwin->left = 0;
	} else {
		/* same buffer as current window */
		newwin->buf = curwin->buf;
	}

	/* insert into circular list after current window */
	newwin->next = curwin->next;
	curwin->next = newwin;
	nwins++;

	return NULL;
}

.
Jvis 4Jwq" $VI -e 'ex.c'

# Patch: led.c
EXINIT="rcm:|sc! \\\\J|vis 6J%;f> /\\\\* map cursor horizontal position to terminal column number \\\\*/
int led_pos\\\\(char \\\\*s, int pos\\\\)
\\\\{J??!.-5,.+5p\Jp FAIL line 95\Jq!J;=
J.+2a 	int ww = curwin ? curwin->w : xcols;
.
J.-1J>	if \\(dir_context\\(s\\) < 0\\)>+1;17;22c ww
.
J??!.-5,.+5p\Jp FAIL line 97\Jq!J.,$;f+ 		return;
	\\\\}
	int dir, off, pos, psn = sb->s_n;J??!.-5,.+5p\Jp FAIL line 289\Jq!J;=
J.+2a 	/* window offset for vsplit (not for prompts) */
	int winx = (ai_max >= 0 && curwin) ? curwin->x : 0;
	int winw = (ai_max >= 0 && curwin) ? curwin->w : xcols;
.
J.,$;f+ 			pos = ren_cursor\\\\(r->s, r->pos\\\\[off-two\\\\]\\\\);
		pos \\\\+= dir < 0 \\\\? -1 : 1;
	\\\\}J??!.-5,.+5p\Jp FAIL line 308\Jq!J;=
J.+3,#+1c 	if (pos >= xleft + winw || pos < xleft)
		xleft = pos < winw ? 0 : pos - winw / 2;
.
J.-1J>	syn_blockhl = -1;>+1,#+1c 	led_crender(r->s, -1, winx + vi_lncol, xleft, xleft + winw - vi_lncol);
	term_pos(-1, winx + led_pos(r->s, pos) + vi_lncol);
.
J??!.-5,.+5p\Jp FAIL line 311\Jq!J.,$;f+ if \\\\(ai_max >= 0\\\\) \\\\\\\\
	term_pos\\\\(crow - ctop, 0\\\\); \\\\\\\\
J??!.-5,.+5p\Jp FAIL line 363\Jq!J;=
J.+3;77c , int ai_max
.
J.-1J>\\{>a 	/* window offset for vsplit (not for prompts) */
	int winx = (ai_max >= 0 && curwin) ? curwin->x : 0;
	int winw = (ai_max >= 0 && curwin) ? curwin->w : xcols;
	int winh = (ai_max >= 0 && curwin) ? curwin->h : xrows;
.
J??!.-5,.+5p\Jp FAIL line 364\Jq!J.-1J>	rstate\\+\\+;>+1;22;27c winh
.
J??!.-5,.+5p\Jp FAIL line 366\Jq!J.-1J>		if \\(vi_lncol\\) \\{>+1;15;16c winx
.
J??!.-5,.+5p\Jp FAIL line 368\Jq!J.,$;f+ 			sbuf_mem\\\\(cb, cs, nl\\\\+!!cs\\\\[nl\\\\]\\\\)
			sbufn_null\\\\(cb\\\\)
			rstate->s = NULL;J??!.-5,.+5p\Jp FAIL line 377\Jq!J;=
J.+3;25;55c winx + vi_lncol, xleft, xleft + winw
.
J.,$;f+ 		\\\\}
		nl = r < crow-ctop \\\\? r\\\\+ctop : \\\\(r-\\\\(crow-orow\\\\+!!\\\\(flg & 4\\\\)\\\\)\\\\)\\\\+ctop;
		led_crender\\\\(lbuf_get\\\\(xb, nl\\\\) \\\\? lbuf_get\\\\(xb, nl\\\\) : \"~\", r,J??!.-5,.+5p\Jp FAIL line 384\Jq!J;=
J.+3c 			winx + vi_lncol, xleft, xleft + winw - vi_lncol)
.
J.-1J>	\\}>+1;23;24c winx
.
J??!.-5,.+5p\Jp FAIL line 386\Jq!J.,$;f+ 		case TK_CTL\\\\('z'\\\\):
			term_suspend\\\\(\\\\);
			if \\\\(ai_max >= 0\\\\)J??!.-5,.+5p\Jp FAIL line 509\Jq!J;=
J.+3;46c , ai_max
.
J.,$;f+ 					restore\\\\(ftidx\\\\)
					r\\\\+\\\\+;
				\\\\}J??!.-5,.+5p\Jp FAIL line 568\Jq!J;=
J.+3;46c , ai_max
.
J.,$;f+ 			else
				restore\\\\(ex_buf\\\\)
			exbuf_load\\\\(ex_buf\\\\)J??!.-5,.+5p\Jp FAIL line 588\Jq!J;=
J.+2a 			if (curwin)
				curwin->buf = ex_buf;
.
J.,$;f+ 			term_done\\\\(\\\\);
			term_init\\\\(\\\\);
			if \\\\(ai_max >= 0\\\\)J??!.-5,.+5p\Jp FAIL line 611\Jq!J;=
J.+3;46c , ai_max
.
Jvis 4Jwq" $VI -e 'led.c'

# Patch: vi.c
EXINIT="rcm:|sc! \\\\J|vis 6J%;f> \\\\}
#define vi_drawmsg_mpt\\\\(msg\\\\) \\\\{ vi_drawmsg\\\\(msg\\\\); if \\\\(!xmpt\\\\) xmpt = 1; \\\\}
J??!.-5,.+5p\Jp FAIL line 104\Jq!J;=
J.+2a /* draw horizontal separator line at screen row, from x for w columns */
static void vi_draw_hsep(int row, int x, int w)
{
	term_pos(row, x);
	for (int i = 0; i < w; i++)
		term_chr('-');
}

/* draw vertical separator line at screen column */
static void vi_draw_vsep(int col, int y, int h)
{
	for (int i = 0; i < h; i++) {
		term_pos(y + i, col);
		term_chr('|');
	}
}

.
J.,$;f+ noff = xoff; \\\\\\\\
for \\\\(i = 0, ret = 0;; i\\\\+\\\\+\\\\) \\\\{ \\\\\\\\
	l1 = ren_next\\\\(c, ren_pos\\\\(c, noff\\\\), 1\\\\)-1-xleft\\\\+vi_lncol; \\\\\\\\J??!.-5,.+5p\Jp FAIL line 120\Jq!J;=
J.+3;10;11c w
.
J.,$;f+ 	ret = func; \\\\\\\\
\\\\} \\\\} \\\\\\\\
J??!.-5,.+5p\Jp FAIL line 127\Jq!J;=
J.+2a /* calculate screen row for buffer row in current window */
static int win_scrrow(int row)
{
	return curwin ? curwin->y + (row - xtop) : row - xtop;
}

/* calculate effective window width */
static int win_width(void)
{
	return curwin ? curwin->w : xcols;
}

/* calculate effective window height (rows visible) */
static int win_height(void)
{
	return curwin ? curwin->h : xrows;
}

.
J.,$;f+ static void vi_drawrow\\\\(int row\\\\)
\\\\{
	int l1, i, i1, lnnum = vi_lnnum;J??!.-5,.+5p\Jp FAIL line 130\Jq!J;=
J.+2a 	int wrows = win_height();
	int wcols = win_width();
	int scrrow = win_scrrow(row);
.
J.,$;f+ 	char \\\\*c, \\\\*s;
	static char ch\\\\[5\\\\] = \"~\";J??!.-5,.+5p\Jp FAIL line 133\Jq!J;=
J.+2;18;31c scrrow ==
.
J.,$;f+ 		int noff, nrow, ret;
		s = lbuf_get\\\\(xb, row - vi_rshift\\\\);
		c = lbuf_get\\\\(xb, xrow\\\\);J??!.-5,.+5p\Jp FAIL line 139\Jq!J;=
J.+3;20;21c w
.
J.,$;f+ 			vi_rshift = 0;
		if \\\\(row != xrow\\\\+1 \\\\|\\\\| !c \\\\|\\\\| \\\\*c == '\\\\\\\\n'\\\\)
			goto skip;J??!.-5,.+5p\Jp FAIL line 143\Jq!J;=
J.+3,#+3c 		char tmp[wcols+3], snum[32];
		memset(tmp, ' ', wcols+1);
		tmp[wcols+1] = '\\\\n';
		tmp[wcols+2] = '\\\\0';
.
J.,$;f+ 		preserve\\\\(int, xtd, xtd = dir_context\\\\(c\\\\) \\\\* 2;\\\\)
		preserve\\\\(int, ftidx,\\\\)
		syn_setft\\\\(n_ft\\\\);J??!.-5,.+5p\Jp FAIL line 163\Jq!J;=
J.+3;25;44c scrrow, curwin ? curwin->x : 0, 0, w
.
J.,$;f+ 		vi_lncol = dir_context\\\\(s\\\\) < 0 \\\\? 0 : l1;
		memset\\\\(c, ' ', l1 - \\\\(c - tmp\\\\)\\\\);
		c\\\\[l1 - \\\\(c - tmp\\\\)\\\\] = '\\\\\\\\0';J??!.-5,.+5p\Jp FAIL line 195\Jq!J;=
J.+3c 		led_crender(s, scrrow, (curwin ? curwin->x : 0) + l1, xleft, xleft + wcols - l1)
.
J.,$;f+ 			i1 -= \\\\(itoa\\\\(abs\\\\(xrow-row\\\\+vi_rshift\\\\), tmp1\\\\) - tmp1\\\\)\\\\+1;
			if \\\\(i1 >= 0\\\\) \\\\{
				memset\\\\(p, ' ', strlen\\\\(p\\\\)\\\\);J??!.-5,.+5p\Jp FAIL line 206\Jq!J;=
J.+3;28;39c scrrow, (curwin ? curwin->x : 0) +
.
J.,$;f+ 			\\\\}
		\\\\}J??!.-5,.+5p\Jp FAIL line 209\Jq!J;=
J.+2;25;36c scrrow, curwin ? curwin->x :
.
J.,$;f+ 		restore\\\\(ftidx\\\\)
		return;
	\\\\}J??!.-5,.+5p\Jp FAIL line 214\Jq!J;=
J.+3c 	led_crender(s, scrrow, curwin ? curwin->x : 0, xleft, xleft + wcols)
.
J.,$;f+ /\\\\* redraw the screen \\\\*/
static void vi_drawagain\\\\(int i\\\\)
\\\\{J??!.-5,.+5p\Jp FAIL line 220\Jq!J;=
J.+2a 	int wrows = win_height();
.
J.-1J>	syn_scdir\\(0\\);>+1;19;20c w
.
J??!.-5,.+5p\Jp FAIL line 222\Jq!J.,$;f+ 		vi_drawrow\\\\(i\\\\);
\\\\}
J??!.-5,.+5p\Jp FAIL line 225\Jq!J;=
J.+2a /* draw all windows and separators */
static void vi_draw_allwins(void)
{
	struct win *w = wins;
	struct win *saved = curwin;
	/* draw each window */
	do {
		curwin = w;
		/* temporarily load window state */
		xrow = w->row;
		xoff = w->off;
		xtop = w->top;
		xleft = w->left;
		if (w->buf != ex_buf) {
			ex_buf = w->buf;
			syn_setft(xb_ft);
		}
		syn_scdir(0);
		for (int i = xtop; i < xtop + w->h; i++)
			vi_drawrow(i);
		/* draw separators based on actual adjacency */
		struct win *w2 = wins;
		do {
			if (w2 != w) {
				/* vertical separator: w2 is to the right of w */
				if (w2->x == w->x + w->w + 1) {
					int y1 = MAX(w->y, w2->y);
					int y2 = MIN(w->y + w->h, w2->y + w2->h);
					if (y1 < y2)
						vi_draw_vsep(w->x + w->w, y1, y2 - y1);
				}
				/* horizontal separator: w2 is below w */
				if (w2->y == w->y + w->h + 1) {
					int x1 = MAX(w->x, w2->x);
					int x2 = MIN(w->x + w->w, w2->x + w2->w);
					if (x1 < x2)
						vi_draw_hsep(w->y + w->h, x1, x2 - x1);
				}
			}
			w2 = w2->next;
		} while (w2 != wins);
		w = w->next;
	} while (w != wins);
	/* restore current window */
	curwin = saved;
	xrow = saved->row;
	xoff = saved->off;
	xtop = saved->top;
	xleft = saved->left;
	if (saved->buf != ex_buf) {
		ex_buf = saved->buf;
		syn_setft(xb_ft);
	}
}

.
J.,$;f+ static void vi_drawupdate\\\\(int i\\\\)
\\\\{
	int n;J??!.-5,.+5p\Jp FAIL line 230\Jq!J;=
J.+3c 	int wrows = win_height();
	term_pos(curwin ? curwin->y : 0, 0);
.
J.,$;f+ 	term_room\\\\(i\\\\);
	syn_scdir\\\\(i\\\\);
	if \\\\(i < 0\\\\) \\\\{J??!.-5,.+5p\Jp FAIL line 234\Jq!J;=
J.+3;14;15c w
.
J.-1J>		for \\(i = 0; i < n; i\\+\\+\\)>+1;21;22c w
.
J??!.-5,.+5p\Jp FAIL line 236\Jq!J.-1J>	\\} else \\{>+1;13;14c w
.
J??!.-5,.+5p\Jp FAIL line 238\Jq!J.,$;f+ 		\\\\*row = MIN\\\\(xtop \\\\+ cnt - 1, lbuf_len\\\\(xb\\\\) - 1\\\\);
		break;
	case 'L':J??!.-5,.+5p\Jp FAIL line 371\Jq!J;=
J.+3;20;25c win_height()
.
J.,$;f+ 		break;
	case 'M':J??!.-5,.+5p\Jp FAIL line 374\Jq!J;=
J.+2;20;25c win_height()
.
J.,$;f+ 			ex_bufpostfix\\\\(&bufs\\\\[i\\\\], 1\\\\);
		syn_setft\\\\(xb_ft\\\\);
		vc_status\\\\(0\\\\);J??!.-5,.+5p\Jp FAIL line 753\Jq!J;=
J.+3;23;28c win_height()
.
J.,$;f+ 	case 'N':
		if \\\\(vi_search\\\\(mv, cnt, row, off, 1\\\\)\\\\)
			return -1;J??!.-5,.+5p\Jp FAIL line 786\Jq!J;=
J.+3;23;28c win_height()
.
J.,$;f+ 		\\\\}
		if \\\\(vi_search\\\\(cadir < 0 \\\\? 'N' : 'n', 1, row, off, 1\\\\)\\\\)
			cadir = -cadir;J??!.-5,.+5p\Jp FAIL line 799\Jq!J;=
J.+3,#+1c 		else if (*row < xtop || *row >= xtop + win_height() - 1)
			xtop = MAX(0, *row - win_height() / 2);
.
J.,$;f+ 		xoff = lbuf_eol\\\\(xb, xrow, 1\\\\);
	else if \\\\(cmd == 'o'\\\\) \\\\{
		xrow\\\\+\\\\+;J??!.-5,.+5p\Jp FAIL line 1031\Jq!J;=
J.+3;21;26c win_height()
.
J.,$;f+ static void vi_scrollbackward\\\\(int cnt\\\\)
\\\\{
	xtop = MAX\\\\(0, xtop - cnt\\\\);J??!.-5,.+5p\Jp FAIL line 1117\Jq!J;=
J.+3;25;30c win_height()
.
J.,$;f+ \\\\}

#define topfix\\\\(\\\\) \\\\\\\\J??!.-5,.+5p\Jp FAIL line 1180\Jq!J;=
J.+2a { int _wh = win_height(); \\\\
.
J.,$;f+ if \\\\(xrow < 0 \\\\|\\\\| xrow >= lbuf_len\\\\(xb\\\\)\\\\) \\\\\\\\
	xrow = lbuf_len\\\\(xb\\\\) \\\\? lbuf_len\\\\(xb\\\\) - 1 : 0; \\\\\\\\
if \\\\(xtop > xrow\\\\) \\\\\\\\J??!.-5,.+5p\Jp FAIL line 1184\Jq!J;=
J.+3,#+4c 	xtop = xtop - _wh / 2 > xrow ? \\\\
			MAX(0, xrow - _wh / 2) : xrow; \\\\
if (xtop + _wh <= xrow) \\\\
	xtop = xtop + _wh + _wh / 2 <= xrow ? \\\\
			xrow - _wh / 2 : xrow - _wh + 1; } \\\\
.
J.,$;f+ 	int mv, n, k, c;
	xgrec\\\\+\\\\+;
	if \\\\(init\\\\) \\\\{J??!.-5,.+5p\Jp FAIL line 1195\Jq!J;=
J.+2a 		win_init();
.
J.,$;f+ 		topfix\\\\(\\\\)
		vi_col = vi_off2col\\\\(xb, xrow, xoff\\\\);J??!.-5,.+5p\Jp FAIL line 1198\Jq!J;=
J.+2,#+1c 		if (nwins > 1) {
			if (curwin) {
				curwin->row = xrow;
				curwin->off = xoff;
				curwin->top = xtop;
				curwin->left = xleft;
			}
			vi_draw_allwins();
		} else
			vi_drawagain(xtop);
		term_pos((curwin ? curwin->y : 0) + xrow - xtop,
			(curwin ? curwin->x : 0) + led_pos(lbuf_get(xb, xrow), vi_col));
.
J.,$;f+ 			c = term_read\\\\(TK_CTL\\\\('l'\\\\)\\\\);
			switch \\\\(c\\\\) \\\\{
			case TK_CTL\\\\('b'\\\\):J??!.-5,.+5p\Jp FAIL line 1246\Jq!J;=
J.+3;40;45c win_height()
.
J.,$;f+ 				vi_mod \\\\|= 4;
				break;
			case TK_CTL\\\\('f'\\\\):J??!.-5,.+5p\Jp FAIL line 1251\Jq!J;=
J.+3;39;44c win_height()
.
J.,$;f+ 					break;
				if \\\\(vi_arg\\\\)
					vi_scrollud = vi_arg;J??!.-5,.+5p\Jp FAIL line 1270\Jq!J;=
J.+3;36;41c win_height()
.
J.,$;f+ 					break;
				if \\\\(vi_arg\\\\)
					vi_scrollud = vi_arg;J??!.-5,.+5p\Jp FAIL line 1282\Jq!J;=
J.+3;36;41c win_height()
.
J.-1J>				xrow = MIN\\(MAX\\(0, lbuf_len\\(xb\\) - 1\\), xrow \\+ n\\);>+1,#+1c 				if (xtop < lbuf_len(xb) - win_height())
					xtop = MIN(lbuf_len(xb) - win_height(), xtop + n);
.
J??!.-5,.+5p\Jp FAIL line 1284\Jq!J.,$;f+ 				case 'v':
					term_push\\\\(k == 'v' \\\\? \":\\\\\\\\x01\" : \":\\\\\\\\x02\", 2\\\\); /\\\\* \\\\^a : \\\\^b \\\\*/
					break;J??!.-5,.+5p\Jp FAIL line 1402\Jq!J;=
J.+2a 				case 'c':
					/* switch to next window */
					if (nwins > 1) {
						curwin->row = xrow;
						curwin->off = xoff;
						curwin->top = xtop;
						curwin->left = xleft;
						win_switch(curwin->next);
						vi_mod |= 1;
					}
					break;
				case 'd':
					/* close current window */
					if (nwins > 1) {
						win_close();
						vi_mod |= 1;
					}
					break;
.
J.,$;f+ 				vi_mod \\\\|= 1;
				break; \\\\}
			case TK_CTL\\\\('z'\\\\):J??!.-5,.+5p\Jp FAIL line 1531\Jq!J;=
J.+3c 			case TK_CTL('l'): {
				int orows = xrows, ocols = xcols;
.
J.,$;f+ 					term_done\\\\(\\\\);
					term_init\\\\(\\\\);
				\\\\}J??!.-5,.+5p\Jp FAIL line 1538\Jq!J;=
J.+2a 				if (xrows != orows || xcols != ocols)
					win_size();
.
J.,$;f+ 				vi_status = vi_status \\\\? xrows - 1: vi_status;
				vi_mod \\\\|= 1;J??!.-5,.+5p\Jp FAIL line 1541\Jq!J;=
J.+2;10c  }
.
J.,$;f+ 		\\\\}
		if \\\\(vi_mod\\\\)
			vi_col = vi_off2col\\\\(xb, xrow, xoff\\\\);J??!.-5,.+5p\Jp FAIL line 1703\Jq!J;=
J.+3,#+1c 		{ int _ww = win_width();
		if (vi_col >= xleft + _ww || vi_col < xleft)
			xleft = vi_col < _ww ? 0 : vi_col - _ww / 2; }
.
J.,$;f+ 			\\\\}
		\\\\}
		term_record = 1;J??!.-5,.+5p\Jp FAIL line 1746\Jq!J;=
J.+3c 		/* save cursor position to current window */
		if (curwin) {
			curwin->row = xrow;
			curwin->off = xoff;
			curwin->top = xtop;
			curwin->left = xleft;
		}
		/* always do full redraw when multiple windows are active */
		if (nwins > 1) {
			vi_draw_allwins();
		} else if (vi_mod & 1 || xleft != oleft
.
J.-1J>				\\|\\| \\(vi_lnnum && orow != xrow && !\\(vi_lnnum == 2\\)\\)>+1;34c  {
.
J??!.-5,.+5p\Jp FAIL line 1748\Jq!J.-1J>			vi_drawagain\\(xtop\\);>+1,#+1c 		} else if (*vi_word && (ooff != xoff || vi_mod & 2)
				&& xrow+1 < xtop + win_height()) {
.
J??!.-5,.+5p\Jp FAIL line 1750\Jq!J.,$;f+ 			vi_drawupdate\\\\(otop - xtop\\\\);
		if \\\\(xhll\\\\) \\\\{
			syn_blockhl = -1;J??!.-5,.+5p\Jp FAIL line 1758\Jq!J;=
J.+3;53;58c win_height()
.
J.,$;f+ 			if \\\\(xmpt > 0\\\\)
				xmpt = 0;
		\\\\}J??!.-5,.+5p\Jp FAIL line 1775\Jq!J;=
J.+3;11;23c (curwin ? curwin->y : 0) + xrow - xtop, (curwin ? curwin->x : 0) +
.
Jvis 4Jwq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! \\\\J|vis 6J%;f> 	long mtime;			/\\\\* modification time \\\\*/
	signed char td;			/\\\\* text direction \\\\*/
\\\\};J??!.-5,.+5p\Jp FAIL line 412\Jq!J;=
J.+2a 
/* window management for splits */
struct win {
	struct buf *buf;		/* buffer displayed in this window */
	int y, x;			/* top-left screen position */
	int h, w;			/* height and width */
	int row, off, top;		/* cursor position within window */
	int left;			/* horizontal scroll offset */
	int vsplit;			/* 1 if created by vertical split */
	struct win *next;		/* next window (circular list) */
};
extern struct win *wins;		/* head of window list */
extern struct win *curwin;		/* current active window */
extern int nwins;			/* number of windows */
void win_init(void);
void win_size(void);
void win_switch(struct win *w);
void win_close(void);
void *win_split(int vertical, char *arg);
.
Jvis 4Jwq" $VI -e 'vi.h'
