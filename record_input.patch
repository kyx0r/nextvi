diff --git a/ex.c b/ex.c
index 436e178d..913ba496 100644
--- a/ex.c
+++ b/ex.c
@@ -23,6 +23,7 @@ int xerr = 1;			/* error handling -
 				bit 1: print errors, bit 2: early return, bit 3: ignore errors */
 int xrcm = 1;			/* range command model -
 				0: exec at command parse 1: exec at command */
+int xrec;			/* input recoding register */
 
 int xquit;			/* exit if positive, force quit if negative */
 int xrow, xoff, xtop;		/* current row, column, and top row */
@@ -1313,6 +1314,7 @@ static void *eo_##opt(char *loc, char *cmd, char *arg) { inner }
 EO(pac) EO(pr) EO(ai) EO(err) EO(ish) EO(ic) EO(grp) EO(mpt) EO(rcm)
 EO(shape) EO(seq) EO(ts) EO(td) EO(order) EO(hll) EO(hlw)
 EO(hlp) EO(hlr) EO(hl) EO(lim) EO(led) EO(vis)
+EO(rec)
 
 _EO(left,
 	if (*loc)
@@ -1374,6 +1376,7 @@ static struct excmd {
 	{"q!", ec_quit},
 	{"q", ec_quit},
 	EO(rcm),
+	EO(rec),
 	{"reg", ec_regprint},
 	{"rd", ec_undoredo},
 	{"r", ec_read},
diff --git a/term.c b/term.c
index 7d955999..bd7ddaa6 100644
--- a/term.c
+++ b/term.c
@@ -174,6 +174,12 @@ int term_read(int winch)
 		ret:
 		ibuf_cnt = 1;
 		ibuf_pos = 0;
+		if (xrec && *ibuf) {
+			char buf[2];
+			buf[0] = *ibuf;
+			buf[1] = '\0';
+			ex_regput(xrec, buf, 1);
+		}
 	}
 	if (icmd_pos < sizeof(icmd))
 		icmd[icmd_pos++] = ibuf[ibuf_pos];
diff --git a/vi.h b/vi.h
index dcdcc3ca..a964144e 100644
--- a/vi.h
+++ b/vi.h
@@ -430,6 +430,7 @@ extern int xpr;
 extern int xlim;
 extern int xseq;
 extern int xerr;
+extern int xrec;
 /* global variables */
 extern int xquit;
 extern int xrow, xoff, xtop;
