#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: conf.c
EXINIT="rcm:|sc! @|vis 6@55;15;22c 
.
@vis 4@wq" $VI -e 'conf.c'

# Patch: ex.c
EXINIT="rcm:|sc! @|vis 6@1032a 	free(offs);
.
@981c 	int *offs = emalloc(rs->nsubc * sizeof(int));
.
@524a 		free(offs);
.
@511c 		int *offs = emalloc(xkwdrs->nsubc * sizeof(int));
		int flg = 0, soff = 0;
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! @|vis 6@518a 	free(offs);
.
@512a 			}
.
@511c 			if (dir > 0) {
				free(offs);
.
@486c 	int *offs = emalloc(re->nsubc * sizeof(int)), i = r0;
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: led.c
EXINIT="rcm:|sc! @|vis 6@259a 	free(off);
	free(att);
	free(stt);
	free(ctt);
.
@177a 		stt = emalloc((cterm+1) * sizeof(int));
		ctt = emalloc((cterm+1) * sizeof(int));
.
@153,156c 	int *off = emalloc((cterm+1) * sizeof(int));	/* off[i]: the character at screen position i */
	int *att = emalloc((cterm+1) * sizeof(int));	/* att[i]: the attributes of i-th character */
	int *stt = NULL;	/* stt[i]: remap off indexes */
	int *ctt = NULL;	/* ctt[i]: cterm bound attrs */
.
@82a 	free(subs);
.
@50c 	int *subs = emalloc(rs->nsubc * sizeof(int));
.
@vis 4@wq" $VI -e 'led.c'

# Patch: regex.c
EXINIT="rcm:|sc! @|vis 6@737a 	free(subs);
.
@733a 				free(subs);
.
@717c 	const char **subs = emalloc((rs->nsubc+2) * sizeof(subs[0]));
.
@638,639c 	char *nsubs = emalloc(prog->sub);
.
@633;24;41c *lb = emalloc(prog->laidx * sizeof(lb[0]))
.
@631c 	rthread *_clist = emalloc(prog->len * sizeof(rthread)), *_nlist = emalloc(prog->len * sizeof(rthread));
.
@628,629c 	int *npc, *pc, *insts = prog->insts;
	int **pcs = emalloc((prog->splits) * sizeof(int*));
	rsub **subs = emalloc(prog->splits * sizeof(rsub*));
	unsigned int *sdense = emalloc(prog->sparsesz * sizeof(unsigned int)), sparsesz = 0;
.
@402c #define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; \\
free(pcs); \\
free(subs); \\
free(sdense); \\
free(_clist); \\
free(_nlist); \\
free(nsubs); \\
free(lb); \\
return state; } \\
.
@vis 4@wq" $VI -e 'regex.c'

# Patch: ren.c
EXINIT="rcm:|sc! @|vis 6@408a 	free(pats);
.
@404c 	char **pats = emalloc(ftslen * sizeof(char *));
.
@360a 	free(subs);
.
@357a 	}
.
@356c 	if (syn_blockhl < 0 || blockhl < 0) {
		free(subs);
.
@353a 	}
.
@352c 	if (ftmidx > fti && ftmap[fti-1].ft == ftmap[fti].ft) {
		free(subs);
.
@309;5;20c *subs = emalloc(rs->nsubc * sizeof(int))
.
@261a 	free(pats);
.
@255c 	char **pats = emalloc(hlslen * sizeof(char *));
.
@vis 4@wq" $VI -e 'ren.c'

# Patch: vi.c
EXINIT="rcm:|sc! @|vis 6@1435a 					free(buf);
.
@1428c 					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
.
@1424a 					free(buf);
.
@1415c 					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
.
@1293a 				free(buf);
.
@1290c 				char *buf = emalloc(strlen(ln)+4);
.
@168a 		free(tmp);
		free(snum);
.
@143c 		char *tmp = emalloc(xcols+3);
		char *snum = emalloc(32);
.
@vis 4@wq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! @|vis 6@502;5;9c att[16]
.
@vis 4@wq" $VI -e 'vi.h'
