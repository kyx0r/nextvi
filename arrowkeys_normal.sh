#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: vi.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> \\\\{
	int mark, c = term_read\\\\(TK_CTL\\\\('l'\\\\)\\\\);
	switch \\\\(c\\\\) \\\\{@??!.-5,.+5p\@p FAIL line 348\@q!@;=
@.+2a 	case '\\\\033':	/* Arrow keys */
		c = term_read(0);
		if (c == '[') {
			c = term_read(0);
			switch (c) {
			case 'A':	/* ↑ */
				*row = MAX(*row - cnt, 0);
				c = 'k';
				break;
			case 'B':	/* ↓ */
				*row = MIN(*row + cnt, lbuf_len(xb) - 1);
				c = 'j';
				break;
			default:	/* Not a line motion so we put back all the arrow characters */
				term_back('\\\\033');
				term_back('[');
				term_back(c);
				return 0;
			}
		} else	/* Not an arrow sequence so we abort */
			return 0;
		break;
.
@.,$;f+ 	\\\\}
	mv = term_read\\\\(TK_CTL\\\\('l'\\\\)\\\\);
	switch \\\\(mv\\\\) \\\\{@??!.-5,.+5p\@p FAIL line 586\@q!@;=
@.+2a 	case '\\\\033':	/* Arrow keys */
		mv = term_read(0);
		if (mv == '[') {
			if (!(cs = lbuf_get(xb, *row)))
				return -1;
			dir = dir_context(lbuf_get(xb, *row));
			mv = term_read(0);
			switch (mv) {
			case 'D':	/* ← */
				dir = -dir;
			case 'C':	/* → */
				for (i = 0; i < cnt; i++)
					if (vi_nextcol(cs, dir, off))
						break;
				break;
			default:	/* Not a motion managed by this function so we abort */
				return 0;
			}
		} else	/* Not a 033[X command so we abort */
			return 0;
		break;
.
@vis 4@wq" $VI -e 'vi.c'
