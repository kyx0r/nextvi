diff --git a/ex.c b/ex.c
index 8f85bef..8488c53 100644
--- a/ex.c
+++ b/ex.c
@@ -26,7 +26,7 @@ struct buf *bufs;		/* main buffers */
 struct buf *ex_buf;		/* current buffer */
 struct buf *ex_pbuf;		/* prev buffer */
 sbuf *xacreg;			/* autocomplete db filter regex */
-rset *xkwdrs;			/* the last searched keyword rset */
+rstr *xkwdrs;			/* the last searched keyword rstr */
 int xkwddir;			/* the last search direction */
 static int xbufsmax;		/* number of buffers */
 static char xrep[EXLEN];	/* the last replacement */
@@ -209,9 +209,9 @@ void ex_krsset(char *kwd, int dir)
 {
 	char *reg = vi_regget('/', &(int){0});
 	if (kwd && *kwd && ((!reg || !xkwdrs || strcmp(kwd, reg))
-		|| ((xkwdrs->regex->flg & REG_ICASE) != xic))) {
-		rset_free(xkwdrs);
-		xkwdrs = rset_make(1, (char*[]){kwd}, xic ? REG_ICASE : 0);
+		|| (xkwdrs->icase != xic))) {
+		rstr_free(xkwdrs);
+		xkwdrs = rstr_make(kwd, xic ? REG_ICASE : 0);
 		xkwdcnt++;
 		vi_regput('/', kwd, 0);
 		xkwddir = dir;
@@ -240,7 +240,7 @@ static int ex_search(char **pat)
 		return -1;
 	row = xrow + xkwddir;
 	while (row >= 0 && row < lbuf_len(xb)) {
-		if (rset_find(xkwdrs, lbuf_get(xb, row), 0, NULL, REG_NEWLINE) >= 0)
+		if (rstr_find(xkwdrs, lbuf_get(xb, row), 0, NULL, REG_NEWLINE) >= 0)
 			break;
 		row += xkwddir;
 	}
@@ -709,7 +709,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	for (i = beg; i < end; i++) {
 		char *ln = lbuf_get(xb, i);
 		sbuf *r = NULL;
-		while (rset_find(xkwdrs, ln, grp / 2, offs, REG_NEWLINE) >= 0) {
+		while (rstr_find(xkwdrs, ln, grp / 2, offs, REG_NEWLINE) >= 0) {
 			if (offs[xgrp - 2] < 0) {
 				ln += offs[1] > 0 ? offs[1] : 1;
 				continue;
@@ -779,7 +779,7 @@ static int ec_glob(char *loc, char *cmd, char *arg)
 	int beg, end, not;
 	char *pat, *s = arg;
 	int i;
-	rset *rs;
+	rstr *rs;
 	if (!loc[0] && !xgdep)
 		loc = "%";
 	if (ex_region(loc, &beg, &end))
@@ -787,7 +787,7 @@ static int ec_glob(char *loc, char *cmd, char *arg)
 	not = strchr(cmd, '!') || cmd[0] == 'v';
 	pat = re_read(&s);
 	if (pat)
-		rs = rset_make(1, (char*[]){pat}, xic ? REG_ICASE : 0);
+		rs = rstr_make(pat, xic ? REG_ICASE : 0);
 	free(pat);
 	if (!pat || !rs)
 		return 1;
@@ -797,7 +797,7 @@ static int ec_glob(char *loc, char *cmd, char *arg)
 	i = beg;
 	while (i < lbuf_len(xb)) {
 		char *ln = lbuf_get(xb, i);
-		if ((rset_find(rs, ln, 0, NULL, REG_NEWLINE) < 0) == not) {
+		if ((rstr_find(rs, ln, 0, NULL, REG_NEWLINE) < 0) == not) {
 			xrow = i;
 			if (ex_exec(s))
 				break;
@@ -808,7 +808,7 @@ static int ec_glob(char *loc, char *cmd, char *arg)
 	}
 	for (i = 0; i < lbuf_len(xb); i++)
 		lbuf_globget(xb, i, xgdep);
-	rset_free(rs);
+	rstr_free(rs);
 	xgdep--;
 	return 0;
 }
@@ -912,9 +912,9 @@ static int ec_chdir(char *loc, char *cmd, char *arg)
 static int ec_setincl(char *loc, char *cmd, char *arg)
 {
 	ec_setdir(NULL, NULL, NULL);
-	rset_free(fsincl);
+	rstr_free(fsincl);
 	if (*arg)
-		fsincl = rset_make(1, (char*[]){arg}, xic ? REG_ICASE : 0);
+		fsincl = rstr_make(arg, xic ? REG_ICASE : 0);
 	else
 		fsincl = NULL;
 	return 0;
diff --git a/lbuf.c b/lbuf.c
index 568caab..25ff755 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -419,7 +419,7 @@ int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *row, int *off)
 	return n != 0;
 }
 
-int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len)
+int lbuf_search(struct lbuf *lb, rstr *re, int dir, int *r, int *o, int *len)
 {
 	int r0 = *r, o0 = *o, grp = xgrp;
 	int offs[grp], i = r0;
@@ -428,7 +428,7 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len)
 	int ln_n = lbuf_len(lb);
 	for (; i >= 0 && i < ln_n; i += dir) {
 		s = lb->ln[i];
-		while (rset_find(re, s + off, grp / 2, offs,
+		while (rstr_find(re, s + off, grp / 2, offs,
 				off ? REG_NOTBOL | REG_NEWLINE : REG_NEWLINE) >= 0) {
 			int g1 = offs[grp - 2], g2 = offs[grp - 1];
 			if (g1 < 0) {
diff --git a/regex.c b/regex.c
index feb536c..2be5485 100644
--- a/regex.c
+++ b/regex.c
@@ -650,3 +650,126 @@ char *re_read(char **src)
 	*src = *s ? s + 1 : s;
 	sbufn_done(sb)
 }
+
+/* return zero if a simple pattern is given */
+static int rstr_simple(rstr *rs, char *re, int icase)
+{
+	char *beg;
+	char *end;
+	if (!strcmp(re, "^$"))
+		return 1;
+	rs->lbeg = re[0] == '^';
+	if (rs->lbeg)
+		re++;
+	rs->wbeg = re[0] == '\\' && re[1] == '<';
+	if (rs->wbeg)
+		re += 2;
+	beg = re;
+	while (re[0] && !strchr("\\.*+?[]{}()$", (unsigned char) re[0]))
+		re++;
+	end = re;
+	rs->wend = re[0] == '\\' && re[1] == '>';
+	if (rs->wend)
+		re += 2;
+	rs->lend = re[0] == '$';
+	if (rs->lend)
+		re++;
+	if (!re[0]) {
+		int len = end - beg;
+		rs->len = len;
+		rs->str = malloc(len + 1);
+		rs->str[len] = '\0';
+		if (icase) {
+			while (--len >= 0)
+				rs->str[len] = tolower((unsigned char)beg[len]);
+		} else
+			memcpy(rs->str, beg, len);
+		return 0;
+	}
+	return 1;
+}
+
+rstr *rstr_make(char *re, int flg)
+{
+	rstr *rs = malloc(sizeof(*rs));
+	memset(rs, 0, sizeof(*rs));
+	rs->icase = flg & REG_ICASE;
+	if (rstr_simple(rs, re, rs->icase))
+		rs->rs = rset_make(1, &re, flg);
+	if (!rs->rs && !rs->str) {
+		free(rs);
+		return NULL;
+	}
+	return rs;
+}
+
+#define rstr_match(gen, wbeg, wend, cmpcase) \
+wbeg wend \
+m = rs->str; t = r; \
+for (; *m && *t; t++, m++) { \
+	if (cmpcase) \
+		goto break##gen; \
+} \
+if (!*m) { \
+	if (n >= 1) { \
+		grps[0] = r - s; \
+		grps[1] = r - s + len; \
+	} \
+	return 0; \
+} \
+break##gen:; \
+
+#define rstr_match1(gen, wbeg, wend, cmpcase) \
+{ for (r = beg; r <= end; r++) { \
+	rstr_match(2##gen, wbeg, wend, cmpcase) \
+} } \
+
+#define _wbeg if (r > s && (isword(r - 1) || !isword(r))) continue;
+#define _wend if (r[len] && (!isword(r + len - 1) || isword(r + len))) continue;
+
+#define template(gen, cmpcase) \
+if (!rs->wbeg && !rs->wend) \
+	rstr_match1(1##gen, /*nop*/, /*nop*/, cmpcase) \
+else if (rs->wbeg && !rs->wend) \
+	rstr_match1(2##gen, _wbeg, /*nop*/, cmpcase) \
+else if (!rs->wbeg && rs->wend) \
+	rstr_match1(3##gen, /*nop*/, _wend, cmpcase) \
+else \
+	rstr_match1(4##gen, _wbeg, _wend, cmpcase) \
+
+/* return zero if an occurrence is found */
+int rstr_find(rstr *rs, char *s, int n, int *grps, int flg)
+{
+	int len;
+	char *beg, *end, *r, *t, *m;
+	if (rs->rs)
+		return rset_find(rs->rs, s, n, grps, flg);
+	if ((rs->lbeg && (flg & REG_NOTBOL)) || (rs->lend && (flg & REG_NOTEOL)))
+		return -1;
+	if (!*s)
+		return -1;
+	len = rs->len;
+	beg = s;
+	end = s + strlen(s) - len - (flg & REG_NEWLINE ? 1 : 0);
+	if (end < beg)
+		return -1;
+	if (rs->lend)
+		beg = end;
+	if (rs->lbeg)
+		end = s;
+	if (!rs->icase) {
+		template(3, *t != *m)
+	} else {
+		template(4, tolower((unsigned char) *t) != *m)
+	}
+	return -1;
+}
+
+void rstr_free(rstr *rs)
+{
+	if (!rs)
+		return;
+	rset_free(rs->rs);
+	free(rs->str);
+	free(rs);
+}
diff --git a/vi.c b/vi.c
index 866b5cc..975b7ec 100644
--- a/vi.c
+++ b/vi.c
@@ -589,7 +589,7 @@ static void vi_regprint(void)
 	}
 }
 
-rset *fsincl;
+rstr *fsincl;
 char *fslink;
 char *fs_exdir;
 int fstlen;
@@ -609,7 +609,7 @@ static char *file_calc(char *path)
 		len1 = strlen(dp->d_name)+1;
 		path[pathlen] = '/';
 		memcpy(&path[pathlen+1], dp->d_name, len1);
-		if (fsincl && rset_find(fsincl, path, 0, NULL, 0) < 0)
+		if (fsincl && rstr_find(fsincl, path, 0, NULL, 0) < 0)
 			continue;
 		if (lstat(path, &statbuf) >= 0 && S_ISREG(statbuf.st_mode))
 		{
diff --git a/vi.h b/vi.h
index d159855..3da5d40 100644
--- a/vi.h
+++ b/vi.h
@@ -113,10 +113,21 @@ typedef struct {
 	int *setgrpcnt;		/* number of groups in each regular expression */
 	int grpcnt;		/* group count */
 } rset;
+typedef struct {
+	rset *rs;		/* only for regex patterns */
+	char *str;		/* for simple, non-regex patterns  */
+	int len;		/* str length */
+	int icase;		/* ignore case */
+	int lbeg, lend;		/* match line beg/end */
+	int wbeg, wend;		/* match word beg/end */
+} rstr;
 rset *rset_make(int n, char **pat, int flg);
 int rset_find(rset *re, char *s, int n, int *grps, int flg);
 void rset_free(rset *re);
 char *re_read(char **src);
+rstr *rstr_make(char *re, int flg);
+int rstr_find(rstr *rs, char *s, int n, int *grps, int flg);
+void rstr_free(rstr *rs);
 
 /* lbuf.c line buffer, managing a number of lines */
 struct lbuf *lbuf_make(void);
@@ -140,7 +151,7 @@ int lbuf_eol(struct lbuf *lb, int r);
 void lbuf_globset(struct lbuf *lb, int pos, int dep);
 int lbuf_globget(struct lbuf *lb, int pos, int dep);
 int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *r, int *o);
-int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len);
+int lbuf_search(struct lbuf *lb, rstr *re, int dir, int *r, int *o, int *len);
 /* motions */
 int lbuf_paragraphbeg(struct lbuf *lb, int dir, int *row, int *off);
 int lbuf_sectionbeg(struct lbuf *lb, int dir, int *row, int *off);
@@ -320,7 +331,7 @@ void ex_print(char *line);
 void ex_show(char *msg);
 int ex_init(char **files);
 void ex_bufpostfix(int i, int clear);
-int ex_krs(rset **krs, int *dir);
+int ex_krs(rstr **krs, int *dir);
 void ex_krsset(char *kwd, int dir);
 int ex_edit(const char *path);
 void ec_bufferi(int id);
@@ -414,9 +425,9 @@ extern int xgrp;
 extern int xpac;
 extern int xkwdcnt;
 extern int xkwddir;
-extern rset *xkwdrs;
+extern rstr *xkwdrs;
 extern sbuf *xacreg;
-extern rset *fsincl;
+extern rstr *fsincl;
 extern char *fslink;
 extern char *fs_exdir;
 extern int fstlen;
