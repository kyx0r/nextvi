diff --git a/cbuild.sh b/cbuild.sh
index b496f47..2e76016 100755
--- a/cbuild.sh
+++ b/cbuild.sh
@@ -41,6 +41,7 @@ CFLAGS="\
 -Wno-unused-parameter \
 -Wno-unused-result \
 -Wfatal-errors -std=c99 \
+-lpthread \
  $CFLAGS"
 
 : "${CC:=cc}"
diff --git a/lbuf.c b/lbuf.c
index 1678fef..447ef59 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -428,34 +428,95 @@ int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *row, int *off)
 	return n != 0;
 }
 
-int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
-			int *o, int ln_n, int skip)
+struct lsparams
+{
+	struct lbuf *lb;
+	rset *re;
+	int dir;
+	int ln_n;
+	int *r;
+	int *o;
+	int skip;
+};
+
+static void *lsearch(void *arg)
 {
-	int r0 = *r, o0 = *o;
-	int offs[re->grpcnt * 2], i = r0;
-	char *s = lbuf_get(lb, i);
-	int off = skip >= 0 && *uc_chr(s, o0 + skip) ? uc_chr(s, o0 + skip) - s : 0;
-	for (; i >= 0 && i < ln_n; i += dir) {
-		s = lb->ln[i];
-		while (rset_find(re, s + off, offs,
+	struct lsparams *a = arg;
+	int r0 = *a->r, o0 = *a->o;
+	int offs[a->re->grpcnt * 2], i = r0;
+	char *s = lbuf_get(a->lb, i);
+	int off = a->skip > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
+	for (; i >= 0 && i < a->ln_n; i += a->dir) {
+		s = a->lb->ln[i];
+		while (rset_find(a->re, s + off, offs,
 				off ? REG_NOTBOL | REG_NEWLINE : REG_NEWLINE) >= 0) {
 			int g1 = offs[xgrp], g2 = offs[xgrp + 1];
 			if (g1 < 0) {
 				off += offs[1] > 0 ? offs[1] : 1;
 				continue;
 			}
-			if (dir < 0 && r0 == i && uc_off(s, off+g1) >= o0)
+			if (a->dir < 0 && r0 == i && uc_off(s, off+g1) >= o0)
 				break;
-			*o = uc_off(s, off + g1);
-			*r = i;
+			*a->o = uc_off(s, off + g1);
+			*a->r = i;
 			off += g2 > 0 ? g2 : 1;
-			if (dir > 0)
-				return 0;
-			ln_n = -1; /* break outer loop efficiently */
+			a->ln_n = -1; /* break outer loop efficiently */
+			if (a->dir > 0)
+				return NULL;
 		}
 		off = 0;
 	}
-	return ln_n < 0 ? 0 : 1;
+	return NULL;
+}
+
+int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
+			int *o, int ln_n, int skip)
+{
+	#define NUM_THREADS 4
+	pthread_t threads[NUM_THREADS];
+	static unsigned char fake_ulen[256]; /* novelty: for fast thread termination */
+	struct lsparams data[NUM_THREADS];
+	int rs[NUM_THREADS];
+	int os[NUM_THREADS];
+	int thread_step = ln_n / NUM_THREADS; /* number of lines assigned per thread */
+	int step = 0, i = 0;
+	utf8_length['\n'] = 0;
+	for (i = 0; i < NUM_THREADS; i++) {
+		if (*r + step > ln_n || *r + step * dir < 0)
+			break;
+		data[i].lb = lb;
+		data[i].re = re;
+		data[i].dir = dir;
+		data[i].skip = skip;
+		rs[i] = *r + step * dir;
+		step += thread_step;
+		data[i].r = &rs[i];
+		if (i == NUM_THREADS-1)
+			data[i].ln_n = ln_n;
+		else
+			data[i].ln_n = MIN(rs[i] + thread_step, ln_n);
+		os[i] = i ? -1 : *o;
+		data[i].o = &os[i];
+		pthread_create(&threads[i], NULL, lsearch, (void*) &data[i]);
+	}
+	for (step = i, i = 0; i < step; i++) {
+		pthread_join(threads[i], NULL);
+		if (data[i].ln_n < 0) {
+			*r = *data[i].r;
+			*o = *data[i].o;
+			for (int z = i+1; z < step; z++)
+				data[z].ln_n = -1;
+			/* force instant termination, regardless how long string is */
+			utf8_length = fake_ulen;
+			for (int z = i+1; z < step; z++)
+				pthread_join(threads[z], NULL);
+			utf8_length = _utf8_length;
+			utf8_length['\n'] = 1;
+			return 0;
+		}
+	}
+	utf8_length['\n'] = 1;
+	return 1;
 }
 
 int lbuf_sectionbeg(struct lbuf *lb, int dir, int *row, int *off, int ch)
diff --git a/regex.c b/regex.c
index 9f690cc..cc40094 100644
--- a/regex.c
+++ b/regex.c
@@ -312,7 +312,7 @@ int reg_comp(rcode *prog, const char *re, int nsubs, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (flg & REG_NEWLINE) utf8_length[eol_ch] = 1; return state; } \
 
 #define newsub(init, copy) \
 if (freesub) \
@@ -543,8 +543,10 @@ int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, int flg)
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
 	char nsubs[prog->sub];
 	flg = prog->flg | flg;
-	if (eol_ch)
+	if (eol_ch && utf8_length[eol_ch])
 		utf8_length[eol_ch] = 0;
+	else
+		flg &= ~REG_NEWLINE;
 	if (flg & REG_ICASE)
 		goto jmp_start1;
 	goto jmp_start2;
diff --git a/uc.c b/uc.c
index b05db93..7298b6a 100644
--- a/uc.c
+++ b/uc.c
@@ -1,4 +1,4 @@
-unsigned char utf8_length[256] = {
+unsigned char _utf8_length[256] = {
 	/*	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
 	/* 0 */ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	/* 1 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
@@ -17,6 +17,7 @@ unsigned char utf8_length[256] = {
 	/* E */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 	/* F */ 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1
 };
+unsigned char *utf8_length = _utf8_length;
 
 /* the number of utf-8 characters in a fat nulled s */
 int uc_slen(char *s)
diff --git a/vi.c b/vi.c
index 4579e1a..3983623 100644
--- a/vi.c
+++ b/vi.c
@@ -30,6 +30,7 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
+#include <pthread.h>
 #include "vi.h"
 #include "conf.c"
 #include "ex.c"
diff --git a/vi.h b/vi.h
index d8c7a06..c4854cc 100644
--- a/vi.h
+++ b/vi.h
@@ -215,7 +215,9 @@ void syn_addhl(char *reg, int id, int reload);
 void syn_init(void);
 
 /* uc.c utf-8 helper functions */
-extern unsigned char utf8_length[256];
+extern unsigned char _utf8_length[256];
+extern unsigned char *utf8_length;
+
 /* return the length of a utf-8 character */
 #define uc_len(s) utf8_length[(unsigned char)s[0]]
 /* the unicode codepoint of the given utf-8 character */
