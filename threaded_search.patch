diff --git a/cbuild.sh b/cbuild.sh
index 2372d3b8..3b294bc7 100755
--- a/cbuild.sh
+++ b/cbuild.sh
@@ -47,6 +47,7 @@ CFLAGS="\
 -Wno-unused-parameter \
 -Wno-unused-result \
 -Wfatal-errors -std=c99 \
+-lpthread \
 $CFLAGS"
 
 case "$OS" in
diff --git a/lbuf.c b/lbuf.c
index cedc3cdf..86d7d40d 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -403,24 +403,30 @@ int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *row, int *off)
 	return n != 0;
 }
 
-int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
-			int *o, int ln_n, int skip)
+struct lsparams
 {
-	int r0 = *r, o0 = *o;
-	int offs[re->grpcnt * 2], i = r0;
-	char *s = lbuf_get(lb, i);
-	int off, g1, g2, _o, step, flg;
-	if (skip >= 0 && s)
-		off = rstate->s == s ? rstate->chrs[MIN(o0 + skip, rstate->n)] - s
-					: uc_chr(s, o0 + skip) - s;
-	else
-		off = 0;
-	for (; i >= 0 && i < ln_n; i += dir) {
+	struct lbuf *lb;
+	rset *re;
+	int dir;
+	int ln_n;
+	int *r;
+	int *o;
+	int off;
+};
+
+static void *lsearch(void *arg)
+{
+	struct lsparams *a = arg;
+	int r0 = *a->r, o0 = *a->o;
+	int offs[a->re->grpcnt * 2], i = r0;
+	char *s;
+	int off = a->off, g1, g2, _o, step, flg;
+	for (; i >= 0 && i < a->ln_n; i += a->dir) {
 		_o = 0;
 		step = 0;
 		flg = REG_NEWLINE;
-		s = lb->ln[i];
-		while (rset_find(re, s + off, offs, flg) >= 0) {
+		s = a->lb->ln[i];
+		while (rset_find(a->re, s + off, offs, flg) >= 0) {
 			flg |= REG_NOTBOL;
 			g1 = offs[xgrp], g2 = offs[xgrp + 1];
 			if (g1 < 0) {
@@ -428,19 +434,75 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 				continue;
 			}
 			_o += uc_off(s + step, off + g1 - step);
-			if (dir < 0 && r0 == i && _o >= o0)
+			if (a->dir < 0 && r0 == i && _o >= o0)
 				break;
-			*o = _o;
-			*r = i;
-			if (dir > 0)
-				return 0;
+			*a->o = _o;
+			*a->r = i;
 			step = off + g1;
 			off += g2 > 0 ? g2 : 1;
-			ln_n = -1; /* break outer loop efficiently */
+			a->ln_n = -1; /* break outer loop efficiently */
+			if (a->dir > 0)
+				return NULL;
 		}
 		off = 0;
 	}
-	return ln_n < 0 ? 0 : 1;
+	return NULL;
+}
+
+int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
+			int *o, int ln_n, int skip)
+{
+	#define NUM_THREADS 4
+	pthread_t threads[NUM_THREADS];
+	static unsigned char fake_ulen[256]; /* novelty: for fast thread termination */
+	struct lsparams data[NUM_THREADS];
+	int rs[NUM_THREADS];
+	int os[NUM_THREADS];
+	int thread_step = ln_n / NUM_THREADS; /* number of lines assigned per thread */
+	int step = 0, i = 0, off;
+	char *s = lbuf_get(lb, *r);
+	if (skip >= 0 && s)
+		off = rstate->s == s ? rstate->chrs[MIN(*o + skip, rstate->n)] - s
+					: uc_chr(s, *o + skip) - s;
+	else
+		off = 0;
+	utf8_length['\n'] = 0;
+	for (i = 0; i < NUM_THREADS; i++) {
+		if (*r + step > ln_n || *r + step * dir < 0)
+			break;
+		data[i].lb = lb;
+		data[i].re = re;
+		data[i].dir = dir;
+		data[i].off = i ? 0 : off;
+		rs[i] = *r + step * dir;
+		step += thread_step;
+		data[i].r = &rs[i];
+		if (i == NUM_THREADS-1)
+			data[i].ln_n = ln_n;
+		else
+			data[i].ln_n = MIN(rs[i] + thread_step, ln_n);
+		os[i] = i ? -1 : *o;
+		data[i].o = &os[i];
+		pthread_create(&threads[i], NULL, lsearch, (void*) &data[i]);
+	}
+	for (step = i, i = 0; i < step; i++) {
+		pthread_join(threads[i], NULL);
+		if (data[i].ln_n < 0) {
+			*r = *data[i].r;
+			*o = *data[i].o;
+			for (int z = i+1; z < step; z++)
+				data[z].ln_n = -1;
+			/* force instant termination, regardless how long string is */
+			utf8_length = fake_ulen;
+			for (int z = i+1; z < step; z++)
+				pthread_join(threads[z], NULL);
+			utf8_length = _utf8_length;
+			utf8_length['\n'] = 1;
+			return 0;
+		}
+	}
+	utf8_length['\n'] = 1;
+	return 1;
 }
 
 int lbuf_sectionbeg(struct lbuf *lb, int dir, int *row, int *off, int ch)
diff --git a/regex.c b/regex.c
index 700158e4..0bced731 100644
--- a/regex.c
+++ b/regex.c
@@ -380,7 +380,7 @@ static int reg_comp(rcode *prog, char *re, int nsubs, int laidx, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (flg & REG_NEWLINE) utf8_length[eol_ch] = 1; return state; } \
 
 #define newsub(init, copy) \
 if (freesub) { \
@@ -610,8 +610,10 @@ static int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, i
 	flg = prog->flg | flg;
 	for (i = 0; i < prog->laidx; i++)
 		lb[i] = NULL;
-	if (eol_ch)
+	if (eol_ch && utf8_length[eol_ch])
 		utf8_length[eol_ch] = 0;
+	else
+		flg &= ~REG_NEWLINE;
 	if (flg & REG_ICASE)
 		goto jmp_start1;
 	goto jmp_start2;
diff --git a/uc.c b/uc.c
index bc22a958..130772b3 100644
--- a/uc.c
+++ b/uc.c
@@ -1,4 +1,4 @@
-unsigned char utf8_length[256] = {
+unsigned char _utf8_length[256] = {
 	/*	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
 	/* 0 */ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	/* 1 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
@@ -17,6 +17,7 @@ unsigned char utf8_length[256] = {
 	/* E */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 	/* F */ 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1
 };
+unsigned char *utf8_length = _utf8_length;
 
 /* the number of utf-8 characters in a fat nulled s */
 int uc_slen(char *s)
diff --git a/vi.c b/vi.c
index 79cdac30..c15a0a08 100644
--- a/vi.c
+++ b/vi.c
@@ -13,6 +13,7 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
+#include <pthread.h>
 #include "vi.h"
 #include "conf.c"
 #include "ex.c"
diff --git a/vi.h b/vi.h
index 1bef0600..08be5917 100644
--- a/vi.h
+++ b/vi.h
@@ -264,7 +264,8 @@ int syn_addhl(char *reg, int id);
 void syn_init(void);
 
 /* uc.c utf-8 helper functions */
-extern unsigned char utf8_length[256];
+extern unsigned char _utf8_length[256];
+extern unsigned char *utf8_length;
 extern int zwlen, def_zwlen;
 extern int bclen, def_bclen;
 /* return the length of a utf-8 character */
