#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! @|vis 6@1414a 	{\"lw\", ec_linewrap},
.
@vis 4@vis 6@1300a static void *ec_linewrap(char *loc, char *cmd, char *arg)
{
	int fd;
	if (xb->modified)
		return \"unsaved changes present\";
	if (*arg)
		xlw = atoi(arg);
	else
		xlw = xcols;
	lbuf_free(xb);
	xb = lbuf_make();
	readfile()
	ex_bufpostfix(ex_buf, 1);
	syn_setft(xb_ft);
	return NULL;
}

.
@vis 4@vis 6@25a int xlw;			/* soft linewrap col */
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: lbuf.c
EXINIT="rcm:|sc! @|vis 6@375a 		/* relink chain: restored lines have their pointers from edit time */
		if (xlw) {
			for (int i = 0; i < lo->n_ins; i++) {
				char *ln = lo->ins[i];
				char *prev = lbuf_s(ln)->lw_prev;
				char *next = lbuf_s(ln)->lw_next;
				if (prev)
					lbuf_s(prev)->lw_next = ln;
				if (next)
					lbuf_s(next)->lw_prev = ln;
			}
			/* pure deletion redo: link the chain around removed lines */
			if (lo->n_del > 0 && lo->n_ins == 0) {
				char *pred = lbuf_s(lo->del[0])->lw_prev;
				char *succ = lbuf_s(lo->del[lo->n_del - 1])->lw_next;
				if (pred)
					lbuf_s(pred)->lw_next = succ;
				if (succ)
					lbuf_s(succ)->lw_prev = pred;
			}
		}
.
@vis 4@vis 6@353a 		/* relink chain: restored lines have original pointers */
		if (xlw) {
			for (int i = 0; i < lo->n_del; i++) {
				char *ln = lo->del[i];
				char *prev = lbuf_s(ln)->lw_prev;
				char *next = lbuf_s(ln)->lw_next;
				if (prev)
					lbuf_s(prev)->lw_next = ln;
				if (next)
					lbuf_s(next)->lw_prev = ln;
			}
			/* pure insertion undo: link the chain around removed lines */
			if (lo->n_ins > 0 && lo->n_del == 0) {
				char *pred = lbuf_s(lo->ins[0])->lw_prev;
				char *succ = lbuf_s(lo->ins[lo->n_ins - 1])->lw_next;
				if (pred)
					lbuf_s(pred)->lw_next = succ;
				if (succ)
					lbuf_s(succ)->lw_prev = pred;
			}
		}
.
@vis 4@vis 6@240;30;31c (!lbuf_s(ln)->lw_next)
.
@vis 4@vis 6@193a 	/* relink the chain after edit */
	if (xlw && (chain_pred || chain_succ)) {
		if (lo->n_ins > 0) {
			char *first_new = lb->ln[beg];
			char *last_new = lb->ln[beg + lo->n_ins - 1];
			if (chain_pred) {
				lbuf_s(chain_pred)->lw_next = first_new;
				lbuf_s(first_new)->lw_prev = chain_pred;
			}
			if (chain_succ) {
				lbuf_s(last_new)->lw_next = chain_succ;
				lbuf_s(chain_succ)->lw_prev = last_new;
			}
		} else {
			/* no new lines inserted, link predecessor to successor */
			if (chain_pred)
				lbuf_s(chain_pred)->lw_next = chain_succ;
			if (chain_succ)
				lbuf_s(chain_succ)->lw_prev = chain_pred;
		}
	}
.
@vis 4@vis 6@190a 	/* save chain boundary pointers before edit */
	char *chain_pred = NULL, *chain_succ = NULL;
	if (xlw) {
		if (beg < end) {
			/* deletion case: save the chain links of deleted range */
			chain_pred = lbuf_s(lb->ln[beg])->lw_prev;
			chain_succ = lbuf_s(lb->ln[end - 1])->lw_next;
		} else if (beg > 0 && beg < lb->ln_n) {
			/* pure insertion: check if inserting into middle of a chain */
			char *prev_ln = lb->ln[beg - 1];
			char *next_ln = lb->ln[beg];
			if (lbuf_s(prev_ln)->lw_next == next_ln) {
				/* inserting into a chain - need to break/relink */
				chain_pred = prev_ln;
				chain_succ = next_ln;
			}
		}
	}
.
@vis 4@vis 6@94a 			if (xlw) {
				rstate->s = NULL;
				ren_state *r = ren_position(ln);
				if (r->cmax > xlw) {
					l_nonl = l;
					l = uc_chr(r->s, r->col[xlw]) - r->s;
					if (l <= 0) {
						l = l_nonl;
						goto too_small;
					}
					l_nonl = l - (ln[l - !!l] == '\\n');
					n = erealloc(n, l_nonl + 5 + sizeof(struct linfo));
					n->len = l_nonl;
					n->grec = 0;
					n->lw_prev = lwp;
					n->lw_next = NULL;
					ln = (char*)(n + 1);
					if (lwp)
						lbuf_s(lwp)->lw_next = ln;
					lwp = ln;
					memcpy(ln, s, l_nonl);
					memset(&ln[l_nonl + 1], 0, 4);	/* fault tolerance pad */
					ln[l_nonl] = '\\n';
				} else {
					if (lwp)
						lbuf_s(lwp)->lw_next = ln;
					n->lw_prev = lwp;
					lwp = NULL;
				}
			}
			too_small:
.
@vis 4@vis 6@90a 			n->lw_prev = NULL;
			n->lw_next = NULL;
.
@vis 4@vis 6@84a 		char *lwp = NULL;
.
@vis 4@wq" $VI -e 'lbuf.c'

# Patch: vi.c
EXINIT="rcm:|sc! @|vis 6@171a 	if (xlw && s) {
		led_att la;
		if (!led_attsb)
			sbuf_make(led_attsb, sizeof(la))
		if (lbuf_s(s)->lw_next && !lbuf_s(s)->lw_prev) {
			la.s = s;
			la.off = 0;
			la.att = SYN_BGMK(8);
			sbuf_mem(led_attsb, &la, (int)sizeof(la))
		} else if (!lbuf_s(s)->lw_next && lbuf_s(s)->lw_prev) {
			la.s = s;
			la.off = ren_position(s)->n-1;
			la.att = SYN_BGMK(9);
			sbuf_mem(led_attsb, &la, (int)sizeof(la))
		}
	}
.
@vis 4@wq" $VI -e 'vi.c'

# Patch: vi.h
EXINIT="rcm:|sc! @|vis 6@432a extern int xlw;
.
@vis 4@vis 6@147a 	char *lw_prev;
	char *lw_next;
.
@vis 4@wq" $VI -e 'vi.h'
