diff --git a/led.c b/led.c
index 98ad4070..ff9bd9bd 100644
--- a/led.c
+++ b/led.c
@@ -3,6 +3,7 @@
 static sbuf *suggestsb;
 static sbuf *acsb;
 sbuf *led_attsb;
+static int vi_insmov;
 
 int dstrlen(const char *s, char delim)
 {
@@ -280,7 +281,7 @@ static int led_lastword(char *s)
 }
 
 static void led_printparts(sbuf *sb, int pre, int ps,
-	char *post, int postn, int ai_max)
+	char *post, int postn, int ai_max, int print)
 {
 	if (!xled) {
 		sbufn_null(sb)
@@ -307,8 +308,10 @@ static void led_printparts(sbuf *sb, int pre, int ps,
 	}
 	if (pos >= xleft + xcols || pos < xleft)
 		xleft = pos < xcols ? 0 : pos - xcols / 2;
-	syn_blockhl = -1;
-	led_crender(r->s, -1, vi_lncol, xleft, xleft + xcols - vi_lncol);
+	if (print) {
+		syn_blockhl = -1;
+		led_crender(r->s, -1, vi_lncol, xleft, xleft + xcols - vi_lncol);
+	}
 	term_pos(-1, led_pos(r->s, pos) + vi_lncol);
 	sbufn_cut(sb, psn)
 	rstate -= 2;
@@ -411,7 +414,8 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 	char *cs;
 	int len, c, i;
 	do {
-		led_printparts(sb, pre, ps, *post, postn, ai_max);
+		led_printparts(sb, pre, ps, *post, postn, ai_max, !vi_insmov);
+		vi_insmov = 0;
 		len = sb->s_n;
 		c = term_read();
 		switch (c) {
@@ -608,6 +612,56 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 			else
 				led_redraw(sb->s, 0, orow, crow, ctop, flg);
 			continue;
+		case '\033':;	/* Arrow keys */
+			char cbuf[1];
+			cbuf[0] = '\0';
+			int fl = fcntl(STDIN_FILENO, F_GETFL);
+			fcntl(STDIN_FILENO, F_SETFL, fl | O_NONBLOCK);
+			read(STDIN_FILENO, cbuf, 1);
+			if (*cbuf == '[') {
+				read(STDIN_FILENO, cbuf, 1);
+				fcntl(STDIN_FILENO, F_SETFL, fl);
+				if (ai_max < 0) {
+					/* Prompt mode: handle arrows internally */
+					int lc, clen, plen;
+					char *newpost;
+					switch (*cbuf) {
+					case 'D':  /* ← */
+						if (len > pre) {
+							lc = led_lastchar(sb->s + pre) + pre;
+							clen = len - lc;
+							plen = strlen(*post);
+							newpost = malloc(plen + clen + 1);
+							memcpy(newpost, sb->s + lc, clen);
+							memcpy(newpost + clen, *post, plen + 1);
+							free(*postref);
+							*postref = *post = newpost;
+							postn++;
+							sbuf_cut(sb, lc)
+						}
+						continue;
+					case 'C':  /* → */
+						if (**post) {
+							clen = uc_len(*post);
+							sbuf_mem(sb, *post, clen)
+							plen = strlen(*post);
+							newpost = malloc(plen - clen + 1);
+							memcpy(newpost, *post + clen, plen - clen + 1);
+							free(*postref);
+							*postref = *post = newpost;
+							postn--;
+						}
+						continue;
+					case 'A':  /* ↑ - history */
+					case 'B':  /* ↓ - history */
+						continue;
+					}
+				}
+				vi_insmov = *cbuf;
+				return *cbuf;
+			}
+			fcntl(STDIN_FILENO, F_SETFL, fl);
+			return c;
 		case TK_CTL('o'): {
 			if (!*postref)
 				*postref = *post = uc_dup(*post);
@@ -643,7 +697,7 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 int led_prompt(sbuf *sb, char *insert, int *kmap, ins_state *is, int ps, int flg)
 {
 	int n = !(flg & 2) ? sb->s_n : 0, key;
-	char *post = "", *postref = post;
+	char *post = "", *postref = NULL;
 	ins_state _is;
 	vi_lncol = 0;
 	if (insert)
@@ -655,6 +709,8 @@ int led_prompt(sbuf *sb, char *insert, int *kmap, ins_state *is, int ps, int flg
 	preserve(int, xtd, xtd = 2;)
 	key = led_line(sb, ps, n, &post, 0, &postref, -1, kmap, is, 0, xrow, xtop, flg);
 	restore(xtd)
+	sbufn_str(sb, post)
+	free(postref);
 	if (key == '\n' && flg & 1) {
 		lbuf_dedup(tempbufs[0].lb, sb->s + n, sb->s_n - n)
 		temp_pos(0, -1, 0, 0);
@@ -685,7 +741,7 @@ int led_input(sbuf *sb, char *post, int postn, int row, int flg, int *pren)
 			return key;
 		}
 		sbuf_chr(sb, key)
-		led_printparts(sb, -1, ps, "", 0, 0);
+		led_printparts(sb, -1, ps, "", 0, 0, 1);
 		term_chr('\n');
 		term_room(1);
 		crow++;
diff --git a/vi.c b/vi.c
index 15dcd18e..f881f8e8 100644
--- a/vi.c
+++ b/vi.c
@@ -856,6 +856,8 @@ static void vi_indents(char *ln, int *l)
 	*l = ln - pln;
 }
 
+static int lmodified;
+
 static int vi_change(int r1, int o1, int r2, int o2, int lnmode)
 {
 	char *post, *ln = lbuf_get(xb, r1);
@@ -887,6 +889,7 @@ static int vi_change(int r1, int o1, int r2, int o2, int lnmode)
 	if (postn + l2 != tlen || memcmp(ln + l1, sb->s + l1, tlen - l2 - l1))
 		lbuf_edit(xb, sb->s, r1, r2 + 1, o1, xoff);
 	free(sb->s);
+	lmodified = 1;
 	return key;
 }
 
@@ -1055,8 +1058,11 @@ static int vc_insert(int cmd)
 	term_room(cmdo);
 	sbuf_mem(sb, ln, l1)
 	key = led_input(sb, post, postn, row, cmdo << 2, &postn);
-	if (postn != l1 || cmdo || !ln)
+	if (postn != l1 || cmdo || !ln) {
 		lbuf_edit(xb, sb->s, row, row + !cmdo, off, xoff);
+		lmodified = 1;
+	} else
+		lmodified = 0;
 	free(sb->s);
 	return key;
 }
@@ -1516,9 +1522,43 @@ void vi(int init)
 					term_back(xoff != lbuf_eol(xb, xrow, 1) ? 'i' : 'a');
 					break;
 				}
+				switch (k) {
+				case 'A':	/* ↑ */
+					term_back(!lmodified ? c : 'i');
+					if (lmodified)
+						vi_col = vi_off2col(xb, xrow, xoff);
+					xrow--;
+					xrow = xrow < 0 ? 0 : xrow;
+					xoff = vi_col2off(xb, xrow, vi_col);
+					lmodified = 0;
+					goto _break;
+				case 'B':	/* ↓ */
+					term_back(!lmodified ? c : 'i');
+					if (lmodified)
+						vi_col = vi_off2col(xb, xrow, xoff);
+					xrow++;
+					xoff = vi_col2off(xb, xrow, vi_col);
+					lmodified = 0;
+					goto _break;
+				case 'D':	/* ← */
+					term_back('i');
+					xoff--;
+					xoff = xoff < 0 ? 0 : xoff;
+					vi_col = vi_off2col(xb, xrow, xoff);
+					goto _break;
+				case 'C':	/* → */
+					term_back(*uc_chr(lbuf_get(xb, xrow), xoff+2) ? 'i' : 'A');
+					xoff++;
+					if (*uc_chr(lbuf_get(xb, xrow), xoff))
+						vi_col = vi_off2col(xb, xrow, xoff);
+					goto _break;
+				}
 				if (c != 'A' && c != 'C')
 					xoff--;
 				break;
+				_break:
+				vi_mod = 0;
+				break;
 			case 'J':
 				vc_join(1, vi_arg <= 1 ? 2 : vi_arg);
 				break;
