diff --git a/ex.c b/ex.c
index e41edeb..9188df1 100644
--- a/ex.c
+++ b/ex.c
@@ -33,6 +33,7 @@ int xkwddir;			/* the last search direction */
 int xmpt;			/* whether to prompt after printing > 1 lines in vi */
 int xpr;			/* ex_cprint register */
 int xsep = ':';			/* ex command separator */
+int xlw = 40;			/* soft linewrap col */
 char *xregs[256];		/* string registers */
 static int xbufsmax;		/* number of buffers */
 static int xbufsalloc = 10;	/* initial number of buffers */
diff --git a/lbuf.c b/lbuf.c
index 0649f71..205a4ed 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -70,25 +70,136 @@ static int linelength(char *s)
 	return s[len] == '\n' ? len + 1 : len;
 }
 
+static char *lbuf_cat(struct lbuf *lb, int beg, int end)
+{
+	sbuf_smake(sb, 64)
+	for (int i = beg; i < end; i++)
+		if (i < lb->ln_n)
+			sbuf_mem(sb, lb->ln[i], lbuf_s(lb->ln[i])->len)
+	sbufn_sret(sb)
+}
+
 /* low-level line replacement */
 static int lbuf_replace(struct lbuf *lb, char *s, struct lopt *lo, int n_del)
 {
 	int i, n_ins = 0, pos = lo->pos;
+	int r_ins;
+	int relink = 0;
 	sbuf_smake(sb, 0)
+	char *nwp = lbuf_get(lb, pos);
 	if (s) {
+		char *lwp = NULL;
+		sbuf_smake(nsb, 0)
+		int org = pos;
+		int p_ndel = n_del;
+		if (s == lo->del || s == lo->ins) {
+			relink = 1;
+			goto skip;
+		}
+		if (!n_del && nwp && (!lbuf_s(nwp)->lw_prev))
+			goto skip;
+		while (nwp && lbuf_s(nwp)->lw_prev) {
+			nwp = lbuf_s(nwp)->lw_prev;
+			pos--;
+		}
+		//p("%s %d %d %d %d\n", nwp, n_del, pos, org, n_ins)
+		if (org != pos || (nwp && lbuf_s(nwp)->lw_next)) {
+			//p("%d\n", n_del)
+			n_del = 0;
+			while (nwp) {
+				//p("%s %d\n", nwp, lbuf_s(nwp)->len)
+				if (org - pos == n_del) {
+					for (r_ins = 0; *s; r_ins++) {
+						int l = linelength(s);
+						int l_nonl = l - (s[l - !!l] == '\n');
+						//p("pre: %d %d %d %d\n", l, l_nonl, nsb->s_n, nsb->s_sz)
+						sbuf_mem(nsb, s, l_nonl)
+						//p("aft: %d %d %d %d\n", l, l_nonl, nsb->s_n, nsb->s_sz)
+						s += l;
+					}
+					if (!p_ndel)
+						sbuf_mem(nsb, nwp, lbuf_s(nwp)->len)
+				} else
+					sbuf_mem(nsb, nwp, lbuf_s(nwp)->len)
+				nwp = lbuf_s(nwp)->lw_next;
+				n_del++;
+			}
+		}
+		//p("%d\n", nsb->s_n)
+		if (nsb->s_n > 0) {
+			s = nsb->s;
+			sbuf_null(nsb)
+			lo->n_del = n_del;
+			lo->pos = pos;
+			if (lo->ins) {
+				free(lo->ins);
+				lo->ins = s;
+			}
+			if (lo->del) {
+				free(lo->del);
+				lo->del = n_del ? lbuf_cat(lb, pos, pos + n_del) : NULL;
+			}
+			//p("%s", lo->del);
+			//p("%s", s);
+		}
+		skip:
 		for (; *s; n_ins++) {
 			int l = linelength(s);
 			int l_nonl = l - (s[l - !!l] == '\n');
 			struct linfo *n = emalloc(l_nonl + 7 + sizeof(struct linfo));
 			n->len = l_nonl;
 			n->grec = 0;
+			n->lw_prev = NULL;
+			n->lw_next = NULL;
 			char *ln = (char*)(n + 1);
 			memcpy(ln, s, l_nonl);
 			memset(&ln[l_nonl + 1], 0, 5);	/* fault tolerance pad */
 			ln[l_nonl] = '\n';
+			if (xlw) {
+				rstate->s = NULL;
+				ren_state *r = ren_position(ln);
+				if (r->cmax > xlw) {
+					l = uc_chr(r->s, r->col[xlw]) - r->s;
+					if (l <= 0)
+						abort();
+					l_nonl = l - (ln[l - !!l] == '\n');
+					n = erealloc(n, l_nonl + 7 + sizeof(struct linfo));
+					n->len = l_nonl;
+					n->grec = 0;
+					n->lw_prev = lwp;
+					n->lw_next = NULL;
+					ln = (char*)(n + 1);
+					if (lwp)
+						lbuf_s(lwp)->lw_next = ln;
+					lwp = ln;
+					memcpy(ln, s, l_nonl);
+					memset(&ln[l_nonl + 1], 0, 5);	/* fault tolerance pad */
+					ln[l_nonl] = '\n';
+				} else {
+					if (lwp)
+						lbuf_s(lwp)->lw_next = ln;
+					n->lw_prev = lwp;
+					lwp = NULL;
+				}
+			}
 			sbuf_mem(sb, &ln, (int)sizeof(s))
 			s += l;
 		}
+		if (!lo->ins)
+			free(nsb->s);
+	} else if (xlw && n_del) {
+		if (nwp && lbuf_s(nwp)->lw_prev) {
+			nwp = lbuf_s(nwp)->lw_prev;
+			lbuf_s(nwp)->lw_next = NULL;
+			lo->unlinked1 = nwp;
+		}
+		nwp = lbuf_get(lb, pos + (n_del-1));
+		if (nwp && lbuf_s(nwp)->lw_next) {
+			nwp = lbuf_s(nwp)->lw_next;
+			lbuf_s(nwp)->lw_prev = NULL;
+			lo->unlinked2 = nwp;
+		}
+		//p("%p %p\n", lo->unlinked1, lo->unlinked2)
 	}
 	for (i = 0; i < n_del; i++)
 		free(lbuf_i(lb, pos + i));
@@ -108,6 +219,18 @@ static int lbuf_replace(struct lbuf *lb, char *s, struct lopt *lo, int n_del)
 	lb->ln_n += n_ins - n_del;
 	for (i = 0; i < n_ins; i++)
 		lb->ln[pos + i] = *((char**)sb->s + i);
+	//p("relink: %d\n", relink)
+	if (relink && n_ins) {
+		//p("%p %p\n", lo->unlinked1, lo->unlinked2)
+		if (lo->unlinked1) {
+			lbuf_s(lo->unlinked1)->lw_next = lb->ln[pos];
+			lbuf_s(lb->ln[pos])->lw_prev = lo->unlinked1;
+		}
+		if (lo->unlinked2) {
+			lbuf_s(lo->unlinked2)->lw_prev = lb->ln[pos + (n_ins-1)];
+			lbuf_s(lb->ln[pos + (n_ins-1)])->lw_next = lo->unlinked2;
+		}
+	}
 	for (i = 0; i < NMARKS_BASE; i++) {	/* updating marks */
 		if (!s && lb->mark[i] >= pos && lb->mark[i] < pos + n_del) {
 			lbuf_savemark(lb, lo, i, i);
@@ -157,6 +280,8 @@ struct lopt *lbuf_opt(struct lbuf *lb, char *buf, int pos, int n_del, int init)
 	lo->pos = pos;
 	lo->n_ins = 0;
 	lo->n_del = n_del;
+	lo->unlinked1 = NULL;
+	lo->unlinked2 = NULL;
 	lo->pos_off = lb->mark[markidx('*')] >= 0 ? lb->mark_off[markidx('*')] : 0;
 	lo->seq = lb->useq;
 	lo->mark = emalloc(sizeof(lb->mark));
@@ -165,6 +290,11 @@ struct lopt *lbuf_opt(struct lbuf *lb, char *buf, int pos, int n_del, int init)
 	return lo;
 }
 
+void lbuf_lw(struct lbuf *lb, int i)
+{
+
+}
+
 int lbuf_rd(struct lbuf *lbuf, int fd, int beg, int end, int init)
 {
 	long nr;
@@ -188,7 +318,8 @@ int lbuf_wr(struct lbuf *lbuf, int fd, int beg, int end)
 	for (int i = beg; i < end; i++) {
 		char *ln = lbuf->ln[i];
 		long nw = 0;
-		long nl = lbuf_s(ln)->len + 1;
+		long nl = lbuf_s(ln)->len + (!lbuf_s(ln)->lw_next);
+		//p("%p\n", lbuf_s(ln)->lw_next)
 		while (nw < nl) {
 			long nc = write(fd, ln + nw, nl - nw);
 			if (nc < 0)
diff --git a/regex.c b/regex.c
index 3353c28..4fa34e8 100644
--- a/regex.c
+++ b/regex.c
@@ -590,6 +590,7 @@ int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, int flg)
 	int *pcs[prog->splits];
 	rsub *subs[prog->splits];
 	unsigned int sdense[prog->sparsesz], sparsesz = 0;
+	memset(sdense, 0, sizeof(int) * prog->sparsesz);
 	rsub *nsub, *s1, *matched = NULL, *freesub = NULL;
 	rthread _clist[prog->len], _nlist[prog->len];
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
diff --git a/vi.h b/vi.h
index f00adb9..50e7d44 100644
--- a/vi.h
+++ b/vi.h
@@ -47,11 +47,11 @@ typedef struct sbuf {
 
 #define sbuf_extend(sb, newsz) \
 { \
-	char *s = sb->s; \
+	char *__s_ = sb->s; \
 	sb->s_sz = newsz; \
 	sb->s = emalloc(sb->s_sz); \
-	memcpy(sb->s, s, sb->s_n); \
-	free(s); \
+	memcpy(sb->s, __s_, sb->s_n); \
+	free(__s_); \
 } \
 
 #define _sbuf_make(sb, newsz, alloc) \
@@ -135,6 +135,8 @@ char *re_read(char **src);
 struct lopt {
 	char *ins;		/* inserted text */
 	char *del;		/* deleted text */
+	char *unlinked1;
+	char *unlinked2;
 	int pos, n_ins, n_del;	/* modification location */
 	int pos_off;		/* cursor line offset */
 	int seq;		/* operation number */
@@ -143,6 +145,8 @@ struct lopt {
 struct linfo {
 	int len;
 	int grec;
+	char *lw_prev;
+	char *lw_next;
 };
 struct lbuf {
 	char **ln;		/* buffer lines */
@@ -165,6 +169,7 @@ struct lbuf *lbuf_make(void);
 void lbuf_free(struct lbuf *lbuf);
 int lbuf_rd(struct lbuf *lbuf, int fd, int beg, int end, int init);
 int lbuf_wr(struct lbuf *lbuf, int fd, int beg, int end);
+void lbuf_lw(struct lbuf *lb, int i);
 void lbuf_iedit(struct lbuf *lbuf, char *s, int beg, int end, int init);
 #define lbuf_edit(lb, s, beg, end) lbuf_iedit(lb, s, beg, end, 0)
 char *lbuf_cp(struct lbuf *lbuf, int beg, int end);
