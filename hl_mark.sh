#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: ex.c
EXINIT="rcm:|sc! @|vis 6@%;f> int xhlw;			/\\\\* highlight current word \\\\*/
int xhlp;			/\\\\* highlight \\\\{\\\\}\\\\[\\\\]\\\\(\\\\) pair \\\\*/
int xhlr;			/\\\\* highlight text in reverse direction \\\\*/@;=
@.+2a int xhlm;			/* highlight marks */
.
@.,$;f+ EO\\\\(pac\\\\) EO\\\\(pr\\\\) EO\\\\(ai\\\\) EO\\\\(err\\\\) EO\\\\(ish\\\\) EO\\\\(ic\\\\) EO\\\\(grp\\\\) EO\\\\(mpt\\\\) EO\\\\(rcm\\\\)
EO\\\\(shape\\\\) EO\\\\(seq\\\\) EO\\\\(ts\\\\) EO\\\\(td\\\\) EO\\\\(order\\\\) EO\\\\(hll\\\\) EO\\\\(hlw\\\\)
EO\\\\(hlp\\\\) EO\\\\(hlr\\\\) EO\\\\(hl\\\\) EO\\\\(lim\\\\) EO\\\\(led\\\\) EO\\\\(vis\\\\)@;=
@.+2a EO(hlm)
.
@.,$;f+ 	EO\\\\(ts\\\\),
	EO\\\\(td\\\\),
	EO\\\\(order\\\\),@;=
@.+2a 	EO(hlm),
.
@vis 4@wq" $VI -e 'ex.c'

# Patch: vi.c
EXINIT="rcm:|sc! @|vis 6@%;f> 				word = cs;
			\\\\}
		\\\\}@;=
@.+2a 		if (xhlm) {
			int mrow, moff;
			char marks[] = \"abcdefghijklmnopqrstuvwxyz[]\`*\";
			led_att la;
			if (!led_attsb)
				sbuf_make(led_attsb, sizeof(la))
			for (int i = 0; i < LEN(marks); i++) {
				if (lbuf_jump(xb, marks[i], &mrow, &moff))
					continue;
				la.s = lbuf_get(xb, mrow);
				la.off = moff;
				la.att = SYN_BGMK(((i % 15) + 1));
				sbuf_mem(led_attsb, &la, (int)sizeof(la))
			}
		}
.
@vis 4@wq" $VI -e 'vi.c'
