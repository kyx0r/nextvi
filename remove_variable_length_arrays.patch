diff --git a/ex.c b/ex.c
index 05fb5a0..4eb58a5 100644
--- a/ex.c
+++ b/ex.c
@@ -697,7 +697,6 @@ static void replace(sbuf *dst, char *rep, char *ln, int *offs)
 static int ec_substitute(char *loc, char *cmd, char *arg)
 {
 	int beg, end, grp = xgrp != 2 ? xgrp : 32;
-	int offs[grp];
 	char *pat = NULL, *rep = NULL;
 	char *s = arg;
 	int i, first = -1, last;
@@ -715,6 +714,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	free(rep);
 	if (!xkwdrs)
 		return 1;
+	int *offs = emalloc(grp * sizeof(int));
 	for (i = beg; i < end; i++) {
 		char *ln = lbuf_get(xb, i);
 		sbuf *r = NULL;
@@ -745,6 +745,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	}
 	if (first >= 0)
 		lbuf_emark(xb, lbuf_opt(xb, NULL, xrow, 0), first, last);
+	free(offs);
 	return 0;
 }
 
@@ -1088,7 +1089,7 @@ static const char *ex_parse(const char *src, char *loc, char *cmd, char *arg)
 int ex_exec(const char *ln)
 {
 	int ret = 0, len = strlen(ln) + 1;
-	char loc[len], cmd[len], arg[len];
+	char *loc = emalloc(len), *cmd = emalloc(len), *arg = emalloc(len);
 	while (*ln) {
 		ln = ex_parse(ln, loc, cmd, arg);
 		char *ecmd = ex_pathexpand(arg);
@@ -1097,6 +1098,9 @@ int ex_exec(const char *ln)
 			ret = excmds[idx].ec(loc, cmd, ecmd);
 		free(ecmd);
 	}
+	free(loc);
+	free(cmd);
+	free(arg);
 	return ret;
 }
 
diff --git a/lbuf.c b/lbuf.c
index 8cd63f7..e4e1036 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -431,7 +431,7 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int ln_n, int *o, int *len, int skip)
 {
 	int r0 = *r, o0 = *o, grp = xgrp;
-	int offs[grp], i = r0;
+	int *offs = emalloc(grp * sizeof(int)), i = r0;
 	char *s = lbuf_get(lb, i);
 	int off = skip > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
 	for (; i >= 0 && i < ln_n; i += dir) {
@@ -449,12 +449,15 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			*r = i;
 			*len = uc_off(s + off + g1, g2 - g1);
 			off += g2 > 0 ? g2 : 1;
-			if (dir > 0)
+			if (dir > 0) {
+				free(offs);
 				return 0;
+			}
 			ln_n = -1; /* break outer loop efficiently */
 		}
 		off = 0;
 	}
+	free(offs);
 	return ln_n < 0 ? 0 : 1;
 }
 
diff --git a/led.c b/led.c
index 6374558..0793577 100644
--- a/led.c
+++ b/led.c
@@ -44,7 +44,7 @@ static void file_index(struct lbuf *buf)
 	int len, sidx, grp = xgrp;
 	char **ss = lbuf_buf(buf);
 	int ln_n = lbuf_len(buf);
-	int subs[grp], n;
+	int *subs = emalloc(grp * sizeof(int)), n;
 	sbuf *ibuf;
 	rset *rs = rset_make(1, (char*[]){xacreg ? xacreg->s : reg}, xic ? REG_ICASE : 0);
 	if (!rs)
@@ -82,6 +82,7 @@ static void file_index(struct lbuf *buf)
 	sbuf_null(acsb)
 	sbuf_free(ibuf)
 	rset_free(rs);
+	free(subs);
 }
 
 static char *kmap_map(int kmap, int c)
@@ -199,8 +200,8 @@ void led_render(char *s0, int row, int cbeg, int cend)
 	char *bound = s0;
 	int *pos;		/* pos[i]: the screen position of the i-th character */
 	char **chrs;		/* chrs[i]: the i-th character in s1 */
-	int off[cterm+1];	/* off[i]: the character at screen position i */
-	int att[cterm+1];	/* att[i]: the attributes of i-th character */
+	int *off = emalloc((cterm+1) * sizeof(int));	/* off[i]: the character at screen position i */
+	int *att = emalloc((cterm+1) * sizeof(int));	/* att[i]: the attributes of i-th character */
 	int *ratt = att;	/* att[i]: adjusted for terminal boundary */
 	int ctx = dir_context(s0);
 	memset(off, -1, (cterm+1) * sizeof(off[0]));
@@ -266,6 +267,8 @@ void led_render(char *s0, int row, int cbeg, int cend)
 		led_out(term_sbuf, 1)
 	if (!term_record)
 		term_commit();
+	free(off);
+	free(att);
 }
 
 static int led_lastchar(char *s)
@@ -621,7 +624,7 @@ sbuf *led_input(char *pref, char **post, int *kmap, int row)
 {
 	sbuf *sb; sbuf_make(sb, 256)
 	int ai_max = 128 * xai;
-	char ai[ai_max+1];
+	char *ai = emalloc(ai_max+1);
 	int n = 0, key, orow = row;
 	while (n < ai_max && (*pref == ' ' || *pref == '\t'))
 		ai[n++] = *pref++;
@@ -659,6 +662,7 @@ sbuf *led_input(char *pref, char **post, int *kmap, int row)
 		xrow++;
 	}
 	sbufn_str(sb, *post)
+	free(ai);
 	return sb;
 }
 
diff --git a/regex.c b/regex.c
index 51d54a4..5722fcc 100644
--- a/regex.c
+++ b/regex.c
@@ -314,7 +314,14 @@ int reg_comp(rcode *prog, const char *re, int nsubs, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; \
+free(pcs); \
+free(subs); \
+free(sdense); \
+free(_clist); \
+free(_nlist); \
+free(nsubs); \
+return state; } \
 
 #define newsub(init, copy) \
 if (freesub) \
@@ -537,13 +544,13 @@ int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, int flg)
 	int spc, i, j, c, *npc, osubp = nsubp * sizeof(char*);
 	int si = 0, clistidx = 0, nlistidx, mcont = MATCH;
 	int *insts = prog->insts, eol_ch = flg & REG_NEWLINE ? '\n' : 0;
-	int *pcs[prog->splits];
-	rsub *subs[prog->splits];
-	unsigned int sdense[prog->sparsesz], sparsesz = 0;
+	int **pcs = emalloc((prog->splits) * sizeof(int*));
+	rsub **subs = emalloc(prog->splits * sizeof(rsub*));
+	unsigned int *sdense = emalloc(prog->sparsesz * sizeof(unsigned int)), sparsesz = 0;
 	rsub *nsub, *s1, *matched = NULL, *freesub = NULL;
-	rthread _clist[prog->len], _nlist[prog->len];
+	rthread *_clist = emalloc(prog->len * sizeof(rthread)), *_nlist = emalloc(prog->len * sizeof(rthread));
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
-	char nsubs[prog->sub];
+	char *nsubs = emalloc(prog->sub);
 	flg = prog->flg | flg;
 	if (eol_ch)
 		utf8_length[eol_ch] = 0;
@@ -612,7 +619,7 @@ rset *rset_make(int n, char **re, int flg)
 /* return the index of the matching regular expression or -1 if none matches */
 int rset_find(rset *rs, char *s, int n, int *grps, int flg)
 {
-	regmatch_t subs[rs->grpcnt+1];
+	regmatch_t *subs = emalloc((rs->grpcnt+1) * sizeof(regmatch_t));
 	regmatch_t *sub = subs+1;
 	if (re_pikevm(rs->regex, s, (const char**)sub, rs->grpcnt * 2, flg))
 	{
@@ -632,10 +639,12 @@ int rset_find(rset *rs, char *s, int n, int *grps, int flg)
 						grps[gi * 2 + 1] = -1;
 					}
 				}
+				free(subs);
 				return i;
 			}
 		}
 	}
+	free(subs);
 	return -1;
 }
 
diff --git a/ren.c b/ren.c
index f3b49de..330b06a 100644
--- a/ren.c
+++ b/ren.c
@@ -250,13 +250,14 @@ int syn_blockhl;
 static void syn_initft(int fti, int n, char *name)
 {
 	int i = n;
-	char *pats[hlslen];
+	char **pats = emalloc((hlslen) * sizeof(char*));
 	for (; i < hlslen && !strcmp(hls[i].ft, name); i++)
 		pats[i - n] = hls[i].pat;
 	ftmap[fti].setbidx = n;
 	ftmap[fti].ft = name;
 	ftmap[fti].rs = rset_make(i - n, pats, 0);
 	ftmap[fti].seteidx = i;
+	free(pats);
 }
 
 char *syn_setft(char *ft)
@@ -376,9 +377,10 @@ int syn_addhl(char *reg, int func, int reload)
 
 void syn_init(void)
 {
-	char *pats[ftslen];
+	char **pats = emalloc(ftslen * sizeof(char *));
 	int i = 0;
 	for (; i < ftslen; i++)
 		pats[i] = fts[i].pat;
 	syn_ftrs = rset_make(i, pats, 0);
+	free(pats);
 }
diff --git a/vi.c b/vi.c
index bd558f4..22aea31 100644
--- a/vi.c
+++ b/vi.c
@@ -152,7 +152,7 @@ static void vi_drawrow(int row)
 	{
 		lnnum = 1;
 		l1 = lbuf_slen(s) + 7;
-		char tmp[l1+100];
+		char *tmp = emalloc(l1+100);
 		c = itoa(row+1-movedown, tmp);
 		l2 = strlen(tmp)+1;
 		*c++ = ' ';
@@ -166,6 +166,7 @@ static void vi_drawrow(int row)
 		*c++ = ' ';
 		memcpy(c, s+i, l1-i);
 		led_reprint(tmp, row - xtop);
+		free(tmp);
 	}
 	if (*vi_word && row == xrow+1) {
 		last_row:;
@@ -176,8 +177,8 @@ static void vi_drawrow(int row)
 			led_print(s, row - xtop);
 			return;
 		}
-		char tmp[xcols+3];
-		char snum[100];
+		char *tmp = emalloc(xcols+3);
+		char *snum = emalloc(100);
 		memset(tmp, ' ', xcols+1);
 		tmp[xcols+1] = '\n';
 		tmp[xcols+2] = '\0';
@@ -208,6 +209,8 @@ static void vi_drawrow(int row)
 		restore(xorder)
 		restore(syn_blockhl)
 		restore(xtd)
+		free(tmp);
+		free(snum);
 	} else if (!lnnum)
 		led_print(s, row - xtop);
 	if (row+1 == MIN(xtop + xrows, lbuf_len(xb)+movedown))
@@ -606,9 +609,10 @@ static void vi_regprint(void)
 	xleft = (xcols / 2) * vi_arg1;
 	for (int i = 1; i < LEN(regs); i++) {
 		if (regs[i]) {
-			char buf[xcols * 5 + 3];
+			char *buf = emalloc(xcols * 5 + 3);
 			snprintf(buf, xcols * 5 + 3, "%c %s", (unsigned char)i, regs[i]);
 			ex_print(xleft ? regs[i] : buf);
+			free(buf);
 		}
 	}
 }
@@ -1533,12 +1537,13 @@ void vi(int init)
 				if (!(ln = lbuf_get(xb, xrow)))
 					break;
 				ln += xoff;
-				char buf[strlen(ln)+4];
+				char *buf = emalloc(strlen(ln)+4);
 				buf[0] = ':';
 				buf[1] = 'e';
 				buf[2] = ' ';
 				strcpy(buf+3, ln);
 				term_push(buf, strlen(ln)+3);
+				free(buf);
 				break; }
 			case TK_CTL('n'):
 				vi_cndir = vi_arg1 ? -vi_cndir : vi_cndir;
@@ -1663,7 +1668,7 @@ void vi(int init)
 					strcpy(vi_msg, "arg2:(0|#)");
 					vi_drawmsg();
 					cs = vi_curword(xb, xrow, xoff, vi_prefix(), '|');
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, ".,.+");
 					char *buf1 = itoa(vi_arg1, buf+4);
 					strcat(buf1, "s/");
@@ -1673,10 +1678,11 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_prompt(":", buf, &kmap);
+					free(buf);
 					goto do_excmd; }
 				case 'r': {
 					cs = vi_curword(xb, xrow, xoff, vi_arg1, '|');
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, "%s/");
 					if (cs) {
 						strcat(buf, cs);
@@ -1684,6 +1690,7 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_prompt(":", buf, &kmap);
+					free(buf);
 					goto do_excmd; }
 				default:
 					vi_back(k);
