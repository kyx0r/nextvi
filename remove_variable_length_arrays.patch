diff --git a/ex.c b/ex.c
index 7ca9c44..b347326 100644
--- a/ex.c
+++ b/ex.c
@@ -766,7 +766,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	free(rep);
 	if (!xkwdrs)
 		return 1;
-	int offs[xkwdrs->grpcnt * 2];
+	int *offs = emalloc(xkwdrs->grpcnt * 2 * sizeof(int));
 	for (i = beg; i < end; i++) {
 		char *ln = lbuf_get(xb, i);
 		sbuf *r = NULL;
@@ -797,6 +797,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	}
 	if (first >= 0)
 		lbuf_emark(xb, lbuf_opt(xb, NULL, xrow, 0, 0), first, last);
+	free(offs);
 	return 0;
 }
 
@@ -1197,7 +1198,7 @@ static const char *ex_parse(const char *src, char *loc, int *idx, char *arg)
 int ex_exec(const char *ln)
 {
 	int ret = 0, idx = 0, len = strlen(ln) + 1;
-	char loc[len], arg[len];
+	char *loc = emalloc(len), *arg = emalloc(len);
 	while (*ln) {
 		ln = ex_parse(ln, loc, &idx, arg);
 		char *ecmd = ex_pathexpand(arg);
@@ -1205,6 +1206,8 @@ int ex_exec(const char *ln)
 			ret = excmds[idx].ec(loc, excmds[idx].name, ecmd);
 		free(ecmd);
 	}
+	free(loc);
+	free(arg);
 	return ret;
 }
 
diff --git a/lbuf.c b/lbuf.c
index 0649f71..ae84628 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -363,7 +363,7 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int *o, int ln_n, int skip)
 {
 	int r0 = *r, o0 = *o;
-	int offs[re->grpcnt * 2], i = r0;
+	int *offs = emalloc(re->grpcnt * 2 * sizeof(int)), i = r0;
 	char *s = lbuf_get(lb, i);
 	int off = skip >= 0 && *uc_chr(s, o0 + skip) ? uc_chr(s, o0 + skip) - s : 0;
 	for (; i >= 0 && i < ln_n; i += dir) {
@@ -380,12 +380,15 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			*o = uc_off(s, off + g1);
 			*r = i;
 			off += g2 > 0 ? g2 : 1;
-			if (dir > 0)
+			if (dir > 0) {
+				free(offs);
 				return 0;
+			}
 			ln_n = -1; /* break outer loop efficiently */
 		}
 		off = 0;
 	}
+	free(offs);
 	return ln_n < 0 ? 0 : 1;
 }
 
diff --git a/led.c b/led.c
index eab4bb5..6236e0a 100644
--- a/led.c
+++ b/led.c
@@ -47,7 +47,7 @@ static void file_index(struct lbuf *buf)
 	rset *rs = rset_smake(xacreg ? xacreg->s : reg, xic ? REG_ICASE : 0);
 	if (!rs)
 		return;
-	int subs[rs->grpcnt * 2];
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int));
 	sbuf_smake(ibuf, 1024)
 	for (n = 1; n <= acsb->s_n; n++)
 		if (acsb->s[n - 1] == '\n')
@@ -81,6 +81,7 @@ static void file_index(struct lbuf *buf)
 	sbuf_null(acsb)
 	free(ibuf->s);
 	rset_free(rs);
+	free(subs);
 }
 
 static char *kmap_map(int kmap, int c)
@@ -151,10 +152,10 @@ void led_render(char *s0, int cbeg, int cend)
 	int att_old = 0, atti = 0, cterm = cend - cbeg;
 	char *bound = NULL;
 	char **chrs = r->chrs;	/* chrs[i]: the i-th character in s0 */
-	int off[cterm+1];	/* off[i]: the character at screen position i */
-	int att[cterm+1];	/* att[i]: the attributes of i-th character */
-	int stt[cterm+1];	/* stt[i]: remap off indexes */
-	int ctt[cterm+1];	/* ctt[i]: cterm bound attrs */
+	int *off = emalloc((cterm+1) * sizeof(int));	/* off[i]: the character at screen position i */
+	int *att = emalloc((cterm+1) * sizeof(int));	/* att[i]: the attributes of i-th character */
+	int *stt = NULL;	/* stt[i]: remap off indexes */
+	int *ctt = NULL;	/* ctt[i]: cterm bound attrs */
 	int ctx = r->ctx;
 	off[cterm] = -1;
 	if (ctx < 0) {
@@ -176,6 +177,8 @@ void led_render(char *s0, int cbeg, int cend)
 		if (o >= 0 && r->cmax > cterm && r->pos[o] + r->wid[o] > cend)
 			while (off[i] == o)
 				off[ctx < 0 ? i++ : i--] = -1;
+		stt = emalloc((cterm+1) * sizeof(int));
+		ctt = emalloc((cterm+1) * sizeof(int));
 		for (i = 0, c = 0; i < cterm;) {
 			if ((o = off[i++]) >= 0) {
 				att[c++] = o;
@@ -254,6 +257,10 @@ void led_render(char *s0, int cbeg, int cend)
 	else
 		led_out(term_sbuf, 1)
 	sbufn_str(term_sbuf, term_att(0))
+	free(off);
+	free(att);
+	free(stt);
+	free(ctt);
 }
 
 static int led_lastchar(char *s)
diff --git a/regex.c b/regex.c
index 1388190..20921cc 100644
--- a/regex.c
+++ b/regex.c
@@ -312,7 +312,14 @@ int reg_comp(rcode *prog, const char *re, int nsubs, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; \
+free(pcs); \
+free(subs); \
+free(sdense); \
+free(_clist); \
+free(_nlist); \
+free(nsubs); \
+return state; } \
 
 #define newsub(init, copy) \
 if (freesub) \
@@ -535,13 +542,13 @@ int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, int flg)
 	int spc, i, j, c, *npc, osubp = nsubp * sizeof(char*);
 	int si = 0, clistidx = 0, nlistidx, mcont = MATCH;
 	int *insts = prog->insts, eol_ch = flg & REG_NEWLINE ? '\n' : 0;
-	int *pcs[prog->splits];
-	rsub *subs[prog->splits];
-	unsigned int sdense[prog->sparsesz], sparsesz = 0;
+	int **pcs = emalloc((prog->splits) * sizeof(int*));
+	rsub **subs = emalloc(prog->splits * sizeof(rsub*));
+	unsigned int *sdense = emalloc(prog->sparsesz * sizeof(unsigned int)), sparsesz = 0;
 	rsub *nsub, *s1, *matched = NULL, *freesub = NULL;
-	rthread _clist[prog->len], _nlist[prog->len];
+	rthread *_clist = emalloc(prog->len * sizeof(rthread)), *_nlist = emalloc(prog->len * sizeof(rthread));
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
-	char nsubs[prog->sub];
+	char *nsubs = emalloc(prog->sub);
 	flg = prog->flg | flg;
 	if (eol_ch)
 		utf8_length[eol_ch] = 0;
@@ -615,7 +622,7 @@ rset *rset_make(int n, char **re, int flg)
 /* return the index of the matching regular expression or -1 if none matches */
 int rset_find(rset *rs, char *s, int *grps, int flg)
 {
-	regmatch_t subs[rs->grpcnt+1];
+	regmatch_t *subs = emalloc((rs->grpcnt+1) * sizeof(regmatch_t));
 	regmatch_t *sub = subs+1;
 	if (re_pikevm(rs->regex, s, (const char**)sub, rs->grpcnt * 2, flg)) {
 		subs[0].rm_eo = NULL; /* make sure sub[-1] never matches */
@@ -632,10 +639,12 @@ int rset_find(rset *rs, char *s, int *grps, int flg)
 						grps[gi * 2 + 1] = -1;
 					}
 				}
+				free(subs);
 				return i;
 			}
 		}
 	}
+	free(subs);
 	return -1;
 }
 
diff --git a/ren.c b/ren.c
index def7604..37c3810 100644
--- a/ren.c
+++ b/ren.c
@@ -241,13 +241,14 @@ int syn_blockhl;
 static void syn_initft(int fti, int n, char *name)
 {
 	int i = n;
-	char *pats[hlslen];
+	char **pats = emalloc((hlslen) * sizeof(char*));
 	for (; i < hlslen && !strcmp(hls[i].ft, name); i++)
 		pats[i - n] = hls[i].pat;
 	ftmap[fti].setbidx = n;
 	ftmap[fti].ft = name;
 	ftmap[fti].rs = rset_make(i - n, pats, 0);
 	ftmap[fti].seteidx = i;
+	free(pats);
 }
 
 char *syn_setft(char *ft)
@@ -286,7 +287,7 @@ int syn_merge(int old, int new)
 void syn_highlight(int *att, char *s, int n)
 {
 	rset *rs = ftmap[ftidx].rs;
-	int subs[rs->grpcnt * 2], sl;
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int)), sl;
 	int blk = 0, blkm = 0, sidx = 0, flg = 0, hl, j, i;
 	int bend = 0, cend = 0;
 	while ((sl = rset_find(rs, s + sidx, subs, flg)) >= 0) {
@@ -332,6 +333,7 @@ void syn_highlight(int *att, char *s, int n)
 	if (syn_blockhl && !blk)
 		for (j = 0; j < n; j++)
 			att[j] = blockcont && att[j] ? att[j] : *blockatt;
+	free(subs);
 }
 
 char *syn_filetype(char *path)
@@ -372,9 +374,10 @@ void syn_addhl(char *reg, int id, int reload)
 
 void syn_init(void)
 {
-	char *pats[ftslen];
+	char **pats = emalloc(ftslen * sizeof(char *));
 	int i = 0;
 	for (; i < ftslen; i++)
 		pats[i] = fts[i].pat;
 	syn_ftrs = rset_make(i, pats, 0);
+	free(pats);
 }
diff --git a/vi.c b/vi.c
index 159e078..917d524 100644
--- a/vi.c
+++ b/vi.c
@@ -161,7 +161,8 @@ static void vi_drawrow(int row)
 			vi_rshift = 0;
 		if (row != xrow+1 || !c || *c == '\n')
 			goto skip;
-		char tmp[xcols+3], snum[100];
+		char *tmp = emalloc(xcols+3);
+		char *snum = emalloc(100);
 		memset(tmp, ' ', xcols+1);
 		tmp[xcols+1] = '\n';
 		tmp[xcols+2] = '\0';
@@ -188,6 +189,8 @@ static void vi_drawrow(int row)
 		restore(xorder)
 		restore(syn_blockhl)
 		restore(xtd)
+		free(tmp);
+		free(snum);
 		return;
 	}
 	s = lbuf_get(xb, row);
@@ -1391,10 +1394,11 @@ void vi(int init)
 				if (!(ln = lbuf_get(xb, xrow)))
 					break;
 				ln += xoff;
-				char buf[strlen(ln)+4];
+				char *buf = emalloc(strlen(ln)+4);
 				strcpy(buf, ":e ");
 				strcpy(buf+3, ln);
 				term_push(buf, strlen(ln)+3);
+				free(buf);
 				break; }
 			case TK_CTL('n'):
 				vi_cndir = vi_arg ? -vi_cndir : vi_cndir;
@@ -1529,7 +1533,7 @@ void vi(int init)
 					strcpy(vi_msg, "arg2:(0|#)");
 					vi_drawmsg();
 					cs = vi_curword(xb, xrow, xoff, vi_prefix());
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, ".,.+");
 					char *buf1 = itoa(vi_arg, buf+4);
 					strcat(buf1, "s/");
@@ -1539,10 +1543,11 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_enprompt(":", buf, &n);
+					free(buf);
 					goto do_excmd; }
 				case 'r': {
 					cs = vi_curword(xb, xrow, xoff, vi_arg);
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, "%s/");
 					if (cs) {
 						strcat(buf, cs);
@@ -1550,6 +1555,7 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_enprompt(":", buf, &n);
+					free(buf);
 					goto do_excmd; }
 				default:
 					term_dec()
