diff --git a/ex.c b/ex.c
index 24ece75..caa0a48 100644
--- a/ex.c
+++ b/ex.c
@@ -736,7 +736,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	free(rep);
 	if (!xkwdrs)
 		return 1;
-	int offs[xkwdrs->grpcnt * 2];
+	int *offs = emalloc(xkwdrs->grpcnt * 2 * sizeof(int));
 	for (i = beg; i < end; i++) {
 		char *ln = lbuf_get(xb, i);
 		sbuf *r = NULL;
@@ -767,6 +767,7 @@ static int ec_substitute(char *loc, char *cmd, char *arg)
 	}
 	if (first >= 0)
 		lbuf_emark(xb, lbuf_opt(xb, NULL, xrow, 0), first, last);
+	free(offs);
 	return 0;
 }
 
@@ -1144,7 +1145,7 @@ static const char *ex_parse(const char *src, char *loc, char *cmd, char *arg)
 int ex_exec(const char *ln)
 {
 	int ret = 0, len = strlen(ln) + 1;
-	char loc[len], cmd[len], arg[len];
+	char *loc = emalloc(len), *cmd = emalloc(len), *arg = emalloc(len);
 	while (*ln) {
 		ln = ex_parse(ln, loc, cmd, arg);
 		char *ecmd = ex_pathexpand(arg);
@@ -1153,6 +1154,9 @@ int ex_exec(const char *ln)
 			ret = excmds[idx].ec(loc, cmd, ecmd);
 		free(ecmd);
 	}
+	free(loc);
+	free(cmd);
+	free(arg);
 	return ret;
 }
 
diff --git a/lbuf.c b/lbuf.c
index e4e30a7..fef19c4 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -432,7 +432,7 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int ln_n, int *o, int *len, int skip)
 {
 	int r0 = *r, o0 = *o;
-	int offs[re->grpcnt * 2], i = r0;
+	int *offs = emalloc(re->grpcnt * 2 * sizeof(int)), i = r0;
 	char *s = lbuf_get(lb, i);
 	int off = skip > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
 	for (; i >= 0 && i < ln_n; i += dir) {
@@ -450,12 +450,15 @@ int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			*r = i;
 			*len = uc_off(s + off + g1, g2 - g1);
 			off += g2 > 0 ? g2 : 1;
-			if (dir > 0)
+			if (dir > 0) {
+				free(offs);
 				return 0;
+			}
 			ln_n = -1; /* break outer loop efficiently */
 		}
 		off = 0;
 	}
+	free(offs);
 	return ln_n < 0 ? 0 : 1;
 }
 
diff --git a/led.c b/led.c
index abf62fd..3f314a8 100644
--- a/led.c
+++ b/led.c
@@ -48,7 +48,7 @@ static void file_index(struct lbuf *buf)
 	rset *rs = rset_smake(xacreg ? xacreg->s : reg, xic ? REG_ICASE : 0);
 	if (!rs)
 		return;
-	int subs[rs->grpcnt * 2];
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int));
 	sbuf_make(ibuf, 1024)
 	for (n = 1; n <= acsb->s_n; n++)
 		if (acsb->s[n - 1] == '\n')
@@ -82,6 +82,7 @@ static void file_index(struct lbuf *buf)
 	sbuf_null(acsb)
 	sbuf_free(ibuf)
 	rset_free(rs);
+	free(subs);
 }
 
 static char *kmap_map(int kmap, int c)
@@ -161,10 +162,10 @@ void led_render(char *s0, int cbeg, int cend)
 	int att_old = 0, atti = 0;
 	char *bound = NULL;
 	char **chrs;		/* chrs[i]: the i-th character in s1 */
-	int off[cterm+1];	/* off[i]: the character at screen position i */
-	int att[cterm+1];	/* att[i]: the attributes of i-th character */
-	int stt[cterm+1];	/* stt[i]: remap off indexes */
-	int ctt[cterm+1];	/* ctt[i]: cterm bound attrs */
+	int *off = emalloc((cterm+1) * sizeof(int));	/* off[i]: the character at screen position i */
+	int *att = emalloc((cterm+1) * sizeof(int));	/* att[i]: the attributes of i-th character */
+	int *stt = NULL;	/* stt[i]: remap off indexes */
+	int *ctt = NULL;	/* ctt[i]: cterm bound attrs */
 	int *pos = ren_position(s0, &chrs, &n);	/* pos[i]: the screen position of the i-th character */
 	int ctx = dir_context(s0);
 	memset(off, -1, (cterm+1) * sizeof(off[0]));
@@ -202,6 +203,8 @@ void led_render(char *s0, int cbeg, int cend)
 		}
 	}
 	if (pos[n] > cterm || cbeg) {
+		stt = emalloc((cterm+1) * sizeof(int));
+		ctt = emalloc((cterm+1) * sizeof(int));
 		for (i = 0, c = 0; i < cterm;) {
 			o = off[i++];
 			if (o >= 0) {
@@ -252,6 +255,10 @@ void led_render(char *s0, int cbeg, int cend)
 		led_out(term_sbuf, 2)
 	else
 		led_out(term_sbuf, 1)
+	free(off);
+	free(att);
+	free(stt);
+	free(ctt);
 }
 
 static int led_lastchar(char *s)
diff --git a/regex.c b/regex.c
index 9f690cc..98400b6 100644
--- a/regex.c
+++ b/regex.c
@@ -312,7 +312,14 @@ int reg_comp(rcode *prog, const char *re, int nsubs, int flags)
 	return 0;
 }
 
-#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; return state; } \
+#define _return(state) { if (eol_ch) utf8_length[eol_ch] = 1; \
+free(pcs); \
+free(subs); \
+free(sdense); \
+free(_clist); \
+free(_nlist); \
+free(nsubs); \
+return state; } \
 
 #define newsub(init, copy) \
 if (freesub) \
@@ -535,13 +542,13 @@ int re_pikevm(rcode *prog, const char *s, const char **subp, int nsubp, int flg)
 	int spc, i, j, c, *npc, osubp = nsubp * sizeof(char*);
 	int si = 0, clistidx = 0, nlistidx, mcont = MATCH;
 	int *insts = prog->insts, eol_ch = flg & REG_NEWLINE ? '\n' : 0;
-	int *pcs[prog->splits];
-	rsub *subs[prog->splits];
-	unsigned int sdense[prog->sparsesz], sparsesz = 0;
+	int **pcs = emalloc((prog->splits) * sizeof(int*));
+	rsub **subs = emalloc(prog->splits * sizeof(rsub*));
+	unsigned int *sdense = emalloc(prog->sparsesz * sizeof(unsigned int)), sparsesz = 0;
 	rsub *nsub, *s1, *matched = NULL, *freesub = NULL;
-	rthread _clist[prog->len], _nlist[prog->len];
+	rthread *_clist = emalloc(prog->len * sizeof(rthread)), *_nlist = emalloc(prog->len * sizeof(rthread));
 	rthread *clist = _clist, *nlist = _nlist, *tmp;
-	char nsubs[prog->sub];
+	char *nsubs = emalloc(prog->sub);
 	flg = prog->flg | flg;
 	if (eol_ch)
 		utf8_length[eol_ch] = 0;
@@ -615,7 +622,7 @@ rset *rset_make(int n, char **re, int flg)
 /* return the index of the matching regular expression or -1 if none matches */
 int rset_find(rset *rs, char *s, int *grps, int flg)
 {
-	regmatch_t subs[rs->grpcnt+1];
+	regmatch_t *subs = emalloc((rs->grpcnt+1) * sizeof(regmatch_t));
 	regmatch_t *sub = subs+1;
 	if (re_pikevm(rs->regex, s, (const char**)sub, rs->grpcnt * 2, flg)) {
 		subs[0].rm_eo = NULL; /* make sure sub[-1] never matches */
@@ -632,10 +639,12 @@ int rset_find(rset *rs, char *s, int *grps, int flg)
 						grps[gi * 2 + 1] = -1;
 					}
 				}
+				free(subs);
 				return i;
 			}
 		}
 	}
+	free(subs);
 	return -1;
 }
 
diff --git a/ren.c b/ren.c
index 8105e7a..17cc23e 100644
--- a/ren.c
+++ b/ren.c
@@ -249,13 +249,14 @@ int syn_blockhl;
 static void syn_initft(int fti, int n, char *name)
 {
 	int i = n;
-	char *pats[hlslen];
+	char **pats = emalloc((hlslen) * sizeof(char*));
 	for (; i < hlslen && !strcmp(hls[i].ft, name); i++)
 		pats[i - n] = hls[i].pat;
 	ftmap[fti].setbidx = n;
 	ftmap[fti].ft = name;
 	ftmap[fti].rs = rset_make(i - n, pats, 0);
 	ftmap[fti].seteidx = i;
+	free(pats);
 }
 
 char *syn_setft(char *ft)
@@ -294,7 +295,7 @@ int syn_merge(int old, int new)
 void syn_highlight(int *att, char *s, int n)
 {
 	rset *rs = ftmap[ftidx].rs;
-	int subs[rs->grpcnt * 2], sl;
+	int *subs = emalloc(rs->grpcnt * 2 * sizeof(int)), sl;
 	int blk = 0, blkm = 0, sidx = 0, flg = 0, hl, j, i;
 	int bend = 0, cend = 0;
 	while ((sl = rset_find(rs, s + sidx, subs, flg)) >= 0) {
@@ -340,6 +341,7 @@ void syn_highlight(int *att, char *s, int n)
 	if (syn_blockhl && !blk)
 		for (j = 0; j < n; j++)
 			att[j] = blockcont && att[j] ? att[j] : *blockatt;
+	free(subs);
 }
 
 char *syn_filetype(char *path)
@@ -374,9 +376,10 @@ int syn_addhl(char *reg, int func, int reload)
 
 void syn_init(void)
 {
-	char *pats[ftslen];
+	char **pats = emalloc(ftslen * sizeof(char *));
 	int i = 0;
 	for (; i < ftslen; i++)
 		pats[i] = fts[i].pat;
 	syn_ftrs = rset_make(i, pats, 0);
+	free(pats);
 }
diff --git a/vi.c b/vi.c
index d998bfe..6a0239d 100644
--- a/vi.c
+++ b/vi.c
@@ -147,7 +147,8 @@ static void vi_drawrow(int row)
 			vi_rshift = 0;
 		if (row != xrow+1 || !c || *c == '\n')
 			goto skip;
-		char tmp[xcols+3], snum[100];
+		char *tmp = emalloc(xcols+3);
+		char *snum = emalloc(100);
 		memset(tmp, ' ', xcols+1);
 		tmp[xcols+1] = '\n';
 		tmp[xcols+2] = '\0';
@@ -178,6 +179,8 @@ static void vi_drawrow(int row)
 		restore(xorder)
 		restore(syn_blockhl)
 		restore(xtd)
+		free(tmp);
+		free(snum);
 		return;
 	}
 	s = lbuf_get(xb, row);
@@ -1492,12 +1495,13 @@ void vi(int init)
 				if (!(ln = lbuf_get(xb, xrow)))
 					break;
 				ln += xoff;
-				char buf[strlen(ln)+4];
+				char *buf = emalloc(strlen(ln)+4);
 				buf[0] = ':';
 				buf[1] = 'e';
 				buf[2] = ' ';
 				strcpy(buf+3, ln);
 				term_push(buf, strlen(ln)+3);
+				free(buf);
 				break; }
 			case TK_CTL('n'):
 				vi_cndir = vi_arg1 ? -vi_cndir : vi_cndir;
@@ -1628,7 +1632,7 @@ void vi(int init)
 					strcpy(vi_msg, "arg2:(0|#)");
 					vi_drawmsg();
 					cs = vi_curword(xb, xrow, xoff, vi_prefix(), '|');
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, ".,.+");
 					char *buf1 = itoa(vi_arg1, buf+4);
 					strcat(buf1, "s/");
@@ -1638,10 +1642,11 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_prompt(":", buf, &kmap);
+					free(buf);
 					goto do_excmd; }
 				case 'r': {
 					cs = vi_curword(xb, xrow, xoff, vi_arg1, '|');
-					char buf[cs ? strlen(cs)+30 : 30];
+					char *buf = emalloc(cs ? strlen(cs)+30 : 30);
 					strcpy(buf, "%s/");
 					if (cs) {
 						strcat(buf, cs);
@@ -1649,6 +1654,7 @@ void vi(int init)
 						free(cs);
 					}
 					ln = vi_prompt(":", buf, &kmap);
+					free(buf);
 					goto do_excmd; }
 				default:
 					vi_back(k);
