diff --git a/ex.c b/ex.c
index 5bf89e3b..96d4cf42 100644
--- a/ex.c
+++ b/ex.c
@@ -1081,6 +1081,16 @@ static int ec_setenc(char *loc, char *cmd, char *arg)
 	return 0;
 }
 
+static int ec_undoleafs(char *loc, char *cmd, char *arg)
+{
+	char *s = lbuf_getleafs(xb);
+	if (*arg)
+		lbuf_setleaf(xb, atoi(arg));
+	else
+		ex_print(s);
+	return 0;
+}
+
 static int eo_val(char *arg)
 {
 	int val = atoi(arg);
@@ -1159,6 +1169,7 @@ static struct excmd {
 	{"uc", ec_setenc},
 	{"uz", ec_setenc},
 	{"ub", ec_setenc},
+	{"up", ec_undoleafs},
 	{"u", ec_undoredo},
 	EO(shape),
 	EO(seq),
diff --git a/lbuf.c b/lbuf.c
index e4d22551..34c83a0c 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -4,6 +4,7 @@ struct lbuf *lbuf_make(void)
 	memset(lb, 0, sizeof(*lb));
 	for (int i = 0; i < LEN(lb->mark); i++)
 		lb->mark[i] = -1;
+	sbuf_make(lb->rehist, 128)
 	return lb;
 }
 
@@ -54,13 +55,39 @@ int lbuf_jump(struct lbuf *lb, int mark, int *pos, int *off)
 	return 0;
 }
 
+static void lbuf_freeleafs(struct lbuf *lb)
+{
+	char *ptr = lb->rehist->s;
+	struct lopt *hist;
+	int n, i, c;
+	sbuf *freedsb; sbuf_make(freedsb, 128)
+	for (i = 0; i < lb->hist_n; i++) {
+		sbuf_mem(freedsb, &lb->hist[i].mark, (int)sizeof(void*))
+		lopt_done(&lb->hist[i]);
+	}
+	while (lb->rehist->s_n > ptr - lb->rehist->s) {
+		n = *(int*)ptr;
+		hist = (struct lopt*)&ptr[sizeof(n)];
+		for (i = 0; i < n; i++) {
+			for (c = 0; c < freedsb->s_n; c+=sizeof(void*))
+				if (*(void**)((char*)freedsb->s + c) == hist[i].mark)
+					goto skip;
+			sbuf_mem(freedsb, &hist[i].mark, (int)sizeof(void*))
+			lopt_done(&hist[i]);
+			skip:;
+		}
+		ptr += n * sizeof(lb->hist[0]) + sizeof(n);
+	}
+	sbuf_free(lb->rehist)
+	sbuf_free(freedsb)
+}
+
 void lbuf_free(struct lbuf *lb)
 {
 	int i;
 	for (i = 0; i < lb->ln_n; i++)
 		free(lbuf_i(lb, i));
-	for (i = 0; i < lb->hist_n; i++)
-		lopt_done(&lb->hist[i]);
+	lbuf_freeleafs(lb);
 	free(lb->hist);
 	free(lb->ln);
 	free(lb);
@@ -143,12 +170,72 @@ void lbuf_emark(struct lbuf *lb, struct lopt *lo, int beg, int end)
 static int smark[NMARKS * 2] = {-1};
 static struct lopt slo = {.mark = smark};
 
+void lbuf_setleaf(struct lbuf *lb, int leaf)
+{
+	char *ptr1 = lb->rehist->s, *ptr2;
+	int n, i, off = -1;
+	for (i = 0; lb->rehist->s_n > ptr1 - lb->rehist->s; i++) {
+		n = *(int*)ptr1;
+		if (i == leaf) {
+			off = ptr1 - lb->rehist->s;
+			break;
+		}
+		ptr1 += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
+	}
+	if (off < 0)
+		return;
+	while (!lbuf_undo(lb));
+	i = lb->hist_n - lb->hist_u;
+	if (i) {
+		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
+		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
+		ptr1 = lb->rehist->s + off;
+		lb->hist_n = n;
+		lb->hist_u = 0;
+		if (lb->hist_n >= lb->hist_sz) {
+			free(lb->hist);
+			int sz = lb->hist_n * 2;
+			struct lopt *hist = emalloc(sz * sizeof(hist[0]));
+			lb->hist = hist;
+			lb->hist_sz = sz;
+		}
+		memcpy(lb->hist, &ptr1[sizeof(n)], n * sizeof(lb->hist[0]));
+		ptr2 = &ptr1[n * sizeof(lb->hist[0]) + sizeof(n)];
+		if (lb->rehist->s_n > ptr2 - lb->rehist->s)
+			memmove(ptr1, ptr2, lb->rehist->s_n - (ptr2 - lb->rehist->s));
+		lb->rehist->s_n -= ptr2 - ptr1;
+		while (!lbuf_redo(lb));
+	}
+}
+
+char *lbuf_getleafs(struct lbuf *lb)
+{
+	char *ptr = lb->rehist->s, *bptr;
+	int n, i;
+	char buf[100];
+	sbuf_smake(sb, 128)
+	for (i = 0; lb->rehist->s_n > ptr - lb->rehist->s; i++) {
+		n = *(int*)ptr;
+		bptr = itoa(i, buf);
+		*bptr++ = '=';
+		bptr = itoa(n, bptr);
+		*bptr++ = '|';
+		*bptr++ = '\0';
+		sbuf_str(sb, buf);
+		ptr += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
+	}
+	sbufn_sret(sb)
+}
+
 /* append undo/redo history */
 struct lopt *lbuf_opt(struct lbuf *lb, char *buf, int pos, int n_del, int init)
 {
 	struct lopt *lo;
-	for (int i = lb->hist_u; i < lb->hist_n; i++)
-		lopt_done(&lb->hist[i]);
+	int i = lb->hist_n - lb->hist_u;
+	if (i) {
+		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
+		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
+	}
 	lb->hist_n = lb->hist_u;
 	if (lb->hist_n == lb->hist_sz) {
 		int sz = lb->hist_sz + (lb->hist_sz ? lb->hist_sz : 128);
@@ -292,10 +379,10 @@ int lbuf_redo(struct lbuf *lb)
 void lbuf_saved(struct lbuf *lb, int clear)
 {
 	if (clear) {
-		for (int i = 0; i < lb->hist_n; i++)
-			lopt_done(&lb->hist[i]);
+		lbuf_freeleafs(lb);
 		lb->hist_n = 0;
 		lb->hist_u = 0;
+		sbuf_make(lb->rehist, 128)
 	}
 	lb->modified = 0;
 }
diff --git a/vi.h b/vi.h
index ae224584..9d8a055a 100644
--- a/vi.h
+++ b/vi.h
@@ -148,6 +148,7 @@ struct linfo {
 struct lbuf {
 	char **ln;			/* buffer lines */
 	struct lopt *hist;		/* buffer history */
+	sbuf *rehist;		/* alternate redo timelines */
 	int mark[NMARKS * 2];		/* mark rows & offs */
 	int tmp_mark[4];		/* aux mark state */
 	int ln_n;			/* number of lines in ln[] */
@@ -181,6 +182,8 @@ int lbuf_eol(struct lbuf *lb, int r, int state);
 int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *r, int *o);
 int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int *o, int ln_n, int skip);
+void lbuf_setleaf(struct lbuf *lb, int leaf);
+char *lbuf_getleafs(struct lbuf *lb);
 #define lbuf_dedup(lb, str, n) \
 { for (int i = 0; i < lbuf_len(lb);) { \
 	char *s = lbuf_get(lb, i); \
