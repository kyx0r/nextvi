diff --git a/ex.c b/ex.c
index 98a08c2..e799243 100644
--- a/ex.c
+++ b/ex.c
@@ -1035,6 +1035,16 @@ static int ec_setenc(char *loc, char *cmd, char *arg)
 	return 0;
 }
 
+static int ec_undoleafs(char *loc, char *cmd, char *arg)
+{
+	char *s = lbuf_getleafs(xb);
+	if (*arg)
+		lbuf_setleaf(xb, atoi(arg));
+	else
+		ex_print(s);
+	return 0;
+}
+
 static struct excmd {
 	char *name;
 	int (*ec)(char *loc, char *cmd, char *arg);
@@ -1067,6 +1077,7 @@ static struct excmd {
 	{"wq", ec_write},
 	{"wq!", ec_write},
 	{"u", ec_undo},
+	{"up", ec_undoleafs},
 	{"rd", ec_redo},
 	{"se", ec_set},
 	{"s", ec_substitute},
diff --git a/lbuf.c b/lbuf.c
index e4e30a7..1c6cea9 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -16,6 +16,7 @@ struct lbuf {
 	char **ln;		/* buffer lines */
 	char *ln_glob;		/* line global mark */
 	struct lopt *hist;	/* buffer history */
+	sbuf *rehist;		/* alternate redo timelines */
 	int mark[NMARKS];	/* mark lines */
 	int mark_off[NMARKS];	/* mark line offsets */
 	int ln_n;		/* number of lines in ln[] */
@@ -36,6 +37,7 @@ struct lbuf *lbuf_make(void)
 	for (i = 0; i < LEN(lb->mark); i++)
 		lb->mark[i] = -1;
 	lb->useq = 1;
+	sbuf_make(lb->rehist, 128)
 	return lb;
 }
 
@@ -82,13 +84,39 @@ static void lbuf_loadpos(struct lbuf *lb, struct lopt *lo)
 	lb->mark_off[markidx('*')] = lo->pos_off;
 }
 
+static void lbuf_freeleafs(struct lbuf *lb)
+{
+	char *ptr = lb->rehist->s;
+	struct lopt *hist;
+	int n, i, c;
+	sbuf *freedsb; sbuf_make(freedsb, 128)
+	for (i = 0; i < lb->hist_n; i++) {
+		sbuf_mem(freedsb, &lb->hist[i].mark, (int)sizeof(void*))
+		lopt_done(&lb->hist[i]);
+	}
+	while (lb->rehist->s_n > ptr - lb->rehist->s) {
+		n = *(int*)ptr;
+		hist = (struct lopt*)&ptr[sizeof(n)];
+		for (i = 0; i < n; i++) {
+			for (c = 0; c < freedsb->s_n; c+=sizeof(void*))
+				if (*(void**)((char*)freedsb->s + c) == hist[i].mark)
+					goto skip;
+			sbuf_mem(freedsb, &hist[i].mark, (int)sizeof(void*))
+			lopt_done(&hist[i]);
+			skip:;
+		}
+		ptr += n * sizeof(lb->hist[0]) + sizeof(n);
+	}
+	sbuf_free(lb->rehist)
+	sbuf_free(freedsb)
+}
+
 void lbuf_free(struct lbuf *lb)
 {
 	int i;
 	for (i = 0; i < lb->ln_n; i++)
 		free(lb->ln[i] - sizeof(int));
-	for (i = 0; i < lb->hist_n; i++)
-		lopt_done(&lb->hist[i]);
+	lbuf_freeleafs(lb);
 	free(lb->hist);
 	free(lb->ln);
 	free(lb->ln_glob);
@@ -176,13 +204,72 @@ void lbuf_emark(struct lbuf *lb, int hist_n, int beg, int end)
 	}
 }
 
+void lbuf_setleaf(struct lbuf *lb, int leaf)
+{
+	char *ptr1 = lb->rehist->s, *ptr2;
+	int n, i, off = -1;
+	for (i = 0; lb->rehist->s_n > ptr1 - lb->rehist->s; i++) {
+		n = *(int*)ptr1;
+		if (i == leaf) {
+			off = ptr1 - lb->rehist->s;
+			break;
+		}
+		ptr1 += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
+	}
+	if (off < 0)
+		return;
+	while (!lbuf_undo(lb));
+	i = lb->hist_n - lb->hist_u;
+	if (i) {
+		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
+		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
+		ptr1 = lb->rehist->s + off;
+		lb->hist_n = n;
+		lb->hist_u = 0;
+		if (lb->hist_n >= lb->hist_sz) {
+			free(lb->hist);
+			int sz = lb->hist_n * 2;
+			struct lopt *hist = emalloc(sz * sizeof(hist[0]));
+			lb->hist = hist;
+			lb->hist_sz = sz;
+		}
+		memcpy(lb->hist, &ptr1[sizeof(n)], n * sizeof(lb->hist[0]));
+		ptr2 = &ptr1[n * sizeof(lb->hist[0]) + sizeof(n)];
+		if (lb->rehist->s_n > ptr2 - lb->rehist->s)
+			memmove(ptr1, ptr2, lb->rehist->s_n - (ptr2 - lb->rehist->s));
+		lb->rehist->s_n -= ptr2 - ptr1;
+		while (!lbuf_redo(lb));
+	}
+}
+
+char *lbuf_getleafs(struct lbuf *lb)
+{
+	char *ptr = lb->rehist->s, *bptr;
+	int n, i;
+	char buf[100];
+	sbuf *sb; sbuf_make(sb, 128)
+	for (i = 0; lb->rehist->s_n > ptr - lb->rehist->s; i++) {
+		n = *(int*)ptr;
+		bptr = itoa(i, buf);
+		*bptr++ = '=';
+		bptr = itoa(n, bptr);
+		*bptr++ = '|';
+		*bptr++ = '\0';
+		sbuf_str(sb, buf);
+		ptr += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
+	}
+	sbufn_done(sb)
+}
+
 /* append undo/redo history; return lopt idx */
 int lbuf_opt(struct lbuf *lb, char *buf, int pos, int n_del)
 {
 	struct lopt *lo;
-	int i;
-	for (i = lb->hist_u; i < lb->hist_n; i++)
-		lopt_done(&lb->hist[i]);
+	int i = lb->hist_n - lb->hist_u;
+	if (i) {
+		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
+		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
+	}
 	lb->hist_n = lb->hist_u;
 	if (lb->hist_n == lb->hist_sz) {
 		int sz = lb->hist_sz + (lb->hist_sz ? lb->hist_sz : 128);
@@ -345,13 +432,12 @@ static int lbuf_seq(struct lbuf *lb)
 /* mark buffer as saved and, if clear, clear the undo history */
 void lbuf_saved(struct lbuf *lb, int clear)
 {
-	int i;
 	if (clear) {
-		for (i = 0; i < lb->hist_n; i++)
-			lopt_done(&lb->hist[i]);
+		lbuf_freeleafs(lb);
 		lb->hist_n = 0;
 		lb->hist_u = 0;
 		lb->useq_last = lb->useq;
+		sbuf_make(lb->rehist, 128)
 	}
 	lb->useq_zero = lbuf_seq(lb);
 	lbuf_modified(xb);
diff --git a/vi.h b/vi.h
index 706f409..e3a9a58 100644
--- a/vi.h
+++ b/vi.h
@@ -150,6 +150,8 @@ int lbuf_globget(struct lbuf *lb, int pos, int dep);
 int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *r, int *o);
 int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int ln_n, int *o, int *len, int skip);
+void lbuf_setleaf(struct lbuf *lb, int leaf);
+char *lbuf_getleafs(struct lbuf *lb);
 /* motions */
 int lbuf_paragraphbeg(struct lbuf *lb, int dir, int *row, int *off);
 int lbuf_sectionbeg(struct lbuf *lb, int dir, int *row, int *off);
