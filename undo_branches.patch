diff --git a/ex.c b/ex.c
index 065cbf04..5e196606 100644
--- a/ex.c
+++ b/ex.c
@@ -1262,6 +1262,16 @@ static void *ec_setenc(char *loc, char *cmd, char *arg)
 	return NULL;
 }
 
+static void *ec_undoleafs(char *loc, char *cmd, char *arg)
+{
+	char *s = lbuf_getleafs(xb);
+	if (*arg)
+		lbuf_setleaf(xb, atoi(arg));
+	else
+		ex_print(s, msg_ft)
+	return NULL;
+}
+
 static int eo_val(char *arg)
 {
 	int val = atoi(arg);
@@ -1344,6 +1354,7 @@ static struct excmd {
 	{"uc", ec_setenc},
 	{"uz", ec_setenc},
 	{"ub", ec_setenc},
+	{"up", ec_undoleafs},
 	{"u", ec_undoredo},
 	EO(shape),
 	EO(seq),
diff --git a/lbuf.c b/lbuf.c
index 14d583f0..3610fc8b 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -3,6 +3,7 @@ struct lbuf *lbuf_make(void)
 	struct lbuf *lb = emalloc(sizeof(*lb));
 	memset(lb, 0, sizeof(*lb));
 	memset(lb->mark, -1, sizeof(lb->mark) / 2);
+	sbuf_make(lb->rehist, 128)
 	return lb;
 }
 
@@ -59,13 +60,39 @@ int lbuf_jump(struct lbuf *lb, int mark, int *pos, int *off)
 	return 0;
 }
 
+static void lbuf_freeleafs(struct lbuf *lb)
+{
+	char *ptr = lb->rehist->s;
+	struct lopt *hist;
+	int n, i, c;
+	sbuf *freedsb; sbuf_make(freedsb, 128)
+	for (i = 0; i < lb->hist_n; i++) {
+		sbuf_mem(freedsb, &lb->hist[i].mark, (int)sizeof(void*))
+		lopt_done(&lb->hist[i]);
+	}
+	while (lb->rehist->s_n > ptr - lb->rehist->s) {
+		n = *(int*)ptr;
+		hist = (struct lopt*)&ptr[sizeof(n)];
+		for (i = 0; i < n; i++) {
+			for (c = 0; c < freedsb->s_n; c+=sizeof(void*))
+				if (*(void**)((char*)freedsb->s + c) == hist[i].mark)
+					goto skip;
+			sbuf_mem(freedsb, &hist[i].mark, (int)sizeof(void*))
+			lopt_done(&hist[i]);
+			skip:;
+		}
+		ptr += n * sizeof(lb->hist[0]) + sizeof(n);
+	}
+	sbuf_free(lb->rehist)
+	sbuf_free(freedsb)
+}
+
 void lbuf_free(struct lbuf *lb)
 {
 	int i;
 	for (i = 0; i < lb->ln_n; i++)
 		free(lbuf_i(lb, i));
-	for (i = 0; i < lb->hist_n; i++)
-		lopt_done(&lb->hist[i]);
+	lbuf_freeleafs(lb);
 	free(lb->hist);
 	free(lb->ln);
 	free(lb);
@@ -142,6 +169,63 @@ void lbuf_emark(struct lbuf *lb, struct lopt *lo, int end, int o2)
 		lopt_done(lo);
 }
 
+void lbuf_setleaf(struct lbuf *lb, int leaf)
+{
+	char *ptr1 = lb->rehist->s, *ptr2;
+	int n, i, off = -1;
+	for (i = 0; lb->rehist->s_n > ptr1 - lb->rehist->s; i++) {
+		n = *(int*)ptr1;
+		if (i == leaf) {
+			off = ptr1 - lb->rehist->s;
+			break;
+		}
+		ptr1 += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
+	}
+	if (off < 0)
+		return;
+	while (!lbuf_undo(lb, &xrow, &xoff));
+	i = lb->hist_n - lb->hist_u;
+	if (i) {
+		sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
+		sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
+		ptr1 = lb->rehist->s + off;
+		lb->hist_n = n;
+		lb->hist_u = 0;
+		if (lb->hist_n >= lb->hist_sz) {
+			free(lb->hist);
+			int sz = lb->hist_n * 2;
+			struct lopt *hist = emalloc(sz * sizeof(hist[0]));
+			lb->hist = hist;
+			lb->hist_sz = sz;
+		}
+		memcpy(lb->hist, &ptr1[sizeof(n)], n * sizeof(lb->hist[0]));
+		ptr2 = &ptr1[n * sizeof(lb->hist[0]) + sizeof(n)];
+		if (lb->rehist->s_n > ptr2 - lb->rehist->s)
+			memmove(ptr1, ptr2, lb->rehist->s_n - (ptr2 - lb->rehist->s));
+		lb->rehist->s_n -= ptr2 - ptr1;
+		while (!lbuf_redo(lb, &xrow, &xoff));
+	}
+}
+
+char *lbuf_getleafs(struct lbuf *lb)
+{
+	char *ptr = lb->rehist->s, *bptr;
+	int n, i;
+	char buf[100];
+	sbuf_smake(sb, 128)
+	for (i = 0; lb->rehist->s_n > ptr - lb->rehist->s; i++) {
+		n = *(int*)ptr;
+		bptr = itoa(i, buf);
+		*bptr++ = '=';
+		bptr = itoa(n, bptr);
+		*bptr++ = '|';
+		*bptr++ = '\0';
+		sbuf_str(sb, buf);
+		ptr += n * sizeof(lb->hist[0]) + sizeof(lb->hist_n);
+	}
+	sbufn_ret(sb, sb->s)
+}
+
 /* append undo/redo history */
 struct lopt *lbuf_opt(struct lbuf *lb, char *buf, int beg, int o1, int n_del)
 {
@@ -150,8 +234,11 @@ struct lopt *lbuf_opt(struct lbuf *lb, char *buf, int beg, int o1, int n_del)
 	if (xseq < 0)
 		lo = &slo;
 	else {
-		for (int i = lb->hist_u; i < lb->hist_n; i++)
-			lopt_done(&lb->hist[i]);
+		int i = lb->hist_n - lb->hist_u;
+		if (i) {
+			sbuf_mem(lb->rehist, &lb->hist_n, (int)sizeof(lb->hist_n))
+			sbuf_mem(lb->rehist, lb->hist, (int)(lb->hist_n * sizeof(lb->hist[0])));
+		}
 		lb->hist_n = lb->hist_u;
 		if (lb->hist_n == lb->hist_sz) {
 			int sz = lb->hist_sz + (lb->hist_sz ? lb->hist_sz : 128);
@@ -388,10 +475,10 @@ int lbuf_redo(struct lbuf *lb, int *row, int *off)
 void lbuf_saved(struct lbuf *lb, int clear)
 {
 	if (clear) {
-		for (int i = 0; i < lb->hist_n; i++)
-			lopt_done(&lb->hist[i]);
+		lbuf_freeleafs(lb);
 		lb->hist_n = 0;
 		lb->hist_u = 0;
+		sbuf_make(lb->rehist, 128)
 	}
 	lb->modified = 0;
 	lb->saved = lb->hist_u;
diff --git a/vi.h b/vi.h
index 1f1a6fdc..2db37a7f 100644
--- a/vi.h
+++ b/vi.h
@@ -151,6 +151,7 @@ struct linfo {
 struct lbuf {
 	char **ln;			/* buffer lines */
 	struct lopt *hist;		/* buffer history */
+	sbuf *rehist;		/* alternate redo timelines */
 	int mark[NMARKS * 2];		/* mark rows & offs */
 	int tmp_mark[4];		/* aux mark state */
 	int ln_n;			/* number of lines in ln[] */
@@ -188,6 +189,8 @@ int lbuf_next(struct lbuf *lb, int dir, int *r, int *o);
 int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *r, int *o);
 int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r,
 			int *o, int ln_n, int skip);
+void lbuf_setleaf(struct lbuf *lb, int leaf);
+char *lbuf_getleafs(struct lbuf *lb);
 #define lbuf_dedup(lb, str, n) \
 { for (int i = 0; i < lbuf_len(lb);) { \
 	char *s = lbuf_get(lb, i); \
