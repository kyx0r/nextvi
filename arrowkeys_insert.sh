#!/bin/sh
# Generated by patch2vi from unified diff
# Separator: '@'
set -e

# Path to nextvi (adjust as needed)
VI=${VI:-vi}

# Verify that VI is nextvi
if ! $VI -? 2>&1 | grep -q 'Nextvi'; then
    echo "Error: $VI is not nextvi" >&2
    echo "Set VI environment variable to point to nextvi" >&2
    exit 1
fi

# Patch: led.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> static sbuf \\\\*suggestsb;
static sbuf \\\\*acsb;
sbuf \\\\*led_attsb;@;=
@.+2a static int vi_insmov;
.
@.,$;f+ \\\\}

static void led_printparts\\\\(sbuf \\\\*sb, int pre, int ps,@;=
@.+3;34c , int print
.
@.,$;f+ 	\\\\}
	if \\\\(pos >= xleft \\\\+ xcols \\\\|\\\\| pos < xleft\\\\)
		xleft = pos < xcols \\\\? 0 : pos - xcols / 2;@;=
@.+3,#+1c 	if (print) {
		syn_blockhl = -1;
		led_crender(r->s, -1, vi_lncol, xleft, xleft + xcols - vi_lncol);
	}
.
@.,$;f+ 	char \\\\*cs;
	int len, c, i;
	do \\\\{@;=
@.+3c 		led_printparts(sb, pre, ps, *post, postn, ai_max, !vi_insmov);
		vi_insmov = 0;
.
@.,$;f+ 			else if \\\\(!i\\\\)
				term_clean\\\\(\\\\);
			continue;@;=
@.+2a 		case '\\\\033':;	/* Arrow keys */
			char cbuf[1];
			cbuf[0] = '\\\\0';
			int fl = fcntl(STDIN_FILENO, F_GETFL);
			fcntl(STDIN_FILENO, F_SETFL, fl | O_NONBLOCK);
			read(STDIN_FILENO, cbuf, 1);
			if (*cbuf == '[') {
				read(STDIN_FILENO, cbuf, 1);
				fcntl(STDIN_FILENO, F_SETFL, fl);
				if (ai_max < 0) {
					/* Prompt mode: handle arrows internally */
					int lc, clen, plen;
					char *newpost;
					switch (*cbuf) {
					case 'D':  /* ← */
						if (len > pre) {
							lc = led_lastchar(sb->s + pre) + pre;
							clen = len - lc;
							plen = strlen(*post);
							newpost = malloc(plen + clen + 1);
							memcpy(newpost, sb->s + lc, clen);
							memcpy(newpost + clen, *post, plen + 1);
							free(*postref);
							*postref = *post = newpost;
							postn++;
							sbuf_cut(sb, lc)
						}
						continue;
					case 'C':  /* → */
						if (**post) {
							clen = uc_len(*post);
							sbuf_mem(sb, *post, clen)
							plen = strlen(*post);
							newpost = malloc(plen - clen + 1);
							memcpy(newpost, *post + clen, plen - clen + 1);
							free(*postref);
							*postref = *post = newpost;
							postn--;
						}
						continue;
					case 'A':  /* ↑ - history */
					case 'B':  /* ↓ - history */
						continue;
					}
				}
				vi_insmov = *cbuf;
				return *cbuf;
			}
			fcntl(STDIN_FILENO, F_SETFL, fl);
			return c;
.
@.,$;f+ int led_prompt\\\\(sbuf \\\\*sb, char \\\\*insert, int \\\\*kmap, ins_state \\\\*is, int ps, int flg\\\\)
\\\\{
	int n = !\\\\(flg & 2\\\\) \\\\? sb->s_n : 0, key;@;=
@.+3;29;33c NULL
.
@.,$;f+ 	key = led_line\\\\(sb, ps, n, &post, 0, &postref, -1, kmap, is, 0, xrow, xtop, flg\\\\);
	restore\\\\(xtd\\\\)
	restore\\\\(xleft\\\\)@;=
@.+2a 	sbufn_str(sb, post)
	free(postref);
.
@.,$;f+ 			return key;
		\\\\}
		sbuf_chr\\\\(sb, key\\\\)@;=
@.+3;37c , 1
.
@vis 4@wq" $VI -e 'led.c'

# Patch: vi.c
EXINIT="rcm:|sc! \\\\@|vis 6@%;f> 	\\\\*l = ln - pln;
\\\\}
@;=
@.+2a static int lmodified;

.
@.,$;f+ 	if \\\\(postn \\\\+ l2 != tlen \\\\|\\\\| memcmp\\\\(ln \\\\+ l1, sb->s \\\\+ l1, tlen - l2 - l1\\\\)\\\\)
		lbuf_edit\\\\(xb, sb->s, r1, r2 \\\\+ 1, o1, xoff\\\\);
	free\\\\(sb->s\\\\);@;=
@.+2a 	lmodified = 1;
.
@.,$;f+ 	term_room\\\\(cmdo\\\\);
	sbuf_mem\\\\(sb, ln, l1\\\\)
	key = led_input\\\\(sb, post, postn, row, cmdo << 2, &postn\\\\);@;=
@.+3;32c  {
.
@.-1@>		lbuf_edit\\(xb, sb-\\>s, row, row \\+ !cmdo, off, xoff\\);>a 		lmodified = 1;
	} else
		lmodified = 0;
.
@.,$;f+ 					term_back\\\\(xoff != lbuf_eol\\\\(xb, xrow, 1\\\\) \\\\? 'i' : 'a'\\\\);
					break;
				\\\\}@;=
@.+2a 				switch (k) {
				case 'A':	/* ↑ */
					term_back(!lmodified ? c : 'i');
					if (lmodified)
						vi_col = vi_off2col(xb, xrow, xoff);
					xrow--;
					xrow = xrow < 0 ? 0 : xrow;
					xoff = vi_col2off(xb, xrow, vi_col);
					lmodified = 0;
					goto _break;
				case 'B':	/* ↓ */
					term_back(!lmodified ? c : 'i');
					if (lmodified)
						vi_col = vi_off2col(xb, xrow, xoff);
					xrow++;
					xoff = vi_col2off(xb, xrow, vi_col);
					lmodified = 0;
					goto _break;
				case 'D':	/* ← */
					term_back('i');
					xoff--;
					xoff = xoff < 0 ? 0 : xoff;
					vi_col = vi_off2col(xb, xrow, xoff);
					goto _break;
				case 'C':	/* → */
					term_back(*uc_chr(lbuf_get(xb, xrow), xoff+2) ? 'i' : 'A');
					xoff++;
					if (*uc_chr(lbuf_get(xb, xrow), xoff))
						vi_col = vi_off2col(xb, xrow, xoff);
					goto _break;
				}
.
@.,$;f+ 				if \\\\(c != 'A' && c != 'C'\\\\)
					xoff--;
				break;@;=
@.+2a 				_break:
				vi_mod = 0;
				break;
.
@vis 4@wq" $VI -e 'vi.c'
