Nextvi(1)		    General Commands Manual		     Nextvi(1)

NAME
     Nextvi – A small vi/ex editor for editing bidirectional UTF-8 text

SYNOPSIS
     vi [-emsv] [file ...]

DESCRIPTION
     Nextvi is a vi(1)-like text editor based on Ali Gholami Rudi's Neatvi(1).
     VI is a legendary command-line text editor, first introduced by Bill Joy
     in 1976, renowned for its modal interface, which allows users to switch
     between insert, command, and visual modes for seamless text manipulation.
     This powerful and efficient editor has stood the test of time, remaining
     a staple tool for developers and system administrators in Unix and Linux
     environments, thanks to its flexibility, customization options, and
     syntax similar to other vi/ex editors. To mark its 50th anniversary,
     Nextvi emerges as the pinnacle of VI's evolution. This masterpiece of
     efficiency and elegance boasts unparalleled startup speed, unmatched
     portability, exceptional hackability, and an incredibly robust macro
     system, among other features. Nextvi is truly the next generation of VI,
     ready to elevate your text editing experience.

OPTIONS
     -e	     Enter Ex mode on startup
     -m	     Disable initial file read message
     -s	     Enter raw Ex mode on startup
     -v	     Enter visual mode on startup (Default)

NOTATION
     <x>     An x representation of non-printable character literal
     [x]     An x representation of a optional argument
     {x}     An x representation of a required argument
     <^X>    A representation of a ctrl key X
     #	     A representation of a positive number
     *	     A representation of any character(s)
     |	     A separation of alternative representations

VI NORMAL
     [#]+
     [#]j
     [#]<^M>
     [#]<Newline>
		   Move the cursor # lines down
     [#]-
     [#]k
		   Move the cursor # lines up
     [#]h	   Move the cursor # cols left
     [#]l	   Move the cursor # cols right
     f{arg}	   Move the cursor to the arg character found forward
     F{arg}	   Move the cursor to the arg character found backward
     t{arg}	   Move the cursor until the arg character found forward
     T{arg}	   Move the cursor until the arg character found backward
     [#],	   Repeat last f or F or t or T command backward # times
     [#];	   Repeat last f or F or t or T command forward # times
     [#]B	   Move the cursor to the end of the word skipping punctuation
		   backward # times
     [#]E	   Move the cursor to the end of the word skipping punctuation
		   forward # times
     [#]b	   Move the cursor to the end of the word backward # times
     [#]e	   Move the cursor to the end of the word forward # times
     [#]W	   Move the cursor to the start of the word skipping
		   punctuation forward # times
     [#]w	   Move the cursor to the start of the word forward # times
     {		   Move the cursor to the next { region up
     }		   Move the cursor to the next { region down
     [		   Move the cursor to the next <^M> region up
     ]		   Move the cursor to the next <^M> region down
     ^		   Move the cursor to the start of the line after indentation
     0 |	   Move the cursor to the start of the line
     $		   Move the cursor to the end of the line
     [#]|	   Move the cursor to # col
     [#]<Space>	   Move cursor # characters forward
     [#]<^H>
     [#]<Backspace>
		   Move cursor # characters backward
     %		   Move the cursor to [](){} pair
     [#]%	   Move the cursor to the # percent line number
     '{arg}	   Goto a line mark arg
     `{arg}	   Goto a line mark arg with horizontal position
     gg		   Goto the first line in the buffer
     [#]G	   Goto the last line in the buffer or # line
     H		   Goto the highest line of the screen
     L		   Goto the lowest line of the screen
     M		   Goto the middle line of the screen
     [#]z.	   Center the screen. # is xtop
     [#]z<^M>
     [#]z<Newline>
		   Center the screen at top row. # is xtop
     [#]z-	   Center the screen at bottom row. # is xtop
     [#]<^E>	   Scroll down 1 or # lines. # is set and stored, cursor
		   position preserved
     [#]<^Y>	   Scroll up 1 or # lines. # is set and stored, cursor
		   position preserved
     [#]<^D>	   Scroll down half a screen size. If # set scroll to # lines
     [#]<^U>	   Scroll up half a screen size. If # set scroll to # lines
     <^B>	   Scroll up full screen size
     <^F>	   Scroll down full screen size
     #		   Show global and relative line numbers
     2#		   Toggle show global line numbers permanently
     4#		   Toggle show relative line numbers after indentation
		   permanently
     8#		   Toggle show relative line numbers permanently
     V		   Toggle show hidden characters: Space,Tab,New line
     <^V>	   Toggle show line motion numbers for ebEBwW
     [#]<^V>	   Disable line motion numbers
     [#]<^R>	   Redo # times
     [#]u	   Undo # times
     <^I>
     <Tab>
		   Open file using text from the cursor to end of the line
     <^K>	   Write the current buffer to file. Force write on 2nd
		   attempt
     [#]<^W>{arg}  Unindent arg region # times
     [#]<{arg}	   Indent left arg region # times
     [#]>{arg}	   Indent right arg region # times
     "{arg}	   Operate on the register arg
     R		   Print registers and their contents
     [#]&{arg}	   Execute arg register macro in non-blocking mode # times
     [#]@{arg}	   Execute arg register macro in blocking mode # times
     [#]@@
     [#]&&
		   Execute a last executed register macro # times
     [#].	   Repeat last normal command # times
     [#]v.	   Repeat last normal command moving down across # lines
     :		   Enter vi mode ex prompt
     [#]!{arg}	   Enter pipe ex prompt based on the region specified by # or
		   arg
     vv		   Open ex prompt with the last ex command from history
     [#]vr	   Open %s/ ex prompt. Insert # word(s) from the cursor
     [#]vt[#arg]   Open .,.+0s/ ex prompt. # specifies number of lines from
		   the cursor. Insert #arg word(s) from the cursor
     [#]v/	   Open v/ xkwd ex prompt to set search keyword. Insert #
		   word(s) from the cursor
     v;		   Open ! ex prompt
     vb		   Recurse into b-1 history buffer. Any quit command shall
		   exit recursion
     [#]vi	   Open %s/^ {8}/ /g ex prompt. Contains regex for changing
		   spaces to tabs. # modifies the width
     [#]vI	   Open %s/^ /	      /g ex prompt. Contains regex for
		   changing tabs to spaces. # modifies the width
     vo		   Remove trailing white spaces and <\r> line endings
     va		   Toggle autoindent on or off. see ai ex option
     <^G>	   Print buffer status infos
     1<^G>	   Enable permanent status bar row
     2<^G>	   Disable permanent status bar row
     ga		   Print character info
     1ga	   Enable permanent character info bar row
     2ga	   Disable permanent character info bar row
     [#]gw	   Hard line wrap a line to # col limit
     [#]gq	   Hard line wrap a buffer to # col limit
     g~{arg}	   Switch character case for arg region
     gu{arg}	   Switch arg region to lowercase
     gU{arg}	   Switch arg region to uppercase
     [#]~	   Switch character case # times forward
     i		   Enter insert mode
     I		   Enter insert moving cursor to the start of the line after
		   indentation
     a		   Enter insert mode 1 character forward
     A		   Enter insert mode moving cursor to the end of the line
     [#]s	   Enter insert mode deleting # characters
     S		   Enter insert mode deleting everything on the line
     o		   Enter insert mode creating a new line down
     O		   Enter insert mode creating a new line up
     [#]c{arg}	   Enter insert mode deleting arg region # times
     C		   Enter insert mode deleting from cursor to the end of the
		   line
     [#]d{arg}	   Delete arg region # times
     D		   Delete from a cursor to the end of the line
     [#]x	   Delete # characters under the cursor forward
     [#]X	   Delete # characters under the cursor backward
     di{arg}	   Delete around arg which can be ( or ) or "
     ci{arg}	   Change around arg which can be ( or ) or "
     [#]r{arg}	   Replace # characters with arg under the cursor forward
     K		   Split a line
     [#]K	   Split a line without creating empty new lines
     [#]J	   Join # lines
     vj		   Toggle space padding when joining lines
     [#]y{arg}	   Yank arg region # times
     Y		   Yank a line
     [#]p	   Paste a default register
     [#]P	   Paste a default register below current line or behind
		   cursor pos
     m{arg}	   Set a buffer local line mark arg
     <^T>	   Set a global file mark 0
     [#]<^T>	   Set or switch to a global mark based on # % 2 == 0
     [#]<^7>
     [#]<^_>
		   Show buffer list and switch based on # or 0-9 index when
		   prompted
     <^^>
     <^6>
		   Swap to the previous buffer
     [#]<^N>	   Swap to the next buffer, # changes direction
		   (forward/backward)
     \		   Swap to /fm/ buffer b-2
     z{arg}	   Change alternate keymap to arg
     ze
     zf
		   Switch to the English and alternate keymap
     zL		   Set td ex option to 2
     zl		   Set td ex option to 1
     zr		   Set td ex option to -1
     zR		   Set td ex option to -2
     [#]/	   Search using regex down skipping # matches
     [#]?	   Search using regex up skipping # matches
     [#]n	   Repeat search down skipping # matches
     [#]N	   Repeat search up skipping # matches
     <^A>	   Auto search word under the cursor, not centering and
		   wrapping up/down direction
     [#]<^A>	   Auto search setting # words from the cursor
     <^]>	   Filesystem search forward based on directory listing in b-2
     [#]<^]>	   Filesystem search forward, setting search keyword to #
		   words under the cursor
     <^P>	   Filesystem search backward based on directory listing in
		   b-2
     [#]<^P>	   Filesystem search backward, setting search keyword to #
		   words under the cursor
     <^Z>	   Suspend vi
     <^L>	   Force redraw whole screen and update terminal dimensions
     qq		   Force quit cleaning the terminal
     zz		   Force quit not cleaning the terminal, submits commands if
		   recursive
     ZZ		   Soft quit, attempting to write the file before exit

INSERT MODE
     <^H>
     <Backspace>
		   Delete a character
     <^U>	   Delete util <^X> mark or everything
     <^W>	   Delete a word
     <^T>	   Increase indent
     <^D>	   Decrease indent
     <^]>	   Switch a default paste register to 0-9
     <^\>{arg}	   Select paste register arg. <^\> selects default register
     <^P>	   Paste a register
     <^G>	   Index buffer for autocomplete
     <^Y>	   Reset autocomplete data
     <^R>	   Loop through autocomplete options backward
     <^N>	   Loop through autocomplete options forward
     <^Z>	   Suspend vi/ex
     <^X>	   Set a mark for <^U> and completion starting position
     <^B>	   Recurse into b-1 history buffer when in ex prompt. Use any
		   quit command to exit recursion
     <^B>	   Print autocomplete options when in vi insert
     <^A>	   Loop through the strings in a history buffer b-1
     <^L>	   Redraw the screen in vi mode, clean the terminal in ex
     <^O>	   Switch between vi and ex modes recursively
     <^O>	   Switch to english keymap
     <^F>	   Switch to alternative keymap
     <^V>{arg}	   Read a literal character arg
     <^K>{arg}	   Read a digraph sequence arg
     <^C>
     <ESC>
		   Exit insert mode

VI MOTIONS
     Basic motion examples:
     3d/int  Delete text until the 3rd instance of "int" keyword
     d3w     Delete 3 words
     "ayl    Yank a character into 'a' register
     "Ayw    Append a word to 'a' register

EX
     Ex is a line editor for Unix systems originally written by Bill Joy in
     1976.  In ex, every command is prefixed with ':'. Ex is essential to vi,
     which allows it to run commands and macros. Together vi and ex create a
     beautiful symbiosis, which complements each other and helps to solve
     various domain problems.

EX EXPANSION
     Characters # and % in ex prompt substitute the buffer pathname.
     % substitutes current buffer and # last swapped buffer.
     It is possible to expand any arbitrary buffer by using % or
     # (no difference in this case) followed by the buffer number.
     Example:
     print the pathname for buffer 69 (if it exists).
     :!echo "%69"

     Every ex command is be able to receive data from the outside
     world through a special expansion character ! which runs a pipe
     command. If the closing ! is not specified, the end of the line
     becomes a terminator.
     Example:
     Substitute the value of env var $SECRET to the value of $RANDOM :).
     In this demo, we set the value of SECRET to "int" ourselves.
     :%s/!export SECRET="int" && printf "%s" $SECRET!/!printf "%s" $RANDOM! :)

EX ESCAPES
     Nextvi special character escapes work mostly the same way everywhere
     except the following situations:
      - Escapes in regex bracket expressions.
      - Due to ex expansion # % and ! characters have to be escaped
	if they are part of an ex command.
      - A single back slash requires 2 back slashes, and so on.
      - regex requires for ( to be escaped if used inside [] brackets.
      - In ex prompt the only separator is "|" character. It can
	be escaped normally but will require extra back slash if passed
	into a regular expression or a global command.

EX RANGES
     Some ex commands can be prefixed with ranges.
     Examples:
     .	     current position
     ,	     vertical range separator
     ;	     horizontal range separator
     :1,5p   print lines 1,5
     :.-5,.+5p
	     print 5 lines around xrow
     :/int/p
	     print first occurrence of int
     :?int?p
	     print first occurrence of int in reverse
     :.,/int/p
	     print until int is found
     :?int?,.p
	     print until int is found in reverse
     :'d,'ap
	     print lines from mark d to mark a
     :%p     print all lines in the buffer
     :$p     print last line in the buffer
     :;50    goto character offset 50
     :10;50  goto line 10 character offset 50
     :10;.+5
	     goto line 10 +5 character offset
     :'a;'a  goto line mark a character offset a
     :;$     goto end of the line
     :5;/int/
	     search for int on line 5
     :.;?int?
	     search for int in reverse on the current line

EX COMMANDS
     [range]f{/?}[kwd]
	     Ranged search (stands for find)

	     Example: no range given, current line only
	     :f/int
	     Example: reverse
	     :f?int
	     Example: range given
	     :10,100f/int
	     Subsequent commands within the range will move to the next match
	     just like vi n/N commands.

     b[#]    Print currently active buffers state or switch to a buffer

	     Example: switch to the 5th buffer
	     :b5

	     There are 2 temporary buffers which are separate from
	     the main buffers.
	     b-1 = /hist/ ex history buffer
	     b-2 = /fm/ directory listing buffer
	     Example: switch to the b-1 buffer
	     :b-1
	     Example: switch to the b-2 buffer
	     :b-2

     bp [path]
	     Set current buffer path
     bs[#]   Set current buffer saved. If any arg given, reset undo/redo
	     history

     [range]p
	     Print line(s) from the buffer

	     Example: utilize character offset ranges
	     :1,10;5;5p
	     Example: print current line from offset 5 to 10
	     :.;5;10p

     ea [kwd] [#]
	     Open file based on it's filename substring and from listing in
	     b-2

	     Requires directory listing in b-2 backfilled prior.
	     Example: backfill b-2 using :fd
	     :fd
	     Example: backfill b-2 using find
	     :b-2|1,$!find .

	     If the substring matches more than 1 filename, a prompt will
	     be shown. Submit using numbers 0-9 (higher ascii values work
	     too (<^C> to cancel)). Passing an extra arg to :ea in form of
	     a number will bypass the prompt and open the corresponding file.
	     Example: open filename containing "v"
	     :ea v
	     Example: open first match containing "v"
	     :ea v 0

     ea![kwd] [#]
	     Forced version of ea

     [#]a [#]i [#]c
	     Enter ex append/insert/change mode

	     # determines insertion line number.
	     Exiting with <^M>.<^M> or <^M><ESC> will apply changes to the buffer.
	     Exiting with <^C> will discard changes.

     [range]d
	     Delete line(s)
     e [path]
	     Open a file at a path
     e!	     Reload the current buffer from the filesystem

     [range]g{*}[kwd]{*}{cmd}
	     Global command

	     Execute an ex command on a range of lines that matches an
	     enclosed regex.

	     Example: remove empty lines
	     :g/^$/d

	     Multiple ex commands can be chained in one global command.
	     To chain commands, the ex separator "|" must be escaped once.
	     Example: yank matches appending to reg 'a' and print them out.
	     :g/int/ya A\|p

	     It is possible to nest global commands inside of global commands.
	     Example: find all lines with int and a semicolon and append
	     "has a semicolon"
	     :g/int/:.g/;/& A has a semicolon
	     Advanced example: extract/print data enclosed in ()
	     :g/\(.+\)/;0;/\(.+\)/\|.;.+1k a\|se grp=2\|;/\)*(\))/\|se nogrp\|k s\|.;'a;'sp

     [range]g!{*}[kwd]{*}{cmd}
	     Inverted global command
     [range]=
	     Print the current range line number

     [range]k [mark]
	     Set a line mark

	     The character offset is set to the current position.

     &{macro}
	     Global non-blocking macro

	     Execute any sequence of vi/ex commands or macros.
	     A non-blocking macro shall not wait for input when the end of
	     the sequence is reached. A non-blocking macro executing other
	     macros will always reach a terminating point.
	     Example: execute vi insert statement
	     :& ihello
	     Example: execute :hello
	     :& :hello
	     Example: execute ci(int macro
	     :& ci(int
	     Example: turn non-blocking into blocking macro
	     :& :@ :run as non-blocking but blocking<^V><^M>

     @{macro}
	     Global blocking macro

	     Execute any sequence of vi/ex commands or macros.
	     A blocking macro shall wait for input when the end of the sequence
	     is reached. A blocking macro executing other macros may result
	     in congestion.
	     Example: execute vi insert statement
	     :@ ihello
	     Example: insert hello into : prompt
	     :@ :hello
	     Example: execute ci(int macro
	     :@ ci(int
	     Example: execute ci(int exiting insert mode
	     :@ ci(int<^V><^C>
	     Example: execute ci)INT as a follow-up
	     :@ ci(int<^V><^C>ci)INT

     pu [register] [cmd]
	     Paste a register

	     To pipe register data to an external process use :pu \![cmd]
	     Example: copy default register to X11 clipboard
	     :pu \!xclip -selection clipboard

     q	     Soft quit
     q!	     Force quit

     [range]r [path|cmd]
	     Read a file or a pipe

	     To read data from a pipe use :[range]r \![cmd]
	     Example: pipe in only the first line
	     :r \!ls
	     Example: pipe in only lines 3,5
	     :3,5r \!ls
	     Example: pipe in all data
	     :%r \!ls

     [range]w [path|cmd]
	     Write to a file or a pipe

	     To pipe buffer data to external process use :[range]w \![cmd]
	     Example: pipe out all data into less
	     :w \!less
	     Example: pipe out only first 10 lines
	     :1,10w \!less

     [range]w! [path]
	     Force write to a file

     wq[!]
     x[!]
	     Write and force/soft quit

     u[#|$]  Undo # times or all with $
     rd[#|$]
	     Redo # times or all with $

     se {exp}
	     Set a variable

	     Example: set using implications
	     :se hll
	     :se nohll
	     Example: set using exact values
	     :se hll=1
	     :se hll=0

     [range]s{*}[kwd]{*}{str}[*][opts]
	     Substitute

	     Find and replace text in a range of lines that matches an
	     enclosed regex with an enclosed replacement string.

	     Example: global replacement
	     :%s/term1/term2/g

	     Substitution backreference inserts the text of matched group
	     specified by \x where x is group number.

	     Example: substitution backreference
	     this is an example text for subs and has int or void
	     :%s/(int)\|(void)/pre\0after
	     this is an example text for subs and has preintafter or void
	     :%s/(int)\|(void)/pre\2after/g
	     this is an example text for subs and has prepreafterafter or prevoidafter

     [range]ya [register][append]
	     Yank a region

	     To append to the register, pass in its uppercase version.
	     To append to any of the non-alphabetical registers add any extra
	     character to the command.
	     Example: append to register 1
	     :ya 1x

     ya!     Reset register value

     [range]![cmd]
	     Run external program

	     When ex range specified, pipes the buffer data to an external
	     process and pipes the output back into current buffer replacing
	     the affected range.
	     Example: infamously sort the buffer
	     :1,$!sort

     ft [filetype]
	     Set a filetype

	     No argument prints the current file type.
	     Reloads the highlight ft, which makes it possible to reset dynamic
	     highlights created by options like "hlw".

     cm [keymap]
	     Set a keymap

	     No argument prints the current keymap name.

     cm! [keymap]
	     Set an alternative keymap

     fd [path]
	     Set a secondary directory (stands for file dir)

	     Recalculates the directory listing in b-2 buffer.
	     No argument implies current directory.

     fp [path]
	     Set a directory path for :fd (stands for file path)

     cd [path]
	     Set a working directory (stands for change dir)

	     Currently open buffers' file paths will be automatically adjusted
	     to reflect a newly set working directory.

     inc [regex]
	     Include regex for :fd calculation

	     Example: include only files in submodule directory that end with .c
	     :inc submodule.*\.c$
	     Example: exclude the .git and submodule folders
	     :inc (^[\!.git\!submodule]+[^\/]+$)
	     No argument disables the filter.

     reg     Print registers and their contents

     bx[#]   Set max number of buffers allowed

	     Buffers will be deallocated if the number specified is lower
	     than the number of buffers currently in use.
	     No argument will reset to the default value of 10.

     ac [regex]
	     Set autocomplete filter regex

	     Example: autocomplete using whole lines from the buffer
	     :ac .+
	     No argument resets to the default word filter regex as defined
	     in led.c.

     uc	     Toggle multibyte utf-8 decoding

	     This command is particularly useful when editing files with
	     mixed encodings, binary files, or when the terminal does not
	     support UTF-8 or lacks the necessary fonts to display UTF-8
	     characters. Typically to be used along with :ph for the full
	     effect.

     ph [#clow] [#chigh] [#width] [#blen][*]
	     Create new placeholders

	     Examples:
	     render 8 bit ascii (Extended ASCII) as '~':
	     :ph 128 255 1 1~
	     flawless ISO/IEC 8859-1 (latin-1) support:
	     :uc|ph 128 160 1 1~
	     reset to default as in conf.c:
	     :ph

EX OPTIONS
     ai	     If set, indent new lines.
     ic	     If set, ignore case in regular expressions.

     ish     Interactive shell

	     Makes every "!" pipe command run through an interactive shell
	     so that all shell features e.g. aliases work.

     grp     Regex search group

	     Defines a target search group for any regex search operation.
	     This becomes necessary when the result of regex search is to
	     be based on some group rather than default match group.

	     Example: ignore tabs at the beginning of the line
	     :se grp=2|1,$f/^[	     ]+(.+)|se nogrp

	     The value of grp is calculated using (group number * 2).
	     The default group number is 0.

     hl	     If set, highlight text based on rules defined in conf.c.
     hlr     If set, highlight text in reverse direction.
     hll     If set and defined in hl, highlight current line.
     hlp     If set and defined in hl, highlight [](){} pairs.
     hlw     If set and defined in hl, highlight current word under the
	     cursor.
     led     If unset, all terminal output is disabled.

     vis     Control startup flags

	     Example: disable :e message in ex mode
	     :se vis=12
	     Example: disable :e message in vi mode
	     :se vis=8
	     Example: enable raw ex mode
	     :se vis=6
	     Example: disable raw ex mode
	     :se vis=4

     mpt     Control vi prompts

	     When set to 0 after an ex command is called from vi, disables
	     the "[any key to continue]" prompt.
	     If mpt is negative, the prompt will remain disabled.

     order   If set, reorder characters based on rules defined in conf.c.
     shape   If set, perform Arabic script letter shaping.
     pac     If set, print autocomplete suggestions on the fly.
     tbs     Number of spaces used to represent a tab.
     td	     Current text direction context.  This option accepts four
	     meaningful values:
	     +2	     Exclusively left-to-right.
	     +1	     Follow dircontexts[] (in conf.c), defaulting to left-to-
		     right.
	     -1	     Follow dircontexts[], defaulting to right-to-left.
	     -2	     Exclusively right-to-left.

     pr	     Print register

	     Set a special register using a character or a number.
	     Once the register is set, all data passed into ex_print will
	     be stored in the register.
	     If the register is uppercase, new lines are added to match the
	     exact output that was printed.
	     Example: paste current buffer list exactly like from :b command
	     :se pr=A|ya! a|b|pu a
	     Example: store a line printed with :p
	     :se pr=A|ya! a|p

EXINIT ENV VAR
     EXINIT defines a sequence of vi/ex commands to be performed
     at startup. Consequently, this is the primary way for scripting
     and customizing nextvi outside of C.
     Many standard text processing utils such as grep, awk, sed
     can be replaced by nextvi with EXINIT in mind.

     Example 1:
     There is a dictionary file (assume vi.c), which we always want
     to have indexed at startup for autocomplete. The last "bx" commands
     delete the vi.c buffer.
     export EXINIT=$(printf "e ./vi.c|& i\x7\x3|bx 1|bx")

     Example 2:
     Load some file (assume vi.c) into vi's history buffer.
     export EXINIT="b-1|%r ./vi.c|b-1"

     Example 3:
     Setup a @ macro in register a
     When @a is executed the macro will create { and closing } below
     the cursor leaving cursor in insert mode in between the braces.
     export EXINIT=$(printf "e|& io{\n}\x16\x3kA\x3|& 1G|& 2\"ayy")

REGEX
     Nextvi's regex syntax is akin to that of Plan 9.
     .	     match any single char
     ^	     assert start of the line
     $	     assert end of the line
     {N,M}   match N to M times
     ()	     grouping
     (?:)    non capture grouping
     [N-M]   match ranges N to M
     *	     repeated zero or more times
     +	     repeated one or more times
     |	     union, alternative branch
     \<	     assert beginning of the word
     \>	     assert end of the word
     ?	     one or zero matches greedy
     ??	     one or zero matches lazy

     Additionally, Nextvi's supports static lookahead expressions. For example
     [!abc] and [=abc] where ! is negated version of =. This will treat "abc"
     as (a && b && c) logically. It is possible to have multiple in one
     bracket expression as well. For example [!abc!cda!qwe] where each string
     delimited by the ! acts like a typical or operation i.e. [acq] with only
     difference of testing the extra characters ahead. To combine both
     standard bracket expression and lookahead in one, use ^ or ^= where ^ is
     negated and ^= is default. For example: [!abc^=123] characters after ^=
     match exactly how [123] would.

SPECIAL MARKS
     *	     position of the previous change
     [	     first line of the previous change
     ]	     last line of the previous change

SPECIAL REGISTERS
     /	     previous search keyword
     :	     previous ex command
     0	     previous value of default register (atomic)
	     Atomic means the operation did not include a <Newline> character.
     1-9     previous value(s) of default register (nonatomic)

CODE MAP
     +---------------+-----------------------+
     | 462   vi.h    | definitions/aux	     |
     | 537   kmap.h  | keymap translation    |
     +---------------+-----------------------+
     | 293   conf.c  | hl/ft/td config	     |
     | 336   term.c  | low level IO	     |
     | 382   ren.c   | positioning/syntax    |
     | 600   lbuf.c  | file/line buffer	     |
     | 653   uc.c    | UTF-8 support	     |
     | 658   regex.c | extended RE	     |
     | 662   led.c   | insert mode/output    |
     | 1232  ex.c    | ex options/commands   |
     | 2003  vi.c    | normal mode/general   |
     | 6819  total   | wc -l *.c|sort	     |
     +---------------+-----------------------+

COMPILING
     export CC='g++ -x c'
	     set compiler, g++ example
     export CFLAGS='-s'
	     set CFLAGS, strip example
     ./cbuild.sh
	     Basic build
     ./cbuild.sh debug
	     Basic debug build
     ./cbuild.sh pgobuild
	     pgobuild which can lead to a significant performance boost on
	     some application specific tasks.
     valgrind --tool=cachegrind --cache-sim=yes --branch-sim=yes ./vi vi.c
	     performance bench test

PHILOSOPHY
     In most text editors, flexibility is a minor or irrelevant design goal.
     Nextvi is designed to be flexible where the editor adapts to the user needs.
     This flexibility is achieved by heavily chaining basic commands and allowing
     them to create new ones with completely different functionality. Command
     reuse keeps the editor small without infringing on your freedom to quickly
     get a good grasp on the code. If you want to customize anything, you should
     be able to do it using the only core commands or a mix with some specific C
     code for more difficult tasks. Simple and flexible design allows for straight
     forward solutions to any problem long term and filters bad inconsistent ideas.

     "All software sucks, but some do more than others."
	     - Kyryl Melekhin

SEE ALSO
     New functionality can be obtained through optional patches provided in the
     patches branch. If you have a meaningful contribution and would love to be
     made public the patch can be submitted via email or github pull request.
     https://github.com/kyx0r/nextvi/tree/patches

     Scripts used to generate this manual are located in the manual branch.
     https://github.com/kyx0r/nextvi/tree/manual

     Q: What is pikevm?
     A: Pikevm is a complete rewrite of nextvi's regex engine for the purposes of
     getting rid of backtracking and severe performance and memory constraints.
     Pikevm guarantees that all regular expressions are computed in constant space
     and O(n+k) time where n is size of the string and k is some constant for the
     complexity of the regex i.e. number of state transitions. It is important to
     understand that it does not mean that we run at O(n) linear speed, but rather
     the amount of processing time & memory usage is distributed evenly and linearly
     throughout the string, the k constant plays a big role. If you are familiar
     with radix sort algorithms this follows the same idea.
     Q: What are the other benefits?
     A: For example, now it is possible to compute a C comment /* n */ where n can
     be an infinite number of characters. Of course this extends to every other
     valid regular expression.
     Q: New features pikevm supports?
     A: Additionally, pikevm supports PCRE style non capture group (?:) and lazy
     quantifiers like .*? and .+?? because they were easy to implement and allow
     for further regex profiling/optimization.
     Q: NFA vs DFA (identify)
     A: pikevm = NFA backtrack = DFA
     Q: What's wrong with original implementation?
     A: Nothing except it being slow and limited. My improved version of Ali's DFA
     implementation ran 3.5X faster in any case, however I found a bug with it
     where zero quantifier "?" nested groups compute wrong submatch results. To
     fix this problem, it would require to undo a lot of optimization work already
     done, basically going back to how slow Ali's implementation would be. The reason
     this was spotted so late was because this kind of regex wasn't used before,
     so I never tested it. Other than that I think submatch extraction is correct
     on other cases. Pikevm does not have this bug, so it will be used as main
     regex engine from now on, unless dfa ever finds a proper fix. Honestly, this
     change isn't so surprising, as I was working on pikevm a few months prior, to
     favor a superior algorithm.
     You can still find that code here (likely with no updates):
     https://github.com/kyx0r/nextvi/tree/dfa_dead
     As a downside, NFA simulation loses the DFA property of being able to
     quickly short circuit a match, as everything runs linearly and at constant
     speed, incurring match time overhead. Well optimized DFA engine can
     outperform pikevm, but that is rather rare as they got problems of their own.
     For example as independently benchmarked, dfa_dead runs only 13% faster than
     pikevm and that is stretching the limit of what is physically possible on a
     table based matcher. Can't cheat mother nature, and if you dare to try she's
     unforgiving at best.
     Supplementary reading by Russ Cox:
     https://swtch.com/~rsc/regexp/regexp1.html

     Original Neatvi repository:
     https://github.com/aligrudi/neatvi

AUTHORS
     Nextvi was written by Kyryl Melekhin <k.melekhin@gmail.com>.  It is based
     on neatvi(1), which was written by Ali Gholami Rudi <ali@rudi.ir>.	 This
     manual page was inspired by népéta <nepeta@canaglie.net>

Linux 6.11.5-arch1-1	       November 1, 2024		  Linux 6.11.5-arch1-1
