diff --git a/conf.c b/conf.c
index 926d306f..ad3a948c 100644
--- a/conf.c
+++ b/conf.c
@@ -29,6 +29,7 @@ char fm_ft[] = "/fm";	/* file manager */
 char n_ft[] = "/#";	/* numbers highlight for ^v */
 char nn_ft[] = "/##";	/* numbers highlight for # */
 char ac_ft[] = "/ac";	/* autocomplete dropdown */
+char grep_ft[] = "/g";	/* grep buffer */
 char ex_ft[] = "/ex";	/* ex mode (is never '\n' terminated) */
 char vs_ft[] = "/vs";	/* vi search prompt (is never '\n' terminated) */
 char bar_ft[] = "/-";	/* status bar (is never '\n' terminated) */
@@ -252,6 +253,9 @@ return|select|switch|type|var))\\>", A(GR1, BL1 | SYN_BD, YE1)},
 		A(IN, SYN_BGMK(RE1), SYN_BGMK(AY1), SYN_BGMK(AY))},
 	{ac_ft, "[^ \t-/:-@[-^{-~]+$|(.+$)", A(IN, SYN_BGMK(AY1))},
 
+	{grep_ft, "^(.+?):([0-9]+):(.+)", A(MA, GR1, CY, AY1)},
+	{grep_ft, NULL, A(AY | SYN_BGMK(RE1)), 1, 3},
+
 	{ex_ft, ".+", A(AY1 | SYN_BD), 1},
 	{ex_ft, ":[ \t]*((((?:\\|.*?(?:(?<^\\\\)\\||$))*(?:<.*?(?:(?<^\\\\)<|$)|>.*?(?:(?<^\\\\)>|$))?\
 [.%$]?(?:'[a-z'`[\\]*])?([0-9]*)?)(?:([-*-+/%])[0-9]+)*(?:\\|.*?(?:(?<^\\\\)\\||$))*)[ \t]*(?:([,;]#?)[ \t]*\
diff --git a/ex.c b/ex.c
index 2d75f3be..d447d015 100644
--- a/ex.c
+++ b/ex.c
@@ -35,7 +35,7 @@ sbuf *xacreg;			/* autocomplete db filter regex */
 rset *xkwdrs;			/* the last searched keyword rset */
 sbuf *xregs[256];		/* string registers */
 struct buf *bufs;		/* main buffers */
-struct buf tempbufs[2];		/* temporary buffers, for internal use */
+struct buf tempbufs[3];		/* temporary buffers, for internal use */
 struct buf *ex_buf;		/* current buffer */
 struct buf *ex_pbuf;		/* prev buffer */
 static struct buf *ex_tpbuf;	/* temp prev buffer */
diff --git a/vi.c b/vi.c
index b78c070b..d01d843e 100644
--- a/vi.c
+++ b/vi.c
@@ -496,12 +496,12 @@ void dir_calc(char *path)
 	free(sb->s);
 }
 
-#define fssearch() \
+#define fssearch(isbuffer) \
 len = lbuf_s(path)->len; \
 path[len] = '\0'; \
 ret = ex_edit(path, len); \
 path[len] = '\n'; \
-if (ret && xrow) { \
+if (isbuffer) { \
 	*row = xrow; *off = xoff; /* short circuit */ \
 	if (!vi_search('n', cnt, row, off, 0)) \
 		return 1; \
@@ -512,14 +512,14 @@ if (ret && xrow) { \
 if (!vi_search(*row ? 'N' : 'n', cnt, row, off, 0)) \
 	return 1; \
 
-static int fs_search(int cnt, int *row, int *off)
+static int fs_search(int again, int cnt, int *row, int *off)
 {
 	char *path;
-	int again = 0, ret, len;
+	int ret, len;
 	wrap:
 	while (fspos < lbuf_len(tempbufs[1].lb)) {
 		path = tempbufs[1].lb->ln[fspos++];
-		fssearch()
+		fssearch(ret && xrow && again != 2)
 	}
 	if (fspos == lbuf_len(tempbufs[1].lb) && !again) {
 		fspos = 0;
@@ -535,7 +535,7 @@ static int fs_searchback(int cnt, int *row, int *off)
 	int ret, len;
 	while (--fspos >= 0) {
 		path = tempbufs[1].lb->ln[fspos];
-		fssearch()
+		fssearch(ret && xrow)
 	}
 	return 0;
 }
@@ -711,6 +711,7 @@ static int vi_motion(int vc, int *row, int *off)
 				break;
 		break;
 	case TK_CTL(']'):	/* this is also ^5 on some systems */
+	case TK_CTL('x'):
 	case TK_CTL('p'):
 		#define open_saved(n) \
 		if (savepath[n]) { \
@@ -729,8 +730,42 @@ static int vi_motion(int vc, int *row, int *off)
 			lkwdcnt = xkwdcnt;
 			fspos += fsdir < 0 ? 1 : 0;
 			fspos = MIN(fspos, lbuf_len(tempbufs[1].lb));
-			fs_search(1, row, off);
+			fs_search(0, 1, row, off);
 			fsdir = 1;
+		} else if (mv == TK_CTL('x')) {
+			term_exec("", 1, '&')
+			temp_pos(2, -1, 0, 0);
+			temp_switch(2, 0);
+			sbuf *gstats; sbuf_make(gstats, 1024)
+			char nbuf[100];
+			int colpos = 0;
+			fspos = 0;
+			while (fs_search(2, 1, row, off)) {
+				sbuf_str(gstats, xb_path)
+				sbuf_chr(gstats, ':')
+				colpos = gstats->s_n;
+				#define nextrow() \
+				itoa((*row)+1, nbuf); \
+				sbuf_str(gstats, nbuf) \
+				sbuf_chr(gstats, ':') \
+				sbufn_str(gstats, lbuf_get(xb, *row)) \
+				temp_write(2, gstats->s); \
+				(*row)++; \
+
+				nextrow()
+				while (!vi_search('n', cnt, row, off, 0)) {
+					sbuf_cut(gstats, colpos)
+					nextrow()
+				}
+				sbuf_cut(gstats, 0)
+			}
+			sbuf_free(gstats)
+			for (i = xbufcur-1; i >= 0 && bufs[i].mtime == -1; i--)
+				ex_bufpostfix(&bufs[i], 1);
+			temp_switch(2, 0);
+			lbuf_jump(xb, '[', row, off);
+			*off = 0;
+			syn_reloadft(syn_addhl(xregs['/'] ? xregs['/']->s : NULL, 3), xic ? REG_ICASE : 0);
 		} else {
 			fspos -= fsdir > 0 ? 1 : 0;
 			if (!fs_searchback(1, row, off)) {
@@ -1290,7 +1325,17 @@ void vi(int init)
 				char buf[strlen(ln)+4];
 				strcpy(buf, ":e ");
 				strcpy(buf+3, ln);
-				term_push(buf, strlen(ln)+3);
+				if (!strcmp(xb_path, "/grep/")) {
+					int subs[2];
+					rset *rs = rset_make(1, (char*[]){":[0-9]+:"}, 0);
+					if (rset_find(rs, buf, subs, 0) >= 0) {
+						buf[subs[0]] = xsep;
+						buf[subs[1]-1] = '\n';
+						buf[subs[1]] = '\0';
+					}
+					rset_free(rs);
+				}
+				term_push(buf, strlen(buf));
 				break; }
 			case TK_CTL('n'):
 				vi_cndir = vi_arg ? -vi_cndir : vi_cndir;
@@ -1432,6 +1477,10 @@ void vi(int init)
 					}
 					ln = vi_enprompt(":", buf, &k, &n);
 					goto do_excmd; }
+				case 'x':
+					temp_switch(2, 1);
+					vi_mod = 1;
+					break;
 				default:
 					term_dec()
 				}
@@ -1796,6 +1845,7 @@ int main(int argc, char *argv[])
 	syn_init();
 	temp_open(0, "/hist/", _ft);
 	temp_open(1, "/fm/", fm_ft);
+	temp_open(2, "/grep/", grep_ft);
 	for (i = 1; i < argc && argv[i][0] == '-'; i++) {
 		if (argv[i][1] == '-' && !argv[i][2]) {
 			i++;
diff --git a/vi.h b/vi.h
index 0c3e52bb..942f2319 100644
--- a/vi.h
+++ b/vi.h
@@ -443,7 +443,7 @@ extern sbuf *xacreg;
 extern rset *xkwdrs;
 extern sbuf *xregs[256];
 extern struct buf *bufs;
-extern struct buf tempbufs[2];
+extern struct buf tempbufs[3];
 extern struct buf *ex_buf;
 extern struct buf *ex_pbuf;
 #define istempbuf(buf) (buf - bufs < 0 || buf - bufs >= xbufcur)
