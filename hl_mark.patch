diff --git a/ex.c b/ex.c
index 2d75f3be..32b3e67a 100644
--- a/ex.c
+++ b/ex.c
@@ -7,6 +7,7 @@ int xhll;			/* highlight current line */
 int xhlw;			/* highlight current word */
 int xhlp;			/* highlight {}[]() pair */
 int xhlr;			/* highlight text in reverse direction */
+int xhlm;			/* highlight marks */
 int xled = 1;			/* use the line editor */
 int xtd = +1;			/* current text direction */
 int xshape = 1;			/* perform letter shaping */
@@ -1285,6 +1286,7 @@ static void *eo_##opt(char *loc, char *cmd, char *arg) { inner }
 EO(pac) EO(pr) EO(ai) EO(ish) EO(ic) EO(grp) EO(shape) EO(seq)
 EO(sep) EO(tbs) EO(td) EO(order) EO(hll) EO(hlw) EO(hlp) EO(hlr)
 EO(hl) EO(lim) EO(led) EO(vis) EO(mpt) EO(err)
+EO(hlm)
 
 _EO(left,
 	if (*loc)
@@ -1372,6 +1374,7 @@ static struct excmd {
 	EO(tbs),
 	EO(td),
 	EO(order),
+	EO(hlm),
 	EO(hll),
 	EO(hlw),
 	EO(hlp),
diff --git a/vi.c b/vi.c
index b78c070b..24dcbb02 100644
--- a/vi.c
+++ b/vi.c
@@ -1715,6 +1715,21 @@ void vi(int init)
 				word = cs;
 			}
 		}
+		if (xhlm) {
+			int mrow, moff;
+			char marks[] = "abcdefghijklmnopqrstuvwxyz[]`*";
+			led_att la;
+			if (!led_attsb)
+				sbuf_make(led_attsb, sizeof(la))
+			for (int i = 0; i < LEN(marks); i++) {
+				if (lbuf_jump(xb, marks[i], &mrow, &moff))
+					continue;
+				la.s = lbuf_get(xb, mrow);
+				la.off = moff;
+				la.att = SYN_BGMK(((i % 15) + 1));
+				sbuf_mem(led_attsb, &la, (int)sizeof(la))
+			}
+		}
 		if (xhlp && (k = syn_findhl(3)) >= 0) {
 			int row = xrow, off = xoff, row1, off1;
 			led_att la;
