.Dd Oct 22, 2024
.Dt Nextvi 1
.Os
.
.Sh NAME
.Nm Nextvi
.Nd A small vi/ex editor for editing bidirectional UTF-8 text
.
.Sh SYNOPSIS
.Nm vi
.Op Fl emsv
.Op Ar
.
.Sh DESCRIPTION
.Nm Nextvi
is a
.Xr vi 1 Ns -like
text editor based on Ali Gholami Rudi's
.Xr Neatvi 1 Ns .
VI is a legendary command-line text editor, first introduced
by Bill Joy in 1976, renowned for its modal interface, which
allows users to switch between insert, command, and visual modes
for seamless text manipulation. This powerful and efficient
editor has stood the test of time, remaining a staple tool for
developers and system administrators in Unix and Linux environments,
thanks to its flexibility, customization options, and syntax
similar to other vi/ex editors. To mark its 50th anniversary,
Nextvi emerges as the pinnacle of VI's evolution. This masterpiece
of efficiency and elegance boasts unparalleled startup speed,
unmatched portability, exceptional hackability, and an incredibly
robust macro system, among other features. Nextvi is truly the
next generation of VI, ready to elevate your text editing experience.
.
.Sh OPTIONS
.Bl -tag -width Ds -compact
.It Fl e
Enter Ex mode on startup
.It Fl m
Disable initial file read message
.It Fl s
When combined with -e enters limited Ex mode
.It Fl v
Enter visual mode on startup. (Default)
.El
.Sh NOTATION
.Bl -tag -width Ds -compact
.It Cm arg1-
An optional number prefixing a command
.It Cm -arg2
A required argument suffixing a command
.It Cm C-
A ctrl key
.It Cm Space
A separation, multiple binds to the same command
.El
.Sh VI NORMAL
.Bl -tag -width Dq -compact
.It Cm arg1-+ arg1-\en arg1-j
Move the cursor arg1 lines down
.It Cm arg1-- arg1-k
Move the cursor arg1 lines up
.It Cm ^
Move the cursor to the start of the line after indentation

.It Cm arg1-#
Enable/Disable line numbers and switch modes:
.Bl -nested -compact
.It
# - single shot print, shows global and relative numbers.
.It
2# - permanent. shows global numbers.
.It
4# - permanent. shows relative numbers after indentation.
.It
8# - permanent. shows relative numbers.
.El

.It Cm C-^ C-6
Switch to previous buffer
.It Cm arg1-C-r
Redo arg1 times
.It Cm arg1-u
Undo arg1 times
.It Cm C-i TAB
Open file using text from the cursor to eol
.It Cm arg1-C-e
Scroll down 1 or arg1 lines. arg1 is set and stored, cursor position preserved
.It Cm arg1-C-y
Scroll up 1 or arg1 lines. arg1 is set and stored, cursor position preserved
.It Cm arg1-C-d
Scroll down half a screen size. If arg1 set scroll to arg1 lines
.It Cm arg1-C-u
Scroll up half a screen size. If arg1 set scroll to arg1 lines
.It Cm C-b
Scroll up full screen size
.It Cm C-f
Scroll down full screen size
.It Cm C-k
Write the current buffer to file. 2nd attempt force writes
.It Cm arg1-C-w-arg2
Unindent arg2 region
.It Cm arg1-<-arg2
Indent left arg2 region
.It Cm arg1->-arg2
Indent right arg2 region
.It Cm @-arg2
Execute a arg2 register macro
.It Cm @@
Execute a last executed register macro on a new line
.It Cm arg1-.
Repeat last normal command arg1 times
.It Cm arg1-v.
Repeat last normal command moving down across arg1 lines
.It Cm :
Enter vi mode ex prompt
.It Cm arg1-!-arg2
Enter pipe ex prompt based on the region specified by arg1 or arg2
.It Cm vv
Open ex prompt with the last ex command from history
.It Cm arg1-vr
Open %s/ ex prompt. arg1 specifies word(s) from the cursor to be inserted
.It Cm arg1-vt-arg2
Open .,.+0s/ ex prompt. arg1 specifies number of lines from the cursor. arg2 specifies word(s) from the cursor to be inserted
.It Cm arg1-v/
Open v/ xkwd ex prompt to set search keyword. arg1 specifies word(s) from the cursor to be inserted
.It Cm v;
Open ! ex prompt
.It Cm vb
Switch to b-1 history buffer
.It Cm arg1-vi
Open %s/^ {8}/	/g ex prompt. Contains regex for changing spaces to tabs. arg1 modifies the width
.It Cm arg1-vI
Open %s/^	/        /g ex prompt. Contains regex for changing tabs to spaces. arg1 modifies the width
.It Cm vo
Removes \er character from line endings and trailing white spaces
.It Cm va
Toggle autoindent on or off. see xai
.It Cm C-g
Print buffer status infos
.It Cm 1-C-g
Enable permanent status bar row
.It Cm 2-C-g
Disable permanent status bar row
.It Cm ga
Print character info
.It Cm 1-ga
Enable permanent character info bar row
.It Cm 2-ga
Disable permanent character info bar row
.It Cm arg1-gw
Hard wrap a line to arg1 col limit
.It Cm arg1-gq
Hard wrap a buffer to arg1 col limit
.It Cm gg
Goto the first line in the buffer
.It Cm g~-arg2
Switch case for arg2 region
.It Cm gu-arg2
Switch to lowercase for arg2 region
.It Cm gU-arg2
Switch to uppercase for arg2 region
.It Cm arg1-~
Switch case arg1 times forward
.It Cm '-arg2
Goto a line mark arg2
.It Cm m-arg2
Set a buffer local line mark arg2
.It Cm i
Enter insert mode
.It Cm I
Enter insert moving cursor to the start of the line after indentation
.It Cm a
Enter insert mode 1 character forward
.It Cm A
Enter insert mode moving cursor to the eol
.It Cm s
Enter insert mode deleting character under the cursor
.It Cm S
Enter insert mode deleting everything on the line
.It Cm o
Enter insert mode creating a new line down
.It Cm O
Enter insert mode creating a new line up
.It Cm arg1-c-arg2
Enter insert mode deleting based on the arg2 motion region
.It Cm C
Enter insert mode deleting from cursor to the eol
.It Cm arg1-d-arg2
Delete a arg2 region
.It Cm D
Delete from a cursor to the eol
.It Cm di-arg2
Delete around arg2 which can be ( or ) or \&"
.It Cm ci-arg2
Change around arg2 which can be ( or ) or \&"
.It Cm K
Split a line
.It Cm arg1-K
Split a line without creating empty new lines
.It Cm arg1-J
Join arg1 lines
.It Cm vj
Raw line join mode, disables space padding when joining lines
.It Cm arg1-y-arg2
Yank a region
.It Cm Y yy
Yank a line
.It Cm arg1-p
Paste a default register
.It Cm arg1-P
Paste a default register below current line or behind cursor pos
.It Cm \&"-arg2
Operation on the register arg2
.It Cm R
Print registers and their contents
.It Cm V
Toggle show hidden characters: Space,Tab,New line
.It Cm arg1-r-arg2
Replace arg1 characters with arg2 under the cursor forward
.It Cm C-v
Show line motion numbers for ebEBwW. Switches its modes
.It Cm arg1-C-v
Disable line motion numbers
.It Cm arg1-G
Goto the last line in the buffer or arg1 line
.It Cm H
Goto the highest line of the screen
.It Cm L
Goto the lowest line of the screen
.It Cm M
Goto the middle line of the screen
.It Cm arg1-x
Delete arg1 characters under the cursor forward
.It Cm arg1-X
Delete arg1 characters under the cursor backward
.It Cm arg1-,
Repeat last f or F or t or F command backward arg1 times
.It Cm arg1-;
Repeat last f or F or t or F command forward arg1 times
.It Cm arg1-h
Move the cursor arg1 cols left
.It Cm arg1-l
Move the cursor arg1 cols right
.It Cm f-arg2
Move the cursor to the arg2 character found forward
.It Cm F-arg2
Move the cursor to the arg2 character found backward
.It Cm t-arg2
Move the cursor until the arg2 character found forward
.It Cm T-arg2
Move the cursor until the arg2 character found backward
.It Cm arg1-B
Move the cursor to the end of the word skipping punctuation backward arg1 times
.It Cm arg1-E
Move the cursor to the end of the word skipping punctuation forward arg1 times
.It Cm arg1-b
Move the cursor to the end of the word backward arg1 times
.It Cm arg1-e
Move the cursor to the end of the word forward arg1 times
.It Cm arg1-W
Move the cursor to the start of the word skipping punctuation forward arg1 times
.It Cm arg1-w
Move the cursor to the start of the word forward arg1 times
.It Cm {
Move the cursor to the next { region up
.It Cm }
Move the cursor to the next { region down
.It Cm [
Move the cursor to the next \en region up
.It Cm ]
Move the cursor to the next \en region down
.It Cm C-]
Filesystem search forward based on directory listing in b-2
.It Cm arg1-C-]
Filesystem search forward, setting search keyword to arg1 words under the cursor
.It Cm C-p
Filesystem search backward based on directory listing in b-2
.It Cm C-t
Set a global file mark
.It Cm arg1-C-t
Set or switch to a global mark based on arg1 % 2 == 0
.It Cm arg1-C-7 arg1-C-_
Show buffer list and switch based to arg1 buffer or 0-9 when prompted
.It Cm 0 |
Move the cursor to the start of the line.
.It Cm arg1-z.
Center the screen. arg1 is xtop
.It Cm arg1-z\en
Center the screen at top row. arg1 is xtop
.It Cm arg1-z-
Center the screen at bottom row. arg1 is xtop
.It Cm z-arg2
Change alternate keymap to arg2
.It Cm ze zf
Switch to the English and alternate keymap
.It Cm zL zl zr zR
Change the value of td option
.It Cm $
Move the cursor to the eol
.It Cm arg1-|
Move the cursor to arg1 col
.It Cm arg1-/
Search using regex down skipping arg1 matches
.It Cm arg1-?
Search using regex up skipping arg1 matches
.It Cm arg1-n
Repeat search down skipping arg1 matches
.It Cm arg1-N
Repeat search up skipping arg1 matches
.It Cm C-a
Auto search word under the cursor, not centering and wrapping up/down direction
.It Cm arg1-C-a
Auto search setting arg1 words from the cursor
.It Cm arg1-Space
Move cursor arg1 character forward
.It Cm arg1-C-h arg1-Backspace
Move cursor arg1 character backward
.It Cm `-arg2
Goto a line mark arg2 with horizonal position
.It Cm %
Move the cursor to [](){} pair
.It Cm arg1-%
Move the cursor to the arg1 percent line number
.It Cm arg1-C-n
Swap to the next buffer, arg1 changes direction (forward/backward)
.It Cm \e
Swap to /fm/ buffer b-2
.It Cm C-z
Suspend vi
.It Cm C-l
Force redraw whole screen and update terminal dimensions
.It Cm qq
Force quit cleaning the terminal
.It Cm zz
Force quit not cleaning the terminal, submits commands if recursive
.It Cm ZZ
Soft quit, attempting to write the file before exit
.El
.
.Sh INSERT MODE
.Bl -tag -width Dq -compact
.It Cm C-h Backspace
Delete a character
.It Cm C-u
Delete util C-x mark or everything
.It Cm C-w
Delete a word
.It Cm C-t
Increase indent
.It Cm C-d
Decrease indent
.It Cm C-]
Switch a default paste register to 0-9
.It Cm C-\e-arg2
Select paste register arg2. \e selects default register
.It Cm C-p
Paste a register
.It Cm C-g
Index a buffer for autocomplete
.It Cm C-y
Reset autocomplete db
.It Cm C-r
Loop through autocomplete options backward
.It Cm C-n
Loop through autocomplete options forward
.It Cm C-z
Suspend vi/ex
.It Cm C-x
Set a mark for C-u and completion starting position
.It Cm C-b
Open history buffer b-1 when in ex prompt, otherwise print autocomplete options
.It Cm C-a
Loop through the strings from a history buffer b-1
.It Cm C-l
Redraw the screen in vi mode, clean the terminal in ex
.It Cm C-o
Switch between vi and ex modes
.It Cm C-e
Switch to english keymap
.It Cm C-f
Switch to alternative keymap
.It Cm C-v-arg2
Read a literal character arg2
.It Cm C-k-arg2
Read a digraph sequence arg2
.It Cm C-c ESC
Exit insert mode
.El
.
.Sh VI MOTIONS
Basic motion examples:
.Bl -tag -width Ds -compact
.It Cm 3d/int
Delete text until the 3rd instance of "int" keyword
.It Cm d3w
Delete 3 words
.It Cm \&"ayl
Yank a character into 'a' register
.It Cm \&"Ayw
Use uppercase to append a word to 'a' register
.El
.
.Sh EX
Ex is a line editor for Unix systems originally written by Bill Joy in 1976.
In ex, every command is prefixed with ':'. Ex is essential to vi, which allows it
to run commands and macros. Together vi and ex create a beautiful symbiosis, which
complements each other and helps to solve various domain problems.
.
.Sh EX EXPANSION
.Bd -literal -compact
Characters # and % in ex prompt substitute the buffer pathname.
% substitutes current buffer and # last swapped buffer.
It is possible to expand any arbitrary buffer by using % or
# (no difference in this case) followed by the buffer number.
Example:
print the pathname for buffer 69 (if it exists).
:!echo "%69"

Every ex command is be able to receive data from the outside
world through a special expansion character ! which runs a pipe
command. If the closing ! is not specified, the end of the line
becomes a terminator.
Example:
Substitute the value of env var $SECRET to the value of $RANDOM :).
In this demo, we set the value of SECRET to "int" ourselves.
:%s/!export SECRET="int" && printf "%s" $SECRET!/!printf "%s" $RANDOM! :)
.Ed
.
.Sh EX ESCAPES
Nextvi special character escapes work mostly the same way everywhere
except the following situations:
.Bd -literal -compact
 - Escapes in regex bracket expressions.
 - Due to ex expansion # % and ! characters have to be escaped
   if they are part of an ex command.
 - A single back slash requires 2 back slashes, and so on.
 - regex requires for ( to be escaped if used inside [] brackets.
 - In ex prompt the only separator is "|" character. It can
   be escaped normally but will require extra back slash if passed
   into a regular expression.
.Ed
.
.Sh EX RANGES
Some ex commands can be prefixed with ranges.
.Bl -tag -width Ds -compact
.It Cm :1,5p
print lines 1,5
.It Cm :.-5,.+5p
print 5 lines around xrow
.It Cm :.,/int/p
print until int is found
.It Cm :?int?,.p
print until int is found in reverse
.Bd -literal -compact
Note: in some cases . can be dropped but is kept for readability.
.Ed
.It Cm :'d,'ap
print lines from mark d to mark a
.El
.
.Sh EX COMMANDS
.Bl -tag -width Ds -compact
.It Cm f
Ranged search (stands for find)
.Bd -literal
Example (no range given, current line only):
:f/int
or
:f?int
or (specified range)
:10,100f/int
Additionally, :f supports xoff (horizontal offset). This is
essential for scripting macros. Subsequent commands within the
range will move to the next match just like n/N.
.Ed

.It Cm b
Print currently active buffers and their state
.It Cm bp
Set current buffer path
.It Cm bs
Set current buffer saved. If arg given, reset undo/redo history
.It Cm p
Print line(s) from the buffer

.It Cm ea
Open file based on it's filename substring and from listing in b-2
.Bd -literal
Requires directory listing in b-2 backfilled prior. May be done
with :fd

If the substring matches more than 1 filename, a prompt will
be shown. Submit using numbers 0-9 (higher ascii values work
too (^c to cancel)). Passing an extra arg to :ea in form of
a number will bypass the prompt and open the corresponding file.
.Ed

.It Cm ea!
Forced version of ea
.It Cm a
Enter ex append mode (exiting with ^c will discard changes)
.It Cm i
Enter ex insert mode (exiting with ^c will discard changes)
.It Cm c
Enter ex change mode (exiting with ^c will discard changes)
.It Cm d
Delete line(s)
.It Cm e
Open a file at path
.It Cm e!
Reload the current buffer from FS

.It Cm g
Global command
.Bd -literal
Same syntax as ex substitution command, but instead of replacement
string it takes an ex command after the / / enclosed regex.
Example: remove empty lines
:g/^$/d
Try doing similar with substitution command - will not work
as removing '\en' without deleting the line is invalid, but
it will work with global command. Multiple ex commands can be
chained in one global command.
In this case the ex separator has to be escaped once.
Example: yank matches appending to reg 'a' and print them out.
:g/int/ya A\e|p
If you wanted to get really fancy, it is possible to nest global
commands inside of global commands.
Example: find all lines with int and a semicolon and append "has a semicolon"
:g/int/:.g/;/tp A has a semicolon
.Ed

.It Cm g! v
Inverted global command
.It Cm =
Move the cursor to a line number
.It Cm k
Set a mark

.It Cm tp
Global macro (stands for term_push)
.Bd -literal
It can run any vi normal command and execute insert statements.
The advantage of tp over traditional macros is in the ability
to bypass the macro queue and run independently. In a way, macro
executed by tp exercises the same causality as running C code
directly.
.Ed

.It Cm pu
Paste a register
.Bd -literal
:pu command can pipe the register to an external program by
specifying \e! as a 2nd argument.
.Ed

.It Cm q
Soft quit
.It Cm q!
Force quit

.It Cm r
Read a file
.Bd -literal
To read data from a pipe use :r \e!date
.Ed

.It Cm w
Soft write a to file
.Bd -literal
To pipe data to external process use :w \e!less
.Ed

.It Cm w!
Force write a to file
.It Cm wq x
Write and soft quit
.It Cm wq! x!
Write and force quit
.It Cm u
Undo
.It Cm rd
Redo

.It Cm se
Set a variable
.Bd -literal
Examples:
:se var=1
:se novar
.Ed

.It Cm s
Substitute
.Bd -literal
Basic usage:
:%s/term1/term2/g

Substitution backreference:
This inserts the text of matched group specified by \ex where x is
group number. Example:
this is an example text for subs and has int or void
:%s/(int)\e|(void)/pre\e0after
this is an example text for subs and has preintafter or void
:%s/(int)\e|(void)/pre\e2after/g
this is an example text for subs and has prepreafterafter or prevoidafter
.Ed

.It Cm ya
Yank a region
.Bd -literal
ya can append to any of the non-alphabetical registers by adding
any extra character to the command.
Example: append to register 1
:ya 1x
.Ed

.It Cm ya!
Reset register value
.It Cm !
Run external program

.It Cm ft
Set a filetype
.Bd -literal
Without filetype, prints the current file type. When filetype
is specified, sets the file type of the current ex buffer.
In nextvi :ft also reloads the highlight ft, which makes it
possible to reset dynamic highlights created by options like
"hlw".
.Ed

.It Cm cm cm!
Keymap
.Bd -literal
Without kmap, prints the current keymap name. When kmap is specified,
sets the alternate keymap to kmap and, unless ! is given, switches
to this keymap.
.Ed

.It Cm fd
Set a secondary directory (stands for file dir)
.Bd -literal
Recalculates the directory listing for fssearch or :ea ex command.
No argument implies current directory.
.Ed

.It Cm fp
Set a secondary directory path (stands for file path)
.It Cm cd
Set a working directory (stands for change dir)

.It Cm inc
Include regex for :fd calculation
.Bd -literal
Example 1:
We want to get only files in submodule directory that end with .c
extension:
:inc submodule.*\e.c$
Example 2:
Exclude the .git and submodule folders.
:inc (^[\e!.git\e!submodule]+[^\e/]+$)
Running "inc" without an arg will disable all filters.
.Ed

.It Cm reg
Print registers and their contents
.It Cm bx
Set max number of buffers allowed (default is 10)

.It Cm ac
Set autocomplete filter regex
.Bd -literal
Running ex command "ac" with no argument will reset back to
the default word filtering regex. You can find its string in
led.c as a reference.
.Ed

.It Cm uc
Toggle multibyte utf-8 decoding
.Bd -literal
This feature is particularly useful when editing files with
mixed encodings, binary files, or when the terminal does not
support UTF-8 or lacks the necessary fonts to display UTF-8
characters. Typically to be used along with :ph for the full
effect.
.Ed

.It Cm ph
Create new placeholders
.Bd -literal
Examples:
render 8 bit ascii (Extended ASCII) as '~':
:ph 128 255 1 1~
flawless ISO/IEC 8859-1 (latin-1) support:
:uc|ph 128 160 1 1~
reset to default as in conf.c:
:ph
.Ed
.
.El
.
.Sh EX OPTIONS
.Bl -tag -width Ds -compact
.
.It Cm ai
If set, indent new lines.
.
.It Cm ic
If set, ignore case in regular expressions.

.It Cm ish
Interactive shell
.Bd -literal
Makes every "!" pipe command run through an interactive shell
so that all shell features e.g. aliases work.
.Ed

.It Cm grp
Regex search group
.Bd -literal
The following allows definition of target search group for /?nN,
autocomplete, ranged search, and ex substitution. This becomes
necessary when the result of regex search is to be based on
some group rather than default match group. For example you
want to search for the whole line but exclude the tabs at the
beginning of the line, use regex like this: [	]+(.[^ ]+) since
only the capture result for 2nd group matters use the "grp"
like this: :se grp=2 .The number 2 is important, it is calculated
using: grpnum * 2. In this case grpnum is 1. The default grpnum
is always 0.
.Ed

.
.It Cm hl
If set, highlight text based on rules defined in
.Pa conf.c .
.
.It Cm hll
If set, highlight current line.
.
.It Cm hlp
If set, highlight pairs of brackets.
.
.It Cm hlr
If set, highlight text in reverse direction.
.
.It Cm hlw
If set, highlight current word under the cursor.
.
.It Cm led
If unset, all terminal output is disabled.

.It Cm mpt
Control vi prompts
.Bd -literal
When set to 0 after an ex command is called from vi, disables
the "[any key to continue]" prompt. If mpt is negative, the
prompt will remain disabled.
.Ed

.It Cm order
If set, reorder characters based on rules defined in
.Pa conf.c .
.
.It Cm shape
If set, perform Arabic script letter shaping.
.
.It Cm pac
If set, print autocomplete suggestions on the fly.
.
.It Cm tbs
Number of spaces used to represent a tab.
.
.It Cm td
Current text direction context.
This option accepts four meaningful values:
.Bl -tag -width Ds -compact
.It Ar +2
Exclusively left-to-right.
.It Ar +1
Follow
.Va dircontexts[]
(in
.Pa conf.c ) ,
defaulting to left-to-right.
.It Ar -1
Follow
.Va dircontexts[] ,
defaulting to right-to-left.
.It Ar -2
Exclusively right-to-left.
.El

.It Cm pr
Print register
.Bd -literal
Set a special register using a character or a number. For instance,
:se pr=a will use the register 'a'. When the register is set,
all data passed into ex_print will be stored. If the register
is uppercase, new lines are added to match the exact output
that was printed. With this, internal editor state can be exported.
For example, printing the current buffers list with :b to a
file is possible.
.Ed
.
.El
.
.Sh EXINIT ENV VAR
.Bd -literal
EXINIT can be used to achieve arbitrary level of customization.
Using ex command "tp" any sequence of vi/ex commands can be
performed at startup.

To run examples below:
There are invisible/non printing characters inside the EXINIT
string. Visual copy paste in most programs will not copy it
correctly. Copy it into a file and execute like this:
	$ source ./init.sh
The new line inside the EXINIT string is literal and is represented
with "\en". To suppress EXINIT invoke vi like so: EXINIT= vi file
When scripting for improved performance, output can be disabled
by running :se noled and the initial load message can be suppressed
using -m commandline.

Example 1:
There is a dictionary file (assume vi.c), which we always want to have indexed
at startup for autocomplete.
export EXINIT="e ./vi.c|tp i|bx 1|bx"
The last "bx" commands delete the vi.c buffer. To keep it around as a buffer
remove the "bx" commands.
Example 2:
Load your shell's history into vi's history buffer and adjust the data such
that it is usable by appending ! at the beginning of command and escaping the "|"
pipes the way ex prompt expects them.
export EXINIT=$'e /root/.ash_history|tp yG:p:%s/^/\e!\e\e|%s/ \e| / \e\e\e\e\e\e| /g\enqq|bx 1|bx|ft'
Congratulations, vi has unofficially replaced your shell's frontend.
Example 3:
Setup some custom @@ macros in your favorite registers.
export EXINIT=$'e|tp io{\en}kA|tp 1G|tp 2\e"ayy'
This macro gets loaded into register a, when @a is executed the macro will
create { and closing } below the cursor leaving cursor in insert mode in
between the braces. This is something you would commonly do in C like
programming language.
.Ed
.
.Sh SPECIAL MARKS
.Bl -tag -width Ds -compact
.It Cm *
the position of the previous change
.It Cm [
the first line of the previous change
.It Cm ]
the last line of the previous change
.El
.
.Sh SPECIAL REGISTERS
.Bl -tag -width Ds -compact
.It Cm /
the previous search keyword
.It Cm :
the previous ex command
.It Cm 0
previous value of default register (atomic)
.Bd -literal -compact
Atomic means the operation did not include a whole line
and a \en character.
.Ed
.It Cm 1-9
previous value(s) of default register (nonatomic)
.El
.
.Sh CODE MAP
.Bd -literal -compact
+--------------+---------------------+
| 537  kmap.h  | keymap translation  |
| 457  vi.h    | definitions/aux     |
+--------------+---------------------+
| 653  uc.c    | UTF-8 support       |
| 324  term.c  | low level IO        |
| 293  conf.c  | hl/ft/td config     |
| 658  regex.c | extended RE         |
| 601  lbuf.c  | file/line buffer    |
| 1199 ex.c    | ex options/commands |
| 2054 vi.c    | normal mode/general |
| 662  led.c   | insert mode/output  |
| 382  ren.c   | positioning/syntax  |
| 6826 total   | wc -l *.c           |
+--------------+---------------------+
.Ed
.
.Sh COMPILING
.Bl -tag -width Ds -compact
.It Cm export CC='g++ -x c'
set compiler, g++ example
.It Cm export CFLAGS='-s'
set CFLAGS, strip example
.It Cm ./cbuild.sh
Basic build
.It Cm ./cbuild.sh debug
Basic debug build
.It Cm ./cbuild.sh pgobuild
pgobuild which can lead to a significant performance boost on
some application specific tasks.
.It Cm valgrind --tool=cachegrind --cache-sim=yes --branch-sim=yes ./vi vi.c
performance bench test
.El
.
.Sh PHILOSOPHY
.Bd -literal -compact
In most text editors, flexibility is a minor or irrelevant design goal.
Nextvi is designed to be flexible where the editor adapts to the user needs.
This flexibility is achieved by heavily chaining basic commands and allowing
them to create new ones with completely different functionality. Command
reuse keeps the editor small without infringing on your freedom to quickly
get a good grasp on the code. If you want to customize anything, you should
be able to do it using the only core commands or a mix with some specific C
code for more difficult tasks. Simple and flexible design allows for straight
forward solutions to any problem long term and filters bad inconsistent ideas.

.Sy \&"All software sucks, but some do more than others."
.Em 	- Kyryl Melekhin
.Ed
.
.Sh SEE ALSO
.Bd -literal -compact
New functionality can be obtained through optional patches provided in the
patches branch. If you have a meaningful contribution and would love to be
made public the patch can be submitted via email or github pull request.
.Lk https://github.com/kyx0r/nextvi/tree/patches

Resources used to create this manual and contributions to be submitted on
the manual branch.
.Lk https://github.com/kyx0r/nextvi/tree/manual

Q: What is pikevm?
A: Pikevm is a complete rewrite of nextvi's regex engine for the purposes of
getting rid of backtracking and severe performance and memory constraints.
Pikevm guarantees that all regular expressions are computed in constant space
and O(n+k) time where n is size of the string and k is some constant for the
complexity of the regex i.e. number of state transitions. It is important to
understand that it does not mean that we run at O(n) linear speed, but rather
the amount of processing time & memory usage is distributed evenly and linearly
throughout the string, the k constant plays a big role. If you are familiar
with radix sort algorithms this follows the same idea.
Q: What are the other benefits?
A: For example, now it is possible to compute a C comment /* n */ where n can
be an infinite number of characters. Of course this extends to every other
valid regular expression.
Q: New features pikevm supports?
A: Additionally, pikevm supports PCRE style non capture group (?:) and lazy
quantifiers like .*? and .+?? because they were easy to implement and allow
for further regex profiling/optimization.
Q: NFA vs DFA (identify)
A: pikevm = NFA backtrack = DFA
Q: What's wrong with original implementation?
A: Nothing except it being slow and limited. My improved version of Ali's DFA
implementation ran 3.5X faster in any case, however I found a bug with it
where zero quantifier "?" nested groups compute wrong submatch results. To
fix this problem, it would require to undo a lot of optimization work already
done, basically going back to how slow Ali's implementation would be. The reason
this was spotted so late was because this kind of regex wasn't used before,
so I never tested it. Other than that I think submatch extraction is correct
on other cases. Pikevm does not have this bug, so it will be used as main
regex engine from now on, unless dfa ever finds a proper fix. Honestly, this
change isn't so surprising, as I was working on pikevm a few months prior, to
favor a superior algorithm.
You can still find that code here (likely with no updates):
.Lk https://github.com/kyx0r/nextvi/tree/dfa_dead
As a downside, NFA simulation loses the DFA property of being able to
quickly short circuit a match, as everything runs linearly and at constant
speed, incurring match time overhead. Well optimized DFA engine can
outperform pikevm, but that is rather rare as they got problems of their own.
For example as independently benchmarked, dfa_dead runs only 13% faster than
pikevm and that is stretching the limit of what is physically possible on a
table based matcher. Can't cheat mother nature, and if you dare to try she's
unforgiving at best.
Supplementary reading by Russ Cox:
.Lk https://swtch.com/~rsc/regexp/regexp1.html

Original Neatvi repository:
.Lk https://github.com/aligrudi/neatvi
.Ed
.
.Sh AUTHORS
.An -nosplit
.Nm
was written by
.An Kyryl Melekhin Aq Mt k.melekhin@gmail.com .
It is based on
.Xr neatvi 1 Ns ,
which was written by
.An Ali Gholami Rudi Aq Mt ali@rudi.ir .
.\" add more contributors here?
This manual page was inspired by
.An népéta Aq Mt nepeta@canaglie.net
