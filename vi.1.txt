.Dd Sep 12, 2024
.Dt Nextvi 1
.Os
.
.Sh NAME
.Nm Nextvi
.Nd A small vi/ex editor for editing bidirectional UTF-8 text
.
.Sh SYNOPSIS
.Nm vi
.Op Fl emsv
.Op Ar
.
.Sh DESCRIPTION
.Nm Nextvi
is a
.Xr vi 1 Ns -like
text editor based on Ali Gholami Rudi's
.Xr Neatvi 1 Ns .
Invented by Bill Joy in 1976, VI (Visual Editor) is a text editor
that allows users to edit and manipulate text in a visual mode.
It is a command-line editor that uses a set of keystrokes and
commands to navigate and modify text. VI is a powerful and efficient
editor that is widely used in Unix and Linux environments. It
is known for its modal interface, where the user can switch
between insert, command, and visual modes to perform different
actions. It is also popular among developers and system administrators
due to its flexibility and customization options. VI's syntax
and command set are similar to those of other vi/ex editors,
making it a versatile tool for users who are familiar with other
text editors. 50 years later, a superior vi implementation has
been created. Nextvi is a masterpiece, a symphony of efficiency
and elegance. It boasts a blazing fast startup time, unrivaled
portability, hackability, a god powerful macro system and so
much more.
.
.Sh OPTIONS
.Bl -tag -width Ds -compact
.It Fl e
Enter Ex mode on startup
.It Fl m
Disable initial file read message
.It Fl s
When combined with -e enters limited Ex mode
.It Fl v
Enter visual mode on startup. (Default)
.El
.Sh NOTATION
.Bl -tag -width Ds -compact
.It Cm arg1-
An optional number prefixing a command
.It Cm -arg2
A required argument suffixing a command
.It Cm C-
A ctrl key
.It Cm Space
A separation, multiple binds to the same command
.El
.Sh VI NORMAL
.Bl -tag -width Dq -compact
.It Cm arg1-+ arg1-\en arg1-j
Move the cursor arg1 lines down
.It Cm arg1-- arg1-k
Move the cursor arg1 lines up
.It Cm ^
Move the cursor to the start of the line after indentation

.It Cm arg1-#
Enable/Disable line numbers and switch modes:
.Bl -nested -compact
.It
# - single shot print, shows global and relative numbers.
.It
2# - permanent. shows global numbers.
.It
4# - permanent. shows relative numbers after indentation.
.It
8# - permanent. shows relative numbers.
.El

.It Cm C-^ C-6
Switch to previous buffer
.It Cm arg1-C-r
Redo arg1 times
.It Cm arg1-u
Undo arg1 times
.It Cm C-i TAB
Open file using text from the cursor to eol
.It Cm arg1-C-e
Scroll down 1 or arg1 lines. arg1 is set and stored, cursor position preserved
.It Cm arg1-C-y
Scroll up 1 or arg1 lines. arg1 is set and stored, cursor position preserved
.It Cm arg1-C-d
Scroll down half a screen size. If arg1 set scroll to arg1 lines
.It Cm arg1-C-u
Scroll up half a screen size. If arg1 set scroll to arg1 lines
.It Cm C-b
Scroll up full screen size
.It Cm C-f
Scroll down full screen size
.It Cm C-k
Write the current buffer to file. 2nd attempt force writes
.It Cm arg1-C-w-arg2
Unindent arg2 region
.It Cm arg1-<-arg2
Indent left arg2 region
.It Cm arg1->-arg2
Indent right arg2 region
.It Cm @-arg2
Execute a arg2 register macro
.It Cm @@
Execute a last executed register macro on a new line
.It Cm arg1-.
Repeat last normal command arg1 times
.It Cm arg1-v.
Repeat last normal command moving down across arg1 lines
.It Cm :
Enter vi mode ex prompt
.It Cm arg1-!-arg2
Enter pipe ex prompt based on the region specified by arg1 or arg2
.It Cm vv
Open ex prompt with the last ex command from history
.It Cm arg1-vr
Open %s/ ex prompt. arg1 specifies word(s) from the cursor to be inserted
.It Cm arg1-vt-arg2
Open .,.+0s/ ex prompt. arg1 specifies number of lines from the cursor. arg2 specifies word(s) from the cursor to be inserted
.It Cm arg1-v/
Open v/ xkwd ex prompt to set search keyword. arg1 specifies word(s) from the cursor to be inserted
.It Cm v;
Open ! ex prompt
.It Cm vb
Switch to b-1 history buffer
.It Cm arg1-vi
Open %s/^ {8}/	/g ex prompt. Contains regex for changing spaces to tabs. arg1 modifies the width
.It Cm arg1-vI
Open %s/^	/        /g ex prompt. Contains regex for changing tabs to spaces. arg1 modifies the width
.It Cm vo
Removes \er character from line endings and trailing white spaces
.It Cm va
Toggle autoindent on or off. see xai
.It Cm C-g
Print buffer status infos
.It Cm arg1-C-g
Enable permanent status bar row
.It Cm ga
Print character info
.It Cm arg1-ga
Enable permanent character info bar row
.It Cm arg1-gw
Hard wrap a line to arg1 col limit
.It Cm arg1-gq
Hard wrap a buffer to arg1 col limit
.It Cm gg
Goto the first line in the buffer
.It Cm g~-arg2
Switch case for arg2 region
.It Cm gu-arg2
Switch to lowercase for arg2 region
.It Cm gU-arg2
Switch to uppercase for arg2 region
.It Cm arg1-~
Switch case arg1 times forward
.It Cm '-arg2
Goto a line mark arg2
.It Cm m-arg2
Set a buffer local line mark arg2
.It Cm i
Enter insert mode
.It Cm I
Enter insert moving cursor to the start of the line after indentation
.It Cm a
Enter insert mode 1 character forward
.It Cm A
Enter insert mode moving cursor to the eol
.It Cm s
Enter insert mode deleting character under the cursor
.It Cm S
Enter insert mode deleting everything on the line
.It Cm o
Enter insert mode creating a new line down
.It Cm O
Enter insert mode creating a new line up
.It Cm arg1-c-arg2
Enter insert mode deleting based on the arg2 motion region
.It Cm C
Enter insert mode deleting from cursor to the eol
.It Cm arg1-d-arg2
Delete a arg2 region
.It Cm D
Delete from a cursor to the eol
.It Cm di-arg2
Delete around arg2 which can be ( or ) or \&"
.It Cm ci-arg2
Change around arg2 which can be ( or ) or \&"
.It Cm K
Split a line
.It Cm arg1-K
Split a line without creating empty new lines
.It Cm arg1-J
Join arg1 lines
.It Cm vj
Raw line join mode, disables space padding when joining lines
.It Cm arg1-y-arg2
Yank a region
.It Cm Y yy
Yank a line
.It Cm arg1-p
Paste a default register
.It Cm arg1-P
Paste a default register below current line or behind cursor pos
.It Cm \&"-arg2
Operation on the register arg2
.It Cm R
Print registers and their contents
.It Cm V
Toggle show hidden characters: Space,Tab,New line
.It Cm arg1-r-arg2
Replace arg1 characters with arg2 under the cursor forward
.It Cm C-v
Show line motion numbers for ebEBwW. Switches its modes
.It Cm arg1-C-v
Disable line motion numbers
.It Cm arg1-G
Goto the last line in the buffer or arg1 line
.It Cm H
Goto the highest line of the screen
.It Cm L
Goto the lowest line of the screen
.It Cm M
Goto the middle line of the screen
.It Cm arg1-x
Delete arg1 characters under the cursor forward
.It Cm arg1-X
Delete arg1 characters under the cursor backward
.It Cm arg1-,
Repeat last f or F or t or F command backward arg1 times
.It Cm arg1-;
Repeat last f or F or t or F command forward arg1 times
.It Cm arg1-h
Move the cursor arg1 cols left
.It Cm arg1-l
Move the cursor arg1 cols right
.It Cm f-arg2
Move the cursor to the arg2 character found forward
.It Cm F-arg2
Move the cursor to the arg2 character found backward
.It Cm t-arg2
Move the cursor until the arg2 character found forward
.It Cm T-arg2
Move the cursor until the arg2 character found backward
.It Cm arg1-B
Move the cursor to the end of the word skipping punctuation backward arg1 times
.It Cm arg1-E
Move the cursor to the end of the word skipping punctuation forward arg1 times
.It Cm arg1-b
Move the cursor to the end of the word backward arg1 times
.It Cm arg1-e
Move the cursor to the end of the word forward arg1 times
.It Cm arg1-W
Move the cursor to the start of the word skipping punctuation forward arg1 times
.It Cm arg1-w
Move the cursor to the start of the word forward arg1 times
.It Cm {
Move the cursor to the next { region up
.It Cm }
Move the cursor to the next { region down
.It Cm [
Move the cursor to the next \en region up
.It Cm ]
Move the cursor to the next \en region down
.It Cm C-]
Filesystem search forward based on directory listing in b-2
.It Cm arg1-C-]
Filesystem search forward, setting search keyword to arg1 words under the cursor
.It Cm C-p
Filesystem search backward based on directory listing in b-2
.It Cm C-t
Set a global file mark
.It Cm arg1-C-t
Set or switch to a global mark based on arg1 % 2 == 0
.It Cm arg1-C-7 arg1-C-_
Show buffer list and switch based to arg1 buffer or 0-9 when prompted
.It Cm 0 |
Move the cursor to the start of the line.
.It Cm arg1-z.
Center the screen. arg1 is xtop
.It Cm arg1-z\en
Center the screen at top row. arg1 is xtop
.It Cm arg1-z-
Center the screen at bottom row. arg1 is xtop
.It Cm z-arg2
Change alternate keymap to arg2
.It Cm ze zf
Switch to the English and alternate keymap
.It Cm zL zl zr zR
Change the value of td option
.It Cm $
Move the cursor to the eol
.It Cm arg1-|
Move the cursor to arg1 col
.It Cm arg1-/
Search using regex down skipping arg1 matches
.It Cm arg1-?
Search using regex up skipping arg1 matches
.It Cm arg1-n
Repeat search down skipping arg1 matches
.It Cm arg1-N
Repeat search up skipping arg1 matches
.It Cm C-a
Auto search word under the cursor, not centering and wrapping up/down direction
.It Cm arg1-C-a
Auto search setting arg1 words from the cursor
.It Cm arg1-Space
Move cursor arg1 character forward
.It Cm arg1-C-h arg1-Backspace
Move cursor arg1 character backward
.It Cm `-arg2
Goto a line mark arg2 with horizonal position
.It Cm %
Move the cursor to [](){} pair
.It Cm arg1-%
Move the cursor to the arg1 percent line number
.It Cm arg1-C-n
Swap to the next buffer, arg1 changes direction (forward/backward)
.It Cm \e
Swap to /fm/ buffer b-2
.It Cm C-z
Suspend vi
.It Cm C-l
Force redraw whole screen and update terminal dimensions
.It Cm qq
Force quit cleaning the terminal
.It Cm zz
Force quit not cleaning the terminal, submits commands if recursive
.It Cm ZZ
Soft quit, attempting to write the file before exit
.El
.
.Sh INSERT MODE
.Bl -tag -width Dq -compact
.It Cm C-h Backspace
Delete a character
.It Cm C-u
Delete util C-x mark or everything
.It Cm C-w
Delete a word
.It Cm C-t
Increase indent
.It Cm C-d
Decrease indent
.It Cm C-]
Switch a default paste register to 0-9
.It Cm C-\e-arg2
Select paste register arg2. \e selects default register
.It Cm C-p
Paste a register
.It Cm C-g
Index a buffer for autocomplete
.It Cm C-y
Reset autocomplete db
.It Cm C-r
Loop through autocomplete options backward
.It Cm C-n
Loop through autocomplete options forward
.It Cm C-z
Suspend vi/ex
.It Cm C-x
Set a mark for C-u and completion starting position
.It Cm C-b
Open history buffer b-1 when in ex prompt, otherwise print autocomplete options
.It Cm C-a
Loop through the strings from a history buffer b-1
.It Cm C-l
Redraw the screen in vi mode, clean the terminal in ex
.It Cm C-o
Switch between vi and ex modes
.It Cm C-e
Switch to english keymap
.It Cm C-f
Switch to alternative keymap
.It Cm C-v-arg2
Read a literal character arg2
.It Cm C-k-arg2
Read a diagraph sequence arg2
.It Cm C-c ESC
Exit insert mode
.El
.
.Sh EX
Ex is a line editor for Unix systems originally written by Bill Joy in 1976.
In ex, every command is prefixed with ':'. Ex is essential to vi, which allows it
to run commands and macros. Together vi and ex create a beautiful symbiosis, which 
complements each other and helps to solve various domain problems.
.
.Sh EX RANGES
Some ex commands can be prefixed with ranges.
.Bl -tag -width Ds -compact
.It Cm Example: print lines 1,5
:1,5p
.It Cm Example: print 5 lines around xrow
:.-5,.+5p
.It Cm Example: print until int is found
:.,/int/p
.It Cm Example: print until int is found in reverse
:?int?,.p
.Bd -literal -compact
Note: in some cases . can be dropped but is kept for readability.
.Ed
.It Cm Example: print lines from mark d to mark a
:'d,'ap
.El
.
.Sh EX COMMANDS
.Bl -tag -width Ds -compact
.It Cm f
Ranged search (stands for find)
.Bd -literal
Example (no range given, current line only):
:f/int
or
:f?int
or (specified range)
:10,100f/int
Additionally, :f supports xoff (horizontal offset). This is
essential for scripting macros. Subsequent commands within the
range will move to the next match just like n/N.
.Ed

.It Cm b
Print currently active buffers and their state
.It Cm bp
Set current buffer path
.It Cm bs
Set current buffer saved. If arg given, reset undo/redo history
.It Cm p
Print line(s) from the buffer

.It Cm ea
Open file based on it's filename substring and from listing in b-2
.Bd -literal
If the substring matches more than 1 filename, a prompt will
be shown. Submit using numbers 0-9 (higher ascii values work
too (^c to cancel)). Passing an extra arg to :ea in form of
a number will bypass the prompt and open the corresponding file.
.Ed

.It Cm ea!
Forced version of ea
.It Cm a
Enter ex append mode (exiting with ^c will discard changes)
.It Cm i
Enter ex insert mode (exiting with ^c will discard changes)
.It Cm c
Enter ex change mode (exiting with ^c will discard changes)
.It Cm d
Delete a line
.It Cm e
Open a file at path
.It Cm e!
Reload the current buffer from FS

.It Cm g
Global command
.Bd -literal
Same syntax as ex substitution command, but instead of replacement
string it takes an ex command after the / / enclosed regex.
Example: remove empty lines
:g/^$/d
Try doing similar with substitution command - will not work
as removing '\en' without deleting the line is invalid, but
it will work with global command. Multiple ex commands can be
chained in one global command.
In this case the ex separator has to be escaped once.
Example: yank matches and print them out.
:g/int/ya A\e|p
If you wanted to get really fancy, it is possible to nest global
commands inside of global commands.
Example: find all lines with int and a semicolon and append "has a semicolon"
:g/int/:.g/;/tp A has a semicolon
.Ed

.It Cm g! v
Inverted global command
.It Cm =
Move the cursor to a line number
.It Cm k
Set a mark

.It Cm tp
Global macro (stands for term_push)
.Bd -literal
It can run any vi normal command and execute insert statements.
The advantage of tp over traditional macros is in the ability
to bypass the macro queue and run independently. In a way, macro
executed by tp exercises the same causality as running C code
directly.
.Ed

.It Cm pu
Paste a register
.Bd -literal
:pu command can pipe the register to an external program by
specifying \e! as a 2nd argument.
.Ed

.It Cm q
Soft quit
.It Cm q!
Force quit

.It Cm r
Read a file
.Bd -literal
To read data from a pipe use :r \e!date
.Ed

.It Cm w
Soft write a to file
.Bd -literal
To pipe data to external process use :w \e!less
.Ed

.It Cm w!
Force write a to file
.It Cm wq x
Write and soft quit
.It Cm wq! x!
Write and force quit
.It Cm u
Undo
.It Cm rd
Redo

.It Cm se
Set a variable
.Bd -literal
Examples:
:se var=1
:se novar
.Ed

.It Cm s
Substitute
.Bd -literal
Basic usage:
:%s/term1/term2/g

Substitution backreference:
This inserts the text of matched group specified by \ex where x is
group number. Example:
this is an example text for subs and has int or void
:%s/(int)\e|(void)/pre\e0after
this is an example text for subs and has preintafter or void
:%s/(int)\e|(void)/pre\e2after/g
this is an example text for subs and has prepreafterafter or prevoidafter
.Ed

.It Cm ya
Yank a region
.It Cm ya!
Reset register value
.It Cm !
Run external program

.It Cm ft
Set a filetype
.Bd -literal
Without filetype, prints the current file type. When filetype
is specified, sets the file type of the current ex buffer.
In nextvi :ft also reloads the highlight ft, which makes it
possible to reset dynamic highlights created by options like
"hlw".
.Ed

.It Cm cm cm!
Keymap
.Bd -literal
Without kmap, prints the current keymap name. When kmap is specified,
sets the alternate keymap to kmap and, unless ! is given, switches
to this keymap.
.Ed

.It Cm fd
Set a secondary directory (stands for file dir)
.Bd -literal
Recalculates the directory listing for fssearch or :ea ex command.
No argument implies current directory.
.Ed

.It Cm fp
Set a secondary directory path (stands for file path)
.It Cm cd
Set a working directory (stands for change dir)

.It Cm inc
Include regex for :fd calculation
.Bd -literal
Example 1:
We want to get only files in submodule directory that end with .c
extension:
:inc submodule.*\e.c$
Example 2:
Exclude the .git and submodule folders.
:inc (^[\e!.git\e!submodule]+[^\e/]+$)
Running "inc" without an arg will disable all filters.
.Ed

.It Cm bx
Set max number of buffers allowed (default is 10)

.It Cm ac
Set autocomplete filter regex
.Bd -literal
Running ex command "ac" with no argument will reset back to
the default word filtering regex. You can find its string in
led.c as a reference.
.Ed
.
.El
.
.Sh EX OPTIONS
.Bl -tag -width Ds -compact
.
.It Cm ai
If set, indent new lines.
.
.It Cm ic
If set, ignore case in regular expressions.
.
.It Cm ish
.\" TODO
.
.It Cm grp
.\" TODO
.
.It Cm hl
If set, highlight text based on rules defined in
.Pa conf.c .
.
.It Cm hll
If set, highlight current line.
.
.It Cm hlp
If set, highlight pairs of brackets.
.
.It Cm hlr
If set, highlight text in reverse direction.
.
.It Cm hlw
If set, highlight current word.
.
.It Cm led
.\" TODO
.
.It Cm mpt
.\" TODO
.
.It Cm order
If set, reorder characters based on rules defined in
.Pa conf.c .
.
.It Cm pac
If set, print autocomplete suggestions on the fly.
.
.It Cm shape
If set, perform Arabic script letter shaping.
.
.It Cm tbs
Number of spaces used to represent a tab.
.
.It Cm td
Current text direction context.
This option accepts four meaningful values:
.Bl -tag -width Ds -compact
.It Ar +2
Exclusively left-to-right.
.It Ar +1
Follow
.Va dircontexts[]
(in
.Pa conf.c ) ,
defaulting to left-to-right.
.It Ar -1
Follow
.Va dircontexts[] ,
defaulting to right-to-left.
.It Ar -2
Exclusively right-to-left.
.
.El
.El
.
.Sh SPECIAL MARKS
.
.Sh SPECIAL YANK BUFFERS
.
.Sh SEE ALSO
.
.Sh AUTHORS
.An -nosplit
.Nm
was written by
.An Kyryl Melekhin Aq Mt k.melekhin@gmail.com .
It is based on
.Xr neatvi 1 Ns ,
which was written by
.An Ali Gholami Rudi Aq Mt ali@rudi.ir .
.\" add more contributors here?
This manual page was written by
.An népéta Aq Mt nepeta@canaglie.net
