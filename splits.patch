diff --git a/conf.c b/conf.c
index a6d30006..29967834 100644
--- a/conf.c
+++ b/conf.c
@@ -257,7 +257,7 @@ return|select|switch|type|var))\\>", A(GR1, BL1 | SYN_BD, YE1)},
 ((?:\\|.*?(?:(?<^\\\\)\\||$))*(?:<.*?(?:(?<^\\\\)<|$)|>.*?(?:(?<^\\\\)>|$))?[.$]?(?:'[a-z'`[\\]*])?\
 ([0-9]*)?)(?:([-*-+/%])([0-9]+))*(?:\\|.*?(?:(?<^\\\\)\\||$))*[ \t]*)*)\
 ((pac|pr|ai|ish|ic|grp|shape|seq|sep|tbs|td|order|hl[lwpr]?|left|lim|led|vis|mpt|err)\
-|[@&!?=dmj]|b[psx]?|p[uh]?|ac?|e[f!]?!?|f(?:\\+?[ \t]?([><])|[tdp+])?|inc|i|\
+|[@&!?=dmj]|b[psx]?|p[uh]?|ac?|e[f!]?!?|f(?:\\+?[ \t]?([><])|[tdp+])?|inc|i|sp|vs|\
 (?:g!?|s)[ \t]?(.)?|q!?|reg|rd?|w(?:q!|[q!])?|u[czb]?|x!?|ya!?|cm!?|cd?)?",
 		A(BL1 | SYN_BD, RE, RE, RE, RE, WH1, MA1, RE, RE, WH1, RE, GR1, CY1, MA1, MA1)},
 	{ex_ft, "\\\\(.)", A(AY1 | SYN_BD, YE)},
diff --git a/ex.c b/ex.c
index 78ceca6d..1e0cc9cc 100644
--- a/ex.c
+++ b/ex.c
@@ -38,6 +38,9 @@ struct buf *bufs;		/* main buffers */
 struct buf tempbufs[2];		/* temporary buffers, for internal use */
 struct buf *ex_buf;		/* current buffer */
 struct buf *ex_pbuf;		/* prev buffer */
+struct win *wins;		/* head of window list */
+struct win *curwin;		/* current active window */
+int nwins;			/* number of windows */
 static struct buf *ex_tpbuf;	/* temp prev buffer */
 static int xbufsmax;		/* number of buffers */
 static int xbufsalloc = 10;	/* initial number of buffers */
@@ -91,6 +94,9 @@ void bufs_switch(int idx)
 		ex_buf = &bufs[idx];
 	}
 	exbuf_load(ex_buf)
+	/* update current window's buffer reference */
+	if (curwin)
+		curwin->buf = ex_buf;
 }
 
 static int bufs_open(const char *path, int len)
@@ -152,6 +158,9 @@ void temp_switch(int i, int swap)
 	}
 	exbuf_load(ex_buf)
 	syn_setft(xb_ft);
+	/* update current window's buffer reference */
+	if (curwin)
+		curwin->buf = ex_buf;
 }
 
 void temp_write(int i, char *str)
@@ -558,11 +567,22 @@ static void *ec_buffer(char *loc, char *cmd, char *arg)
 
 static void *ec_quit(char *loc, char *cmd, char *arg)
 {
-	for (int i = 0; !strchr(cmd, '!') && i < xbufcur; i++)
+	/* q! always force quits */
+	if (strchr(cmd, '!')) {
+		xquit = -1;
+		return NULL;
+	}
+	/* if multiple windows, close current window */
+	if (nwins > 1) {
+		win_close();
+		return NULL;
+	}
+	/* single window: check for modified buffers and quit */
+	for (int i = 0; i < xbufcur; i++)
 		if ((xquit < 0 || xgrec < 2) && bufs[i].lb->modified)
 			return "buffers modified";
 	if (!xquit)
-		xquit = !strchr(cmd, '!') ? 1 : -1;
+		xquit = 1;
 	return NULL;
 }
 
@@ -1298,6 +1318,16 @@ _EO(left,
 	return NULL;
 )
 
+static void *ec_split(char *loc, char *cmd, char *arg)
+{
+	return win_split(0, arg);
+}
+
+static void *ec_vsplit(char *loc, char *cmd, char *arg)
+{
+	return win_split(1, arg);
+}
+
 #undef EO
 #define EO(opt) {#opt, eo_##opt}
 
@@ -1355,9 +1385,12 @@ static struct excmd {
 	{"uz", ec_setenc},
 	{"ub", ec_setenc},
 	{"u", ec_undoredo},
+	EO(vis),
+	{"vs", ec_vsplit},
 	EO(shape),
 	EO(seq),
 	EO(sep),
+	{"sp", ec_split},
 	{"s", ec_substitute},
 	{"x!", ec_write},
 	{"x", ec_write},
@@ -1379,7 +1412,6 @@ static struct excmd {
 	EO(left),
 	EO(lim),
 	EO(led),
-	EO(vis),
 	{"=", ec_num},
 	{"", ec_print}, /* do not remove */
 };
@@ -1526,6 +1558,209 @@ void ex(void)
 	xgrec--;
 }
 
+/* window management functions */
+static void curwin_save(void)
+{
+	if (curwin) {
+		curwin->row = xrow;
+		curwin->off = xoff;
+		curwin->top = xtop;
+		curwin->left = xleft;
+		curwin->buf = ex_buf;
+	}
+}
+
+static void curwin_load(void)
+{
+	if (curwin) {
+		xrow = curwin->row;
+		xoff = curwin->off;
+		xtop = curwin->top;
+		xleft = curwin->left;
+		if (curwin->buf != ex_buf) {
+			exbuf_save(ex_buf)
+			ex_buf = curwin->buf;
+			exbuf_load(ex_buf)
+			syn_setft(xb_ft);
+		}
+	}
+}
+
+void win_init(void)
+{
+	if (!wins) {
+		wins = emalloc(sizeof(struct win));
+		wins->buf = ex_buf;
+		wins->y = 0;
+		wins->x = 0;
+		wins->h = xrows;
+		wins->w = xcols;
+		wins->row = 0;
+		wins->off = 0;
+		wins->top = 0;
+		wins->left = 0;
+		wins->vsplit = 0;
+		wins->next = wins;  /* circular list */
+		curwin = wins;
+		nwins = 1;
+	}
+}
+
+void win_size(void)
+{
+	/* recalculate window sizes after terminal resize */
+	struct win *w = wins;
+	if (!w || nwins == 1) {
+		if (w) {
+			w->h = xrows;
+			w->w = xcols;
+			w->y = 0;
+			w->x = 0;
+		}
+		return;
+	}
+	/* for multiple windows, redistribute proportionally */
+	int y = 0, x = 0;
+	/* check if this is a vertical split layout */
+	int is_vsplit = wins->next->vsplit;
+	do {
+		if (!is_vsplit) {
+			/* horizontal split: stacked vertically */
+			w->h = (xrows - (nwins - 1)) / nwins;
+			w->w = xcols;
+			w->y = y;
+			w->x = 0;
+			y += w->h + 1;  /* +1 for separator */
+		} else {
+			/* vertical split: side by side */
+			w->w = (xcols - (nwins - 1)) / nwins;
+			w->h = xrows;
+			w->x = x;
+			w->y = 0;
+			x += w->w + 1;  /* +1 for separator */
+		}
+		w = w->next;
+	} while (w != wins);
+}
+
+void win_switch(struct win *w)
+{
+	if (w && w != curwin) {
+		curwin_save();
+		curwin = w;
+		curwin_load();
+	}
+}
+
+void win_close(void)
+{
+	struct win *w, *prev;
+	if (nwins <= 1)
+		return;
+	/* find previous window in circular list */
+	prev = curwin;
+	while (prev->next != curwin)
+		prev = prev->next;
+	/* remove curwin from list */
+	prev->next = curwin->next;
+	w = curwin;
+	if (wins == curwin)
+		wins = curwin->next;
+	curwin = prev->next;
+	free(w);
+	nwins--;
+	/* expand remaining window to fill space */
+	if (nwins == 1) {
+		wins->y = 0;
+		wins->x = 0;
+		wins->h = xrows;
+		wins->w = xcols;
+	} else {
+		win_size();
+	}
+	curwin_load();
+}
+
+void *win_split(int vertical, char *arg)
+{
+	struct win *newwin;
+	int newh, neww;
+
+	if (vertical) {
+		if (curwin->w < 10)
+			return "window too narrow";
+		neww = curwin->w / 2;
+	} else {
+		if (curwin->h < 4)
+			return "window too small";
+		newh = curwin->h / 2;
+	}
+
+	newwin = emalloc(sizeof(struct win));
+	if (vertical) {
+		/* vertical split: new window on right */
+		newwin->y = curwin->y;
+		newwin->x = curwin->x + neww + 1;  /* +1 for separator */
+		newwin->h = curwin->h;
+		newwin->w = curwin->w - neww - 1;
+		curwin->w = neww;
+	} else {
+		/* horizontal split: new window below */
+		newwin->y = curwin->y + newh + 1;  /* +1 for separator */
+		newwin->x = curwin->x;
+		newwin->h = curwin->h - newh - 1;
+		newwin->w = curwin->w;
+		curwin->h = newh;
+	}
+
+	/* copy cursor state from current window */
+	curwin_save();
+	newwin->row = curwin->row;
+	newwin->off = curwin->off;
+	newwin->top = curwin->top;
+	newwin->left = curwin->left;
+	newwin->vsplit = vertical;
+
+	/* handle buffer for new window */
+	if (arg && *arg) {
+		/* save original buffer for current window */
+		struct buf *origbuf = curwin->buf;
+		/* open specified file */
+		int fd = bufs_find(arg, strlen(arg));
+		if (fd >= 0) {
+			newwin->buf = &bufs[fd];
+		} else {
+			bufs_switch(bufs_open(arg, strlen(arg)));
+			newwin->buf = ex_buf;
+			int f = open(xb_path, O_RDONLY);
+			if (f >= 0) {
+				lbuf_rd(xb, f, 0, lbuf_len(xb));
+				close(f);
+			}
+			ex_bufpostfix(ex_buf, arg[0]);
+		}
+		/* restore current window's buffer and global state */
+		curwin->buf = origbuf;
+		ex_buf = origbuf;
+		exbuf_load(ex_buf)
+		syn_setft(xb_ft);
+		newwin->row = 0;
+		newwin->off = 0;
+		newwin->top = 0;
+		newwin->left = 0;
+	} else {
+		/* same buffer as current window */
+		newwin->buf = curwin->buf;
+	}
+
+	/* insert into circular list after current window */
+	newwin->next = curwin->next;
+	curwin->next = newwin;
+	nwins++;
+
+	return NULL;
+}
+
 void ex_init(char **files, int n)
 {
 	xbufsalloc = MAX(n, xbufsalloc);
diff --git a/led.c b/led.c
index 98ad4070..8ea29cc5 100644
--- a/led.c
+++ b/led.c
@@ -287,6 +287,9 @@ static void led_printparts(sbuf *sb, int pre, int ps,
 		return;
 	}
 	int dir, off, pos, psn = sb->s_n;
+	/* window offset for vsplit (not for prompts) */
+	int winx = (ai_max >= 0 && curwin) ? curwin->x : 0;
+	int winw = (ai_max >= 0 && curwin) ? curwin->w : xcols;
 	sbuf_str(sb, post)
 	sbufn_null(sb)
 	/* XXX: O(n) insertion; recursive array data structure cannot be optimized.
@@ -305,11 +308,11 @@ static void led_printparts(sbuf *sb, int pre, int ps,
 			pos = ren_cursor(r->s, r->pos[off-two]);
 		pos += dir < 0 ? -1 : 1;
 	}
-	if (pos >= xleft + xcols || pos < xleft)
-		xleft = pos < xcols ? 0 : pos - xcols / 2;
+	if (pos >= xleft + winw || pos < xleft)
+		xleft = pos < winw ? 0 : pos - winw / 2;
 	syn_blockhl = -1;
-	led_crender(r->s, -1, vi_lncol, xleft, xleft + xcols - vi_lncol);
-	term_pos(-1, led_pos(r->s, pos) + vi_lncol);
+	led_crender(r->s, -1, winx + vi_lncol, xleft, xleft + winw - vi_lncol);
+	term_pos(-1, winx + led_pos(r->s, pos) + vi_lncol);
 	sbufn_cut(sb, psn)
 	rstate -= 2;
 }
@@ -360,12 +363,16 @@ RS(2, led_crender(str, ctop+xrows, 0, 0, xcols)) \
 if (ai_max >= 0) \
 	term_pos(crow - ctop, 0); \
 
-static void led_redraw(char *cs, int r, int orow, int crow, int ctop, int flg)
+static void led_redraw(char *cs, int r, int orow, int crow, int ctop, int flg, int ai_max)
 {
+	/* window offset for vsplit (not for prompts) */
+	int winx = (ai_max >= 0 && curwin) ? curwin->x : 0;
+	int winw = (ai_max >= 0 && curwin) ? curwin->w : xcols;
+	int winh = (ai_max >= 0 && curwin) ? curwin->h : xrows;
 	rstate++;
-	for (int nl = 0; r < xrows; r++) {
+	for (int nl = 0; r < winh; r++) {
 		if (vi_lncol) {
-			term_pos(r, 0);
+			term_pos(r, winx);
 			term_kill();
 		}
 		if (r >= orow-ctop && r < crow-ctop) {
@@ -374,16 +381,16 @@ static void led_redraw(char *cs, int r, int orow, int crow, int ctop, int flg)
 			sbuf_mem(cb, cs, nl+!!cs[nl])
 			sbufn_null(cb)
 			rstate->s = NULL;
-			led_crender(cb->s, r, vi_lncol, xleft, xleft + xcols - vi_lncol)
+			led_crender(cb->s, r, winx + vi_lncol, xleft, xleft + winw - vi_lncol)
 			free(cb->s);
 			cs += nl+!!cs[nl];
 			continue;
 		}
 		nl = r < crow-ctop ? r+ctop : (r-(crow-orow+!!(flg & 4)))+ctop;
 		led_crender(lbuf_get(xb, nl) ? lbuf_get(xb, nl) : "~", r,
-			vi_lncol, xleft, xleft + xcols - vi_lncol)
+			winx + vi_lncol, xleft, xleft + winw - vi_lncol)
 	}
-	term_pos(crow - ctop, 0);
+	term_pos(crow - ctop, winx);
 	rstate--;
 }
 
@@ -506,7 +513,7 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 		case TK_CTL('z'):
 			term_suspend();
 			if (ai_max >= 0)
-				led_redraw(sb->s, 0, orow, crow, ctop, flg);
+				led_redraw(sb->s, 0, orow, crow, ctop, flg, ai_max);
 			continue;
 		case TK_CTL('x'):
 			is->sug_pt = is->sug_pt == len ? -1 : len;
@@ -564,7 +571,7 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 					syn_setft(xb_ft);
 					r++;
 				}
-				led_redraw(sb->s, r, orow, crow, ctop, flg);
+				led_redraw(sb->s, r, orow, crow, ctop, flg, ai_max);
 				continue;
 			}
 			temp_pos(0, -1, 0, 0);
@@ -585,6 +592,8 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 			else
 				restore(ex_buf)
 			exbuf_load(ex_buf)
+			if (curwin)
+				curwin->buf = ex_buf;
 			syn_setft(xb_ft);
 			vi(1); /* redraw past screen */
 			restore(ftidx)
@@ -606,7 +615,7 @@ static int led_line(sbuf *sb, int ps, int pre, char **post, int postn, char **po
 			if (ai_max < 0)
 				term_clean();
 			else
-				led_redraw(sb->s, 0, orow, crow, ctop, flg);
+				led_redraw(sb->s, 0, orow, crow, ctop, flg, ai_max);
 			continue;
 		case TK_CTL('o'): {
 			if (!*postref)
diff --git a/vi.c b/vi.c
index b8dd9d17..e43e7910 100644
--- a/vi.c
+++ b/vi.c
@@ -103,6 +103,23 @@ static void vi_drawmsg(void)
 	}
 }
 
+/* draw horizontal separator line at screen row */
+static void vi_draw_hsep(int row)
+{
+	term_pos(row, 0);
+	for (int i = 0; i < xcols; i++)
+		term_chr('-');
+}
+
+/* draw vertical separator line at screen column */
+static void vi_draw_vsep(int col, int y, int h)
+{
+	for (int i = 0; i < h; i++) {
+		term_pos(y + i, col);
+		term_chr('|');
+	}
+}
+
 static int vi_nextcol(char *ln, int dir, int *off)
 {
 	int o = ren_off(ln, ren_next(ln, ren_pos(ln, *off), dir));
@@ -126,23 +143,44 @@ for (i = 0, ret = 0;; i++) { \
 	ret = func; \
 } } \
 
+/* calculate screen row for buffer row in current window */
+static int win_scrrow(int row)
+{
+	return curwin ? curwin->y + (row - xtop) : row - xtop;
+}
+
+/* calculate effective window width */
+static int win_width(void)
+{
+	return curwin ? curwin->w : xcols;
+}
+
+/* calculate effective window height (rows visible) */
+static int win_height(void)
+{
+	return curwin ? curwin->h : xrows;
+}
+
 static void vi_drawrow(int row)
 {
 	int l1, i, i1, lnnum = vi_lnnum;
+	int wrows = win_height();
+	int wcols = win_width();
+	int scrrow = win_scrrow(row);
 	char *c, *s;
 	static char ch[5] = "~";
 	if (*vi_word && xled) {
 		int noff, nrow, ret;
 		s = lbuf_get(xb, row - vi_rshift);
 		c = lbuf_get(xb, xrow);
-		if (row == xtop + xrows-1 || !c || *c == '\n')
+		if (row == xtop + wrows-1 || !c || *c == '\n')
 			vi_rshift = 0;
 		if (row != xrow+1 || !c || *c == '\n')
 			goto skip;
-		char tmp[xcols+3], snum[32];
-		memset(tmp, ' ', xcols+1);
-		tmp[xcols+1] = '\n';
-		tmp[xcols+2] = '\0';
+		char tmp[wcols+3], snum[32];
+		memset(tmp, ' ', wcols+1);
+		tmp[wcols+1] = '\n';
+		tmp[wcols+2] = '\0';
 		i1 = isupper((unsigned char)*vi_word);
 		if (*vi_word == 'e' || *vi_word == 'E')
 			vi_drawnum(lbuf_wordend(xb, i1, 2, &nrow, &noff))
@@ -157,9 +195,9 @@ static void vi_drawrow(int row)
 		preserve(int, xorder, xorder = 0;)
 		preserve(int, syn_blockhl, syn_blockhl = -1;)
 		preserve(int, xtd, xtd = dir_context(c) * 2;)
-		vi_rshift = (row != xtop + xrows-1);
+		vi_rshift = (row != xtop + wrows-1);
 		syn_setft(n_ft);
-		RS(2, led_crender(tmp, row - xtop, 0, 0, xcols))
+		RS(2, led_crender(tmp, scrrow, curwin ? curwin->x : 0, 0, wcols))
 		syn_setft(xb_ft);
 		restore(xorder)
 		restore(syn_blockhl)
@@ -177,20 +215,20 @@ static void vi_drawrow(int row)
 		if (lnnum == 1 || lnnum & 2) {
 			c = itoa(row+1-vi_rshift, tmp);
 			*c++ = ' ';
-			i = snprintf(0, 0, "%d", xtop+xrows);
+			i = snprintf(0, 0, "%d", xtop+wrows);
 		}
 		p = c;
 		if (lnnum == 1 || lnnum & 4 || lnnum & 8) {
 			c = itoa(abs(xrow-row+vi_rshift), c);
 			*c++ = ' ';
-			i1 = snprintf(0, 0, "%d", xrows);
+			i1 = snprintf(0, 0, "%d", wrows);
 		}
 		*c = '\0';
 		l1 = (c - tmp) + (i+i1 - (strlen(tmp) - !!i - !!i1));
 		vi_lncol = dir_context(s) < 0 ? 0 : l1;
 		memset(c, ' ', l1 - (c - tmp));
 		c[l1 - (c - tmp)] = '\0';
-		led_crender(s, row - xtop, l1, xleft, xleft + xcols - l1)
+		led_crender(s, scrrow, (curwin ? curwin->x : 0) + l1, xleft, xleft + wcols - l1)
 		preserve(int, syn_blockhl, syn_blockhl = -1;)
 		syn_setft(nn_ft);
 		if ((lnnum == 1 || lnnum & 4) && !xleft && vi_lncol) {
@@ -200,39 +238,85 @@ static void vi_drawrow(int row)
 			i1 -= (itoa(abs(xrow-row+vi_rshift), tmp1) - tmp1)+1;
 			if (i1 >= 0) {
 				memset(p, ' ', strlen(p));
-				RS(2, led_prender(tmp1, row - xtop, l1+i1, 0, l1))
+				RS(2, led_prender(tmp1, scrrow, (curwin ? curwin->x : 0) + l1+i1, 0, l1))
 			}
 		}
-		RS(2, led_prender(tmp, row - xtop, 0, 0, l1))
+		RS(2, led_prender(tmp, scrrow, curwin ? curwin->x : 0, 0, l1))
 		syn_setft(xb_ft);
 		restore(syn_blockhl)
 		return;
 	}
-	led_crender(s, row - xtop, 0, xleft, xleft + xcols)
+	led_crender(s, scrrow, curwin ? curwin->x : 0, xleft, xleft + wcols)
 	rstate = rstates;
 }
 
 /* redraw the screen */
 static void vi_drawagain(int i)
 {
+	int wrows = win_height();
 	syn_scdir(0);
-	for (; i < xtop + xrows; i++)
+	for (; i < xtop + wrows; i++)
 		vi_drawrow(i);
 }
 
+/* draw all windows and separators */
+static void vi_draw_allwins(void)
+{
+	struct win *w = wins;
+	struct win *saved = curwin;
+	/* draw each window */
+	do {
+		curwin = w;
+		/* temporarily load window state */
+		xrow = w->row;
+		xoff = w->off;
+		xtop = w->top;
+		xleft = w->left;
+		if (w->buf != ex_buf) {
+			ex_buf = w->buf;
+			syn_setft(xb_ft);
+		}
+		syn_scdir(0);
+		for (int i = xtop; i < xtop + w->h; i++)
+			vi_drawrow(i);
+		/* draw separator if not last window */
+		if (w->next != wins) {
+			if (w->next->y > w->y) {
+				/* horizontal separator below this window */
+				vi_draw_hsep(w->y + w->h);
+			} else if (w->next->x > w->x) {
+				/* vertical separator to right of this window */
+				vi_draw_vsep(w->x + w->w, w->y, w->h);
+			}
+		}
+		w = w->next;
+	} while (w != wins);
+	/* restore current window */
+	curwin = saved;
+	xrow = saved->row;
+	xoff = saved->off;
+	xtop = saved->top;
+	xleft = saved->left;
+	if (saved->buf != ex_buf) {
+		ex_buf = saved->buf;
+		syn_setft(xb_ft);
+	}
+}
+
 /* update the screen */
 static void vi_drawupdate(int i)
 {
 	int n;
-	term_pos(0, 0);
+	int wrows = win_height();
+	term_pos(curwin ? curwin->y : 0, 0);
 	term_room(i);
 	syn_scdir(i);
 	if (i < 0) {
-		n = MIN(-i, xrows);
+		n = MIN(-i, wrows);
 		for (i = 0; i < n; i++)
-			vi_drawrow(xtop + xrows - n + i);
+			vi_drawrow(xtop + wrows - n + i);
 	} else {
-		n = MIN(i, xrows);
+		n = MIN(i, wrows);
 		for (i = n-1; i >= 0; i--)
 			vi_drawrow(xtop + i);
 	}
@@ -1179,14 +1263,15 @@ static void vi_argcmd(int arg, char cmd)
 }
 
 #define topfix() \
+{ int _wh = win_height(); \
 if (xrow < 0 || xrow >= lbuf_len(xb)) \
 	xrow = lbuf_len(xb) ? lbuf_len(xb) - 1 : 0; \
 if (xtop > xrow) \
-	xtop = xtop - xrows / 2 > xrow ? \
-			MAX(0, xrow - xrows / 2) : xrow; \
-if (xtop + xrows <= xrow) \
-	xtop = xtop + xrows + xrows / 2 <= xrow ? \
-			xrow - xrows / 2 : xrow - xrows + 1; \
+	xtop = xtop - _wh / 2 > xrow ? \
+			MAX(0, xrow - _wh / 2) : xrow; \
+if (xtop + _wh <= xrow) \
+	xtop = xtop + _wh + _wh / 2 <= xrow ? \
+			xrow - _wh / 2 : xrow - _wh + 1; } \
 
 void vi(int init)
 {
@@ -1194,11 +1279,22 @@ void vi(int init)
 	int mv, n, k, c;
 	xgrec++;
 	if (init) {
+		win_init();
 		topfix()
 		vi_col = vi_off2col(xb, xrow, xoff);
-		vi_drawagain(xtop);
+		if (nwins > 1) {
+			if (curwin) {
+				curwin->row = xrow;
+				curwin->off = xoff;
+				curwin->top = xtop;
+				curwin->left = xleft;
+			}
+			vi_draw_allwins();
+		} else
+			vi_drawagain(xtop);
 		vi_drawmsg();
-		term_pos(xrow - xtop, led_pos(lbuf_get(xb, xrow), vi_col));
+		term_pos((curwin ? curwin->y : 0) + xrow - xtop,
+			(curwin ? curwin->x : 0) + led_pos(lbuf_get(xb, xrow), vi_col));
 	}
 	while (!xquit) {
 		int nrow = xrow;
@@ -1246,12 +1342,12 @@ void vi(int init)
 			c = term_read();
 			switch (c) {
 			case TK_CTL('b'):
-				vi_scrollbackward(MAX(1, vi_arg) * (xrows - 1));
+				vi_scrollbackward(MAX(1, vi_arg) * (win_height() - 1));
 				xoff = lbuf_indents(xb, xrow);
 				vi_mod |= 4;
 				break;
 			case TK_CTL('f'):
-				vi_scrollforward(MAX(1, vi_arg) * (xrows - 1));
+				vi_scrollforward(MAX(1, vi_arg) * (win_height() - 1));
 				xoff = lbuf_indents(xb, xrow);
 				vi_mod |= 4;
 				break;
@@ -1270,7 +1366,7 @@ void vi(int init)
 					break;
 				if (vi_arg)
 					vi_scrollud = vi_arg;
-				n = vi_scrollud ? vi_scrollud : xrows / 2;
+				n = vi_scrollud ? vi_scrollud : win_height() / 2;
 				xrow = MAX(0, xrow - n);
 				if (xtop > 0)
 					xtop = MAX(0, xtop - n);
@@ -1282,10 +1378,10 @@ void vi(int init)
 					break;
 				if (vi_arg)
 					vi_scrollud = vi_arg;
-				n = vi_scrollud ? vi_scrollud : xrows / 2;
+				n = vi_scrollud ? vi_scrollud : win_height() / 2;
 				xrow = MIN(MAX(0, lbuf_len(xb) - 1), xrow + n);
-				if (xtop < lbuf_len(xb) - xrows)
-					xtop = MIN(lbuf_len(xb) - xrows, xtop + n);
+				if (xtop < lbuf_len(xb) - win_height())
+					xtop = MIN(lbuf_len(xb) - win_height(), xtop + n);
 				xoff = lbuf_indents(xb, xrow);
 				vi_mod |= 4;
 				break;
@@ -1403,6 +1499,24 @@ void vi(int init)
 				case 'v':
 					term_push(k == 'v' ? ":\x01" : ":\x02", 2); /* ^a : ^b */
 					break;
+				case 'c':
+					/* switch to next window */
+					if (nwins > 1) {
+						curwin->row = xrow;
+						curwin->off = xoff;
+						curwin->top = xtop;
+						curwin->left = xleft;
+						win_switch(curwin->next);
+						vi_mod |= 1;
+					}
+					break;
+				case 'd':
+					/* close current window */
+					if (nwins > 1) {
+						win_close();
+						vi_mod |= 1;
+					}
+					break;
 				case ';':
 					ln = vi_enprompt(":", "!", &n);
 					goto do_excmd;
@@ -1539,6 +1653,7 @@ void vi(int init)
 					term_done();
 					term_init();
 				}
+				win_size();
 				vi_status = vi_status ? xrows - 1: vi_status;
 				vi_mod |= 1;
 				break;
@@ -1738,19 +1853,29 @@ void vi(int init)
 			}
 		}
 		term_record = 1;
-		if (vi_mod & 1 || xleft != oleft
+		/* save cursor position to current window */
+		if (curwin) {
+			curwin->row = xrow;
+			curwin->off = xoff;
+			curwin->top = xtop;
+			curwin->left = xleft;
+		}
+		/* always do full redraw when multiple windows are active */
+		if (nwins > 1) {
+			vi_draw_allwins();
+		} else if (vi_mod & 1 || xleft != oleft
 				|| (vi_lnnum && orow != xrow && !(vi_lnnum == 2))
-				|| (*vi_word && orow != xrow))
+				|| (*vi_word && orow != xrow)) {
 			vi_drawagain(xtop);
-		else if (*vi_word && (ooff != xoff || vi_mod & 2)
-				&& xrow+1 < xtop + xrows) {
+		} else if (*vi_word && (ooff != xoff || vi_mod & 2)
+				&& xrow+1 < xtop + win_height()) {
 			vi_drawrow(xrow+1);
 			vi_rshift = 0;
 		} else if (xtop != otop)
 			vi_drawupdate(otop - xtop);
 		if (xhll) {
 			syn_blockhl = -1;
-			if (xrow != orow && orow >= xtop && orow < xtop + xrows)
+			if (xrow != orow && orow >= xtop && orow < xtop + win_height())
 				if (!(vi_mod & 1) && !*vi_word)
 					vi_drawrow(orow);
 			syn_blockhl = -1;
@@ -1768,7 +1893,7 @@ void vi(int init)
 			vi_msg[0] = '\0';
 		} else
 			vi_drawmsg();
-		term_pos(xrow - xtop, n + vi_lncol);
+		term_pos((curwin ? curwin->y : 0) + xrow - xtop, (curwin ? curwin->x : 0) + n + vi_lncol);
 		term_commit();
 		xb->useq += xseq;
 	}
diff --git a/vi.h b/vi.h
index a6f6348d..81eafcb3 100644
--- a/vi.h
+++ b/vi.h
@@ -406,6 +406,25 @@ struct buf {
 	long mtime;			/* modification time */
 	signed char td;			/* text direction */
 };
+
+/* window management for splits */
+struct win {
+	struct buf *buf;		/* buffer displayed in this window */
+	int y, x;			/* top-left screen position */
+	int h, w;			/* height and width */
+	int row, off, top;		/* cursor position within window */
+	int left;			/* horizontal scroll offset */
+	int vsplit;			/* 1 if created by vertical split */
+	struct win *next;		/* next window (circular list) */
+};
+extern struct win *wins;		/* head of window list */
+extern struct win *curwin;		/* current active window */
+extern int nwins;			/* number of windows */
+void win_init(void);
+void win_size(void);
+void win_switch(struct win *w);
+void win_close(void);
+void *win_split(int vertical, char *arg);
 /* ex options */
 extern int xleft;
 extern int xvis;
